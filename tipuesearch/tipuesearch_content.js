var tipuesearch = {"pages":[{"text":"openpde Developer Info Francesco Salvadore","tags":"","loc":"index.html","title":" openpde "},{"text":"Concrete class of field for Finite Difference 1D. Source Code !< Concrete class of field for Finite Difference 1D. module opendiff_field_fd_1d !< Concrete class of field for Finite Difference 1D. use opendiff_adt_field use opendiff_adt_mesh use opendiff_kinds use opendiff_mesh_fd_1d implicit none private public :: field_fd_1d type , extends ( field ) :: field_fd_1d !< Finite difference 1D class for *field* handling. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred methods procedure , private :: add !< Add fields. procedure , private :: assign_field !< Assign fields. procedure , private :: associate_mesh !< Associate field to a mesh. procedure :: init !< Initilize field. procedure :: output !< Output field data. procedure , private :: sub !< Subtract fields. procedure , private :: mul !< Multiply fields. procedure , private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. ! public methods procedure :: set !< Set field. ! operators endtype field_fd_1d contains function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_fd_1d ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to assign' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate if ( allocated ( lhs % val )) deallocate ( lhs % val ) n = mesh_cur % n ng = mesh_cur % ng allocate ( lhs % val ( 1 - ng : n + ng )) lhs % m => rhs_cur % m lhs % val = rhs_cur % val end subroutine assign_field subroutine associate_mesh ( this , fieldmesh , error ) !< Associate field to a mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_fd_1d ), pointer :: fieldmesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( fieldmesh ) type is ( mesh_fd_1d ) fieldmesh_cur => fieldmesh class default STOP 'Error passing mesh' end select this % m => fieldmesh_cur n = fieldmesh_cur % n ng = fieldmesh_cur % ng if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - ng : n + ng )) if ( present ( error )) error = 0 end subroutine associate_mesh elemental subroutine free ( this ) !< Free dynamic memory. class ( field_fd_1d ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % val )) deallocate ( this % val ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free subroutine init ( this , fieldmesh , description , error ) !< Initialize finite difference 1D field. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. integer ( I4P ) :: i !< Counter. call this % free call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description !        call random_number(this%val) select type ( fieldmesh ) type is ( mesh_fd_1d ) mesh_cur => fieldmesh class default STOP 'Error setting mesh' end select n = mesh_cur % n ng = mesh_cur % ng print * , \"number of points of mesh in init n,ng: \" , n , ng do i = 1 - ng , n + ng this % val ( i ) = sin ( i * 2. * acos ( - 1. ) / n ) enddo if ( present ( error )) error = 0 end subroutine init function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs end function mulreal subroutine output ( this , filename , error ) !< Output field data. class ( field_fd_1d ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , 1 ) imax = ubound ( this % val , 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_fd_1d ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => rhs % m opr_cur % val = lhs * rhs % val end function realmul subroutine set ( this , fieldmesh , description , val , error ) !< Set mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( fieldmesh )) call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val - rhs_cur % val end function sub end module opendiff_field_fd_1d","tags":"","loc":"sourcefile/opendiff_field_fd_1d.f90.html","title":"opendiff_field_fd_1d.f90 – openpde"},{"text":"Abstract class of field. Source Code !< Abstract class of field. module opendiff_adt_field !< Abstract class of field. use opendiff_adt_mesh use opendiff_kinds implicit none private public :: field type , abstract :: field !< Abstract class for *field* handling. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred methods procedure ( abstract_simmetric_operator ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_associate_mesh ), private , deferred :: associate_mesh !< Associate field to a mesh. procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_simmetric_operator ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_output ), deferred :: output !< Output field data. procedure ( abstract_simmetric_operator ), private , deferred :: sub !< Subtract fields. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. !RIMETTERE !procedure :: assigreal   => assigreal_mesh_fd_1d_scal ! public methods procedure :: free !< Free dynamic memory. ! operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. endtype field abstract interface !< Symmetric operator field.op.field. function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) !< Symmetric operator field.op.field. import :: field class ( field ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_simmetric_operator endinterface abstract interface !< Non symmetric operator field.op.real. function abstract_field_op_real ( lhs , rhs ) result ( opr ) !< Non symmetric operator field.op.real. import :: field , R_P class ( field ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_field_op_real endinterface abstract interface !< Non symmetric operator real.op.field. function abstract_real_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator real.op.field. import :: field , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_real_op_field endinterface abstract interface !< Assignment overloading. subroutine abstract_assign ( lhs , rhs ) !< Assignment overloading. import :: field class ( field ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. end subroutine abstract_assign endinterface abstract interface !< Associate a mesh to field. subroutine abstract_associate_mesh ( this , fieldmesh , error ) !< Associate a mesh to field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_associate_mesh endinterface abstract interface !< Initialize the field. subroutine abstract_init ( this , fieldmesh , description , error ) !< Initialize the field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< The mesh. character ( * ), intent ( in ), optional :: description !< Description of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Output the field. subroutine abstract_output ( this , filename , error ) !< Output the field. import :: field , I_P class ( field ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output fiel name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_output endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( field ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free end module opendiff_adt_field","tags":"","loc":"sourcefile/opendiff_adt_field.f90.html","title":"opendiff_adt_field.f90 – openpde"},{"text":"Abstract class of equation. Source Code !< Abstract class of equation. module opendiff_adt_equation !< Abstract class of equation. use json_module use opendiff_adt_field use opendiff_kinds implicit none private public :: equation type , abstract :: equation !< Abstract class for *equation* handling. !< !< The concrete types are implemented at application level (by the user) !< predefined examples might be provided as well. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred methods procedure ( abstract_bc ), deferred :: bc !< Equation boundary condition. procedure ( abstract_forcing ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), deferred :: init !< Initialize the equation. ! public methods procedure :: free !< Free dynamic memory. generic :: load => load_from_json !< Load equation definition from file. ! private methods procedure :: load_from_json !< Load equation definition from jSON file. endtype equation abstract interface !< Equation boundary condition. subroutine abstract_bc ( this , inp , t ) !< Equation boundary condition. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. end subroutine abstract_bc endinterface abstract interface !< Initialize equation. function abstract_init ( this ) result ( error ) !< Initialize equation. import :: equation , field , I_P class ( equation ), intent ( inout ) :: this !< The equation. integer ( I_P ) :: error !< Error status. end function abstract_init endinterface abstract interface !< Return the field after forcing the equation. function abstract_forcing ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed. end function abstract_forcing endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free subroutine load_from_json ( this , filename , error ) !< Load equation definition from JSON file. class ( equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. type ( json_file ) :: json !< JSON file handler. !logical                                :: found call json % initialize () call json % load_file ( filename = filename ) !call json%get('version.major', i, found) endsubroutine load_from_json end module opendiff_adt_equation","tags":"","loc":"sourcefile/opendiff_adt_equation.f90.html","title":"opendiff_adt_equation.f90 – openpde"},{"text":"Abstract class of spatial operator. Source Code !< Abstract class of spatial operator. module opendiff_adt_spatial_operator !< Abstract class of spatial operator. use opendiff_adt_field implicit none private public :: spatial_operator type , abstract :: spatial_operator !< Abstract class for *spatial operator* handling. character ( len = :), allocatable :: description !< Operator description. contains procedure ( abstract_operate ), deferred :: operate !< Operator operation. endtype spatial_operator abstract interface !< Operator operation. function abstract_operate ( this , inp ) result ( opr ) !< Operator operation. import :: spatial_operator , field class ( spatial_operator ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. end function abstract_operate endinterface end module opendiff_adt_spatial_operator","tags":"","loc":"sourcefile/opendiff_adt_spatial_operator.f90.html","title":"opendiff_adt_spatial_operator.f90 – openpde"},{"text":"opendiff kinds: definition of reals and integer kind parameters of opendiff library. Source Code !< opendiff kinds: definition of reals and integer kind parameters of opendiff library. module opendiff_kinds !< opendiff kinds: definition of reals and integer kind parameters of opendiff library. implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. endmodule opendiff_kinds","tags":"","loc":"sourcefile/opendiff_kinds.f90.html","title":"opendiff_kinds.f90 – openpde"},{"text":"Concrete class of Euler integrator. Source Code !< Concrete class of Euler integrator. module opendiff_integrator_euler !< Concrete class of Euler integrator. use opendiff_adt_equation use opendiff_adt_field use opendiff_adt_integrator use opendiff_field_fd_1d use opendiff_kinds implicit none private public :: integrator_euler type , extends ( integrator ) :: integrator_euler !< Euler integrator. contains procedure :: integrate !< Integrate the field accordingly the equation. endtype integrator_euler contains function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the equation by means of the Euler scheme. class ( integrator_euler ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary ! select type(inp) !     type is(field_fd_1d) !         print *,\"t, dt, inp: \",t, this%dt, inp%val ! end select allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? call equ % bc ( inp = inp , t = t ) for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate end module opendiff_integrator_euler","tags":"","loc":"sourcefile/opendiff_integrator_euler.f90.html","title":"opendiff_integrator_euler.f90 – openpde"},{"text":"Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Source Code !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. module opendiff_spatial_operator_der1_fd_1d !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. use opendiff_adt_field use opendiff_adt_spatial_operator_der1 use opendiff_field_fd_1d use opendiff_kinds use opendiff_mesh_fd_1d implicit none private public :: spatial_operator_der1_fd_1d type , extends ( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d !< Concrete class of spatial operator for first derivative for Finite Difference 1D. contains procedure :: operate !< Operator operation. endtype spatial_operator_der1_fd_1d contains function operate ( this , inp ) result ( opr ) !< Operator operation. class ( spatial_operator_der1_fd_1d ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_fd_1d ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. real ( R_P ) :: h !< Space step. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: ng !< Number of ghost cells. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to spatial operate' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate h = mesh_cur % h n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => mesh_cur do i = 1 , n !opr_cur%val(i) = (inp_cur%val(i+1) - inp_cur%val(i-1))/(2.*h) opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( h ) enddo !opr_cur%val(1) = (inp_cur%val(2) - inp_cur%val(n))/(2.*h) !opr_cur%val(n) = (inp_cur%val(1) - inp_cur%val(n-1))/(2.*h) end function operate end module opendiff_spatial_operator_der1_fd_1d","tags":"","loc":"sourcefile/opendiff_spatial_operator_der1_fd_1d.f90.html","title":"opendiff_spatial_operator_der1_fd_1d.f90 – openpde"},{"text":"opendiff: Open Fortran Library for PDE solving. Source Code !< opendiff: Open Fortran Library for PDE solving. module opendiff !< opendiff: Open Fortran Library for PDE solving. use opendiff_adt_equation use opendiff_adt_field use opendiff_adt_integrator use opendiff_adt_mesh use opendiff_adt_spatial_operator use opendiff_adt_spatial_operator_der1 use opendiff_field_fd_1d use opendiff_integrator_euler use opendiff_kinds use opendiff_mesh_fd_1d use opendiff_spatial_operator_der1_fd_1d implicit none private public :: equation public :: field public :: field_fd_1d public :: integrator public :: integrator_euler public :: mesh public :: mesh_fd_1d public :: spatial_operator public :: spatial_operator_der1 public :: spatial_operator_der1_fd_1d ! kinds public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P end module opendiff","tags":"","loc":"sourcefile/opendiff.f90.html","title":"opendiff.f90 – openpde"},{"text":"Concrete class of mesh for Finite Difference 1D. Source Code !< Concrete class of mesh for Finite Difference 1D. module opendiff_mesh_fd_1d !< Concrete class of mesh for Finite Difference 1D. use opendiff_adt_mesh use opendiff_kinds use vtk_fortran implicit none private public :: mesh_fd_1d type , extends ( mesh ) :: mesh_fd_1d !< Finite difference 1D class for *mesh* handling. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: ng !< Number of ghost points. integer ( I_P ) :: s !< Number of replicas for steps/stages. real ( R_P ) :: h !< Cell size. contains procedure :: init !< Initilize mesh. procedure :: output !< Output data. procedure :: set !< Set mesh. endtype mesh_fd_1d contains pure subroutine init ( this , description , error ) !< Initialize mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % n = 50 this % ng = 2 this % s = 1 this % h = 0.05_R8P if ( present ( error )) error = 0 end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_fd_1d ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set end module opendiff_mesh_fd_1d","tags":"","loc":"sourcefile/opendiff_mesh_fd_1d.f90.html","title":"opendiff_mesh_fd_1d.f90 – openpde"},{"text":"Abstract class of spatial operator for 1D derivative. Source Code !< Abstract class of spatial operator for 1D derivative. module opendiff_adt_spatial_operator_der1 !< Abstract class of spatial operator for 1D derivative. use opendiff_adt_spatial_operator implicit none private public :: spatial_operator_der1 type , abstract , extends ( spatial_operator ) :: spatial_operator_der1 !< Abstract class for first derivative for *spatial operator* handling. endtype spatial_operator_der1 end module opendiff_adt_spatial_operator_der1","tags":"","loc":"sourcefile/opendiff_adt_spatial_operator_der1.f90.html","title":"opendiff_adt_spatial_operator_der1.f90 – openpde"},{"text":"Abstract class of integrator. Source Code !< Abstract class of integrator. module opendiff_adt_integrator !< Abstract class of integrator. use opendiff_adt_field use opendiff_adt_equation use opendiff_kinds implicit none private public :: integrator type , abstract :: integrator !< Abstract class for *integrator* handling. character ( len = :), allocatable :: description !< Mesh description. real ( R_P ) :: dt = 0._R_P !< Time step. contains procedure :: free !< Free dynamic memory. procedure ( abstract_integrate ), deferred :: integrate !< Integrate the field accordingly the equation. endtype integrator abstract interface !< Integrate the field accordingly the equation. function abstract_integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the equation. import :: equation , field , integrator , I_P , R_P class ( integrator ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. end function abstract_integrate endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module opendiff_adt_integrator","tags":"","loc":"sourcefile/opendiff_adt_integrator.f90.html","title":"opendiff_adt_integrator.f90 – openpde"},{"text":"Abstract class of mesh. Source Code !< Abstract class of mesh. module opendiff_adt_mesh !< Abstract class of mesh. use opendiff_kinds implicit none private public :: mesh type , abstract :: mesh !< Abstract class for *mesh* handling. character ( len = :), allocatable :: description !< Mesh description. contains procedure :: free !< Free dynamic memory. procedure ( abstract_meshinit ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , deferred :: output !< Output mesh. endtype mesh abstract interface !< Initialize mesh. subroutine abstract_meshinit ( this , description , error ) !< Initialize mesh. import :: I_P , mesh class ( mesh ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshinit endinterface abstract interface !< Output mesh. subroutine abstract_meshoutput ( this , error ) !< Output mesh. import :: I_P , mesh class ( mesh ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshoutput endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module opendiff_adt_mesh","tags":"","loc":"sourcefile/opendiff_adt_mesh.f90.html","title":"opendiff_adt_mesh.f90 – openpde"},{"text":"Source Code module myequations !< Fake Burgers equation. use opendiff implicit none private public :: burgers_equation type , extends ( equation ) :: burgers_equation !< Fake Burgers equations. !< !< @note The reason the next is a pointer is just to make it a pointee !< when pointed inside forcing_burgers function. class ( spatial_operator_der1 ), pointer :: der1 !< First derivative. contains procedure :: bc => bc_burgers !< Equation boundary conditions imposition. procedure :: forcing => forcing_burgers !< Forcing equation. procedure :: init => init_burgers !< Initialize equation. endtype burgers_equation contains subroutine bc_burgers ( this , inp , t ) !< Equation boundary conditions imposition. class ( burgers_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Field. real ( R_P ), intent ( in ) :: t !< Time. class ( field_fd_1d ), pointer :: inp_cur !< Pointer to input field. class ( mesh_fd_1d ), pointer :: mesh_cur !< Pointer to input mehs. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: i !< Counter. select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to bc' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng do i = 1 - ng , 0 inp_cur % val ( i ) = inp_cur % val ( i + n ) enddo do i = n + 1 , n + ng inp_cur % val ( i ) = inp_cur % val ( i - n ) enddo end subroutine bc_burgers function init_burgers ( this ) result ( error ) !< Initialize equation. class ( burgers_equation ), intent ( inout ) :: this !< The equation. integer ( I_P ) :: error !< Error status. ! The next is to be read by JSON allocate ( spatial_operator_der1_fd_1d :: this % der1 ) error = 0 end function init_burgers function forcing_burgers ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. class ( burgers_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed. class ( spatial_operator_der1 ), pointer :: der1_cur !< Dummy pointer for spatial operator. allocate ( opr , source = inp ) der1_cur => this % der1 opr = der1_cur % operate ( inp ) !OK TOO        opr = this%der1%operate(inp) end function forcing_burgers end module myequations program burgers !< Testing program of fake Burgers equation. use opendiff use myequations class ( mesh ), allocatable :: m1 !< Mesh. class ( field ), allocatable :: u1 !< Field 1. !TEST class(field), allocatable      :: u2       !< Field 2. !TEST class(field), allocatable      :: u3       !< Field 3. class ( integrator ), allocatable :: integ !< Integrator. type ( burgers_equation ) :: burg_equ !< Burgers equation. integer ( I_P ) :: itmin = 0 !< Fist time step. integer ( I_P ) :: itmax = 1000 !< Last time step. integer ( I_P ) :: it !< Time step counter. integer ( I_P ) :: er !< Error status. !TEST class(spatialop), allocatable :: der1d character ( 16 ) :: output_name !< Output file name. ! These should be done reading from JSON input files and returning right ! pointers following factory pattern or similar allocate ( mesh_fd_1d :: m1 ) allocate ( field_fd_1d :: u1 ) !TEST allocate(field_fd_1d :: u2) !TEST allocate(spatialop_fd_1d_der1_c :: der1d) allocate ( integrator_euler :: integ ) !TEST allocate(u3, source=u1) integ % dt = 0.001_R_P call m1 % init ( error = er ) call u1 % init ( m1 , error = er ) er = burg_equ % init () !TEST call u2%init(m1, error=er) !TEST u3 = u1 + u1 * u2 !TEST u3 = der1d%operate(u1) output_name = \"out_XXXXXXXX.dat\" write ( output_name ( 5 : 12 ), \"(I8.8)\" ) itmin call u1 % output ( output_name , error = er ) do it = itmin , itmax er = integ % integrate ( inp = u1 , equ = burg_equ , t = it * integ % dt ) if ( mod ( it , 10 ) == 0 ) then print * , 'it: ' , it write ( output_name ( 5 : 12 ), \"(I8.8)\" ) it call u1 % output ( output_name , error = er ) endif enddo call m1 % output ( error = er ) end program burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – openpde"},{"text":"type, public, extends( field ) :: field_fd_1d type~~field_fd_1d~~InheritsGraph type~field_fd_1d field_fd_1d type~field field type~field->type~field_fd_1d type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Finite difference 1D class for field handling. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, private :: add Add fields. private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. procedure, private :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. procedure, private :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. procedure, public :: init Initilize field. private subroutine init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. procedure, public :: output Output field data. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. procedure, private :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. procedure, private :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. procedure, private :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. procedure, public :: set Set field. private subroutine set (this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code type , extends ( field ) :: field_fd_1d !< Finite difference 1D class for *field* handling. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred methods procedure , private :: add !< Add fields. procedure , private :: assign_field !< Assign fields. procedure , private :: associate_mesh !< Associate field to a mesh. procedure :: init !< Initilize field. procedure :: output !< Output field data. procedure , private :: sub !< Subtract fields. procedure , private :: mul !< Multiply fields. procedure , private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. ! public methods procedure :: set !< Set field. ! operators endtype field_fd_1d","tags":"","loc":"type/field_fd_1d.html","title":"field_fd_1d – openpde "},{"text":"type, public, abstract :: field type~~field~~InheritsGraph type~field field type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class for field handling. Inherited By type~~field~~InheritedByGraph type~field field type~field_fd_1d field_fd_1d type~field->type~field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure( abstract_simmetric_operator ), private, deferred :: add Add fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. procedure( abstract_assign ), private, deferred :: assign_field Assign fields. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. procedure( abstract_associate_mesh ), private, deferred :: associate_mesh Associate field to a mesh. subroutine abstract_associate_mesh (this, fieldmesh, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field. procedure( abstract_init ), public, deferred :: init Initilize field. subroutine abstract_init (this, fieldmesh, description, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field. procedure( abstract_simmetric_operator ), private, deferred :: mul Multiply fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. procedure( abstract_field_op_real ), private, deferred :: mulreal Multiply field for real. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. procedure( abstract_output ), public, deferred :: output Output field data. subroutine abstract_output (this, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field. procedure( abstract_simmetric_operator ), private, deferred :: sub Subtract fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. procedure( abstract_real_op_field ), private, deferred, pass(rhs) :: realmul Multiply real for field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory. generic, public :: operator(+) => add Operator + overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. generic, public :: operator(-) => sub Operator - overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. generic, public :: assignment(=) => assign_field Assignment overloading. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. Source Code type , abstract :: field !< Abstract class for *field* handling. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred methods procedure ( abstract_simmetric_operator ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_associate_mesh ), private , deferred :: associate_mesh !< Associate field to a mesh. procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_simmetric_operator ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_output ), deferred :: output !< Output field data. procedure ( abstract_simmetric_operator ), private , deferred :: sub !< Subtract fields. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. !RIMETTERE !procedure :: assigreal   => assigreal_mesh_fd_1d_scal ! public methods procedure :: free !< Free dynamic memory. ! operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. endtype field","tags":"","loc":"type/field.html","title":"field – openpde "},{"text":"type, public, abstract :: equation Abstract class for equation handling. The concrete types are implemented at application level (by the user)\n predefined examples might be provided as well. Inherited By type~~equation~~InheritedByGraph type~equation equation type~burgers_equation burgers_equation type~equation->type~burgers_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure( abstract_bc ), public, deferred :: bc Equation boundary condition. subroutine abstract_bc (this, inp, t) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition. procedure( abstract_forcing ), public, deferred :: forcing Forcing equation. function abstract_forcing (this, inp, t) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. procedure( abstract_init ), public, deferred :: init Initialize the equation. function abstract_init (this) result(error) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation. procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. generic, public :: load => load_from_json Load equation definition from file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load equation definition from JSON file. procedure, public :: load_from_json Load equation definition from jSON file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load equation definition from JSON file. Source Code type , abstract :: equation !< Abstract class for *equation* handling. !< !< The concrete types are implemented at application level (by the user) !< predefined examples might be provided as well. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred methods procedure ( abstract_bc ), deferred :: bc !< Equation boundary condition. procedure ( abstract_forcing ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), deferred :: init !< Initialize the equation. ! public methods procedure :: free !< Free dynamic memory. generic :: load => load_from_json !< Load equation definition from file. ! private methods procedure :: load_from_json !< Load equation definition from jSON file. endtype equation","tags":"","loc":"type/equation.html","title":"equation – openpde "},{"text":"type, public, abstract :: spatial_operator Abstract class for spatial operator handling. Inherited By type~~spatial_operator~~InheritedByGraph type~spatial_operator spatial_operator type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator->type~spatial_operator_der1 type~burgers_equation burgers_equation type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1->type~spatial_operator_der1_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred :: operate Operator operation. function abstract_operate (this, inp) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , abstract :: spatial_operator !< Abstract class for *spatial operator* handling. character ( len = :), allocatable :: description !< Operator description. contains procedure ( abstract_operate ), deferred :: operate !< Operator operation. endtype spatial_operator","tags":"","loc":"type/spatial_operator.html","title":"spatial_operator – openpde "},{"text":"type, public, extends( integrator ) :: integrator_euler type~~integrator_euler~~InheritsGraph type~integrator_euler integrator_euler type~integrator integrator type~integrator->type~integrator_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler integrator. Type-Bound Procedures procedure, public :: integrate Integrate the field accordingly the equation. private function integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation by means of the Euler scheme. Source Code type , extends ( integrator ) :: integrator_euler !< Euler integrator. contains procedure :: integrate !< Integrate the field accordingly the equation. endtype integrator_euler","tags":"","loc":"type/integrator_euler.html","title":"integrator_euler – openpde "},{"text":"type, public, extends( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d type~~spatial_operator_der1_fd_1d~~InheritsGraph type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator_der1->type~spatial_operator_der1_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator for first derivative for Finite Difference 1D. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , extends ( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d !< Concrete class of spatial operator for first derivative for Finite Difference 1D. contains procedure :: operate !< Operator operation. endtype spatial_operator_der1_fd_1d","tags":"","loc":"type/spatial_operator_der1_fd_1d.html","title":"spatial_operator_der1_fd_1d – openpde "},{"text":"type, public, extends( mesh ) :: mesh_fd_1d type~~mesh_fd_1d~~InheritsGraph type~mesh_fd_1d mesh_fd_1d type~mesh mesh type~mesh->type~mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Finite difference 1D class for mesh handling. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n Number of points. integer(kind=I_P), public :: ng Number of ghost points. integer(kind=I_P), public :: s Number of replicas for steps/stages. real(kind=R_P), public :: h Cell size. Type-Bound Procedures procedure, public :: init Initilize mesh. private pure subroutine init (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. procedure, public :: output Output data. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. procedure, public :: set Set mesh. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code type , extends ( mesh ) :: mesh_fd_1d !< Finite difference 1D class for *mesh* handling. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: ng !< Number of ghost points. integer ( I_P ) :: s !< Number of replicas for steps/stages. real ( R_P ) :: h !< Cell size. contains procedure :: init !< Initilize mesh. procedure :: output !< Output data. procedure :: set !< Set mesh. endtype mesh_fd_1d","tags":"","loc":"type/mesh_fd_1d.html","title":"mesh_fd_1d – openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_der1 type~~spatial_operator_der1~~InheritsGraph type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class for first derivative for spatial operator handling. Inherited By type~~spatial_operator_der1~~InheritedByGraph type~spatial_operator_der1 spatial_operator_der1 type~burgers_equation burgers_equation type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1->type~spatial_operator_der1_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_der1 !< Abstract class for first derivative for *spatial operator* handling. endtype spatial_operator_der1","tags":"","loc":"type/spatial_operator_der1.html","title":"spatial_operator_der1 – openpde "},{"text":"type, public, abstract :: integrator Abstract class for integrator handling. Inherited By type~~integrator~~InheritedByGraph type~integrator integrator type~integrator_euler integrator_euler type~integrator->type~integrator_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. procedure( abstract_integrate ), public, deferred :: integrate Integrate the field accordingly the equation. function abstract_integrate (this, equ, t, inp) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation. Source Code type , abstract :: integrator !< Abstract class for *integrator* handling. character ( len = :), allocatable :: description !< Mesh description. real ( R_P ) :: dt = 0._R_P !< Time step. contains procedure :: free !< Free dynamic memory. procedure ( abstract_integrate ), deferred :: integrate !< Integrate the field accordingly the equation. endtype integrator","tags":"","loc":"type/integrator.html","title":"integrator – openpde "},{"text":"type, public, abstract :: mesh Abstract class for mesh handling. Inherited By type~~mesh~~InheritedByGraph type~mesh mesh type~field field type~mesh->type~field m type~mesh_fd_1d mesh_fd_1d type~mesh->type~mesh_fd_1d type~field_fd_1d field_fd_1d type~field->type~field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. procedure( abstract_meshinit ), public, deferred :: init Initilize mesh. subroutine abstract_meshinit (this, description, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. procedure( abstract_meshoutput ), public, deferred :: output Output mesh. subroutine abstract_meshoutput (this, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Source Code type , abstract :: mesh !< Abstract class for *mesh* handling. character ( len = :), allocatable :: description !< Mesh description. contains procedure :: free !< Free dynamic memory. procedure ( abstract_meshinit ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , deferred :: output !< Output mesh. endtype mesh","tags":"","loc":"type/mesh.html","title":"mesh – openpde "},{"text":"type, public, extends( equation ) :: burgers_equation type~~burgers_equation~~InheritsGraph type~burgers_equation burgers_equation type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 type~equation equation type~equation->type~burgers_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Fake Burgers equations. Note The reason the next is a pointer is just to make it a pointee\n when pointed inside forcing_burgers function. Components Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1 First derivative. Type-Bound Procedures procedure, public :: bc => bc_burgers Equation boundary conditions imposition. private subroutine bc_burgers (this, inp, t) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition. procedure, public :: forcing => forcing_burgers Forcing equation. private function forcing_burgers (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. procedure, public :: init => init_burgers Initialize equation. private function init_burgers (this) result(error) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation. Source Code type , extends ( equation ) :: burgers_equation !< Fake Burgers equations. !< !< @note The reason the next is a pointer is just to make it a pointee !< when pointed inside forcing_burgers function. class ( spatial_operator_der1 ), pointer :: der1 !< First derivative. contains procedure :: bc => bc_burgers !< Equation boundary conditions imposition. procedure :: forcing => forcing_burgers !< Forcing equation. procedure :: init => init_burgers !< Initialize equation. endtype burgers_equation","tags":"","loc":"type/burgers_equation.html","title":"burgers_equation – openpde "},{"text":"abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field.","tags":"","loc":"interface/abstract_simmetric_operator.html","title":"abstract_simmetric_operator – openpde"},{"text":"abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real.","tags":"","loc":"interface/abstract_field_op_real.html","title":"abstract_field_op_real – openpde"},{"text":"abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field.","tags":"","loc":"interface/abstract_real_op_field.html","title":"abstract_real_op_field – openpde"},{"text":"abstract interface Assignment overloading. private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading.","tags":"","loc":"interface/abstract_assign.html","title":"abstract_assign – openpde"},{"text":"abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh(this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field.","tags":"","loc":"interface/abstract_associate_mesh.html","title":"abstract_associate_mesh – openpde"},{"text":"abstract interface Initialize the field. private subroutine abstract_init(this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field.","tags":"","loc":"interface/abstract_init.html","title":"abstract_init – openpde"},{"text":"abstract interface Output the field. private subroutine abstract_output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field.","tags":"","loc":"interface/abstract_output.html","title":"abstract_output – openpde"},{"text":"abstract interface Equation boundary condition. private subroutine abstract_bc(this, inp, t) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition.","tags":"","loc":"interface/abstract_bc.html","title":"abstract_bc – openpde"},{"text":"abstract interface Initialize equation. private function abstract_init(this) result(error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation.","tags":"","loc":"interface/abstract_init~2.html","title":"abstract_init – openpde"},{"text":"abstract interface Return the field after forcing the equation. private function abstract_forcing(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation.","tags":"","loc":"interface/abstract_forcing.html","title":"abstract_forcing – openpde"},{"text":"abstract interface Operator operation. private function abstract_operate(this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"interface/abstract_operate.html","title":"abstract_operate – openpde"},{"text":"abstract interface Integrate the field accordingly the equation. private function abstract_integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation.","tags":"","loc":"interface/abstract_integrate.html","title":"abstract_integrate – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_meshinit(this, description, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh.","tags":"","loc":"interface/abstract_meshinit.html","title":"abstract_meshinit – openpde"},{"text":"abstract interface Output mesh. private subroutine abstract_meshoutput(this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh.","tags":"","loc":"interface/abstract_meshoutput.html","title":"abstract_meshoutput – openpde"},{"text":"private function add(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_fd_1d ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => rhs % m opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => lhs % m opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub.html","title":"sub – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_fd_1d ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to assign' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate if ( allocated ( lhs % val )) deallocate ( lhs % val ) n = mesh_cur % n ng = mesh_cur % ng allocate ( lhs % val ( 1 - ng : n + ng )) lhs % m => rhs_cur % m lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field.html","title":"assign_field – openpde"},{"text":"private subroutine associate_mesh(this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. Variables Type Visibility Attributes Name Initial class( mesh_fd_1d ), public, pointer :: fieldmesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. Source Code subroutine associate_mesh ( this , fieldmesh , error ) !< Associate field to a mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_fd_1d ), pointer :: fieldmesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. select type ( fieldmesh ) type is ( mesh_fd_1d ) fieldmesh_cur => fieldmesh class default STOP 'Error passing mesh' end select this % m => fieldmesh_cur n = fieldmesh_cur % n ng = fieldmesh_cur % ng if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - ng : n + ng )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh.html","title":"associate_mesh – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_fd_1d ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % val )) deallocate ( this % val ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free","tags":"","loc":"proc/free.html","title":"free – openpde"},{"text":"private subroutine init(this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. Variables Type Visibility Attributes Name Initial class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. integer(kind=I4P), public :: i Counter. Source Code subroutine init ( this , fieldmesh , description , error ) !< Initialize finite difference 1D field. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. integer ( I4P ) :: i !< Counter. call this % free call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description !        call random_number(this%val) select type ( fieldmesh ) type is ( mesh_fd_1d ) mesh_cur => fieldmesh class default STOP 'Error setting mesh' end select n = mesh_cur % n ng = mesh_cur % ng print * , \"number of points of mesh in init n,ng: \" , n , ng do i = 1 - ng , n + ng this % val ( i ) = sin ( i * 2. * acos ( - 1. ) / n ) enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: imin Lower extent. integer(kind=I_P), public :: imax Upper extent. integer(kind=I_P), public :: i Counter. Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_fd_1d ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , 1 ) imax = ubound ( this % val , 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output.html","title":"output – openpde"},{"text":"private subroutine set(this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code subroutine set ( this , fieldmesh , description , val , error ) !< Set mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( fieldmesh )) call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free","tags":"","loc":"proc/free~2.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~3.html","title":"free – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load equation definition from JSON file. Variables Type Visibility Attributes Name Initial type(json_file), public :: json JSON file handler. Source Code subroutine load_from_json ( this , filename , error ) !< Load equation definition from JSON file. class ( equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. type ( json_file ) :: json !< JSON file handler. !logical                                :: found call json % initialize () call json % load_file ( filename = filename ) !call json%get('version.major', i, found) endsubroutine load_from_json","tags":"","loc":"proc/load_from_json.html","title":"load_from_json – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation by means of the Euler scheme. Variables Type Visibility Attributes Name Initial class( field ), public, allocatable :: for Temporary Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the equation by means of the Euler scheme. class ( integrator_euler ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary ! select type(inp) !     type is(field_fd_1d) !         print *,\"t, dt, inp: \",t, this%dt, inp%val ! end select allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? call equ % bc ( inp = inp , t = t ) for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate","tags":"","loc":"proc/integrate.html","title":"integrate – openpde"},{"text":"private function operate(this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: inp_cur Dummy pointer for input field. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. real(kind=R_P), public :: h Space step. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: n Counter. integer(kind=I_P), public :: ng Number of ghost cells. Source Code function operate ( this , inp ) result ( opr ) !< Operator operation. class ( spatial_operator_der1_fd_1d ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_fd_1d ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. real ( R_P ) :: h !< Space step. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: ng !< Number of ghost cells. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to spatial operate' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate h = mesh_cur % h n = mesh_cur % n ng = mesh_cur % ng allocate ( opr_cur % val ( 1 - ng : n + ng )) opr_cur % m => mesh_cur do i = 1 , n !opr_cur%val(i) = (inp_cur%val(i+1) - inp_cur%val(i-1))/(2.*h) opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( h ) enddo !opr_cur%val(1) = (inp_cur%val(2) - inp_cur%val(n))/(2.*h) !opr_cur%val(n) = (inp_cur%val(1) - inp_cur%val(n-1))/(2.*h) end function operate","tags":"","loc":"proc/operate.html","title":"operate – openpde"},{"text":"private pure subroutine init(this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. Source Code pure subroutine init ( this , description , error ) !< Initialize mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % n = 50 this % ng = 2 this % s = 1 this % h = 0.05_R8P if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~2.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_fd_1d ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~2.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~2.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~4.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~5.html","title":"free – openpde"},{"text":"private function init_burgers(this) result(error) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation. Source Code function init_burgers ( this ) result ( error ) !< Initialize equation. class ( burgers_equation ), intent ( inout ) :: this !< The equation. integer ( I_P ) :: error !< Error status. ! The next is to be read by JSON allocate ( spatial_operator_der1_fd_1d :: this % der1 ) error = 0 end function init_burgers","tags":"","loc":"proc/init_burgers.html","title":"init_burgers – openpde"},{"text":"private function forcing_burgers(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. Variables Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1_cur Dummy pointer for spatial operator. Source Code function forcing_burgers ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. class ( burgers_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed. class ( spatial_operator_der1 ), pointer :: der1_cur !< Dummy pointer for spatial operator. allocate ( opr , source = inp ) der1_cur => this % der1 opr = der1_cur % operate ( inp ) !OK TOO        opr = this%der1%operate(inp) end function forcing_burgers","tags":"","loc":"proc/forcing_burgers.html","title":"forcing_burgers – openpde"},{"text":"private subroutine bc_burgers(this, inp, t) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: inp_cur Pointer to input field. class( mesh_fd_1d ), public, pointer :: mesh_cur Pointer to input mehs. integer(kind=I_P), public :: ng Number of ghost cells. integer(kind=I_P), public :: n Counter. integer(kind=I_P), public :: i Counter. Source Code subroutine bc_burgers ( this , inp , t ) !< Equation boundary conditions imposition. class ( burgers_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Field. real ( R_P ), intent ( in ) :: t !< Time. class ( field_fd_1d ), pointer :: inp_cur !< Pointer to input field. class ( mesh_fd_1d ), pointer :: mesh_cur !< Pointer to input mehs. integer ( I_P ) :: ng !< Number of ghost cells. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: i !< Counter. select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to bc' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate n = mesh_cur % n ng = mesh_cur % ng do i = 1 - ng , 0 inp_cur % val ( i ) = inp_cur % val ( i + n ) enddo do i = n + 1 , n + ng inp_cur % val ( i ) = inp_cur % val ( i - n ) enddo end subroutine bc_burgers","tags":"","loc":"proc/bc_burgers.html","title":"bc_burgers – openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_mesh opendiff_kinds opendiff_mesh_fd_1d module~~opendiff_field_fd_1d~~UsesGraph module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_mesh vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 1D. Used By module~~opendiff_field_fd_1d~~UsedByGraph module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff opendiff module~opendiff_field_fd_1d->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_integrator_euler->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( field ) :: field_fd_1d Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, private :: add Add fields. procedure, private :: assign_field Assign fields. procedure, private :: associate_mesh Associate field to a mesh. procedure, public :: init Initilize field. procedure, public :: output Output field data. procedure, private :: sub Subtract fields. procedure, private :: mul Multiply fields. procedure, private :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, public :: set Set field. Description Finite difference 1D class for field handling. Functions private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Subroutines private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. private subroutine associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The mesh. Description Free dynamic memory. private subroutine init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. private subroutine set (this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh.","tags":"","loc":"module/opendiff_field_fd_1d.html","title":"opendiff_field_fd_1d – openpde"},{"text":"Uses: opendiff_adt_mesh opendiff_kinds module~~opendiff_adt_field~~UsesGraph module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of field. Used By module~~opendiff_adt_field~~UsedByGraph module~opendiff_adt_field opendiff_adt_field module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff opendiff module~opendiff_adt_field->module~opendiff module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_integrator_euler->module~opendiff module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~myequations->program~burgers module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff var panmoduleopendiff_adt_fieldUsedByGraph = svgPanZoom('#moduleopendiff_adt_fieldUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. abstract interface Assignment overloading. private subroutine abstract_assign (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field. abstract interface Initialize the field. private subroutine abstract_init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field. abstract interface Output the field. private subroutine abstract_output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field. Derived Types type, public, abstract :: field Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure(abstract_simmetric_operator), private :: add Add fields. procedure(abstract_assign), private :: assign_field Assign fields. procedure(abstract_associate_mesh), private :: associate_mesh Associate field to a mesh. procedure(abstract_init), public :: init Initilize field. procedure(abstract_simmetric_operator), private :: mul Multiply fields. procedure(abstract_field_op_real), private :: mulreal Multiply field for real. procedure(abstract_output), public :: output Output field data. procedure(abstract_simmetric_operator), private :: sub Subtract fields. procedure(abstract_real_op_field), private, pass(rhs) :: realmul Multiply real for field. procedure, public :: free Free dynamic memory. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. Description Abstract class for field handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_field.html","title":"opendiff_adt_field – openpde"},{"text":"Uses: json_module opendiff_adt_field opendiff_kinds module~~opendiff_adt_equation~~UsesGraph module~opendiff_adt_equation opendiff_adt_equation json_module json_module json_module->module~opendiff_adt_equation module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_mesh->module~opendiff_adt_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of equation. Used By module~~opendiff_adt_equation~~UsedByGraph module~opendiff_adt_equation opendiff_adt_equation module~opendiff opendiff module~opendiff_adt_equation->module~opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_adt_integrator module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~myequations->program~burgers var panmoduleopendiff_adt_equationUsedByGraph = svgPanZoom('#moduleopendiff_adt_equationUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Equation boundary condition. private subroutine abstract_bc (this, inp, t) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition. abstract interface Initialize equation. private function abstract_init (this) result(error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation. abstract interface Return the field after forcing the equation. private function abstract_forcing (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. Derived Types type, public, abstract :: equation Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure(abstract_bc), public :: bc Equation boundary condition. procedure(abstract_forcing), public :: forcing Forcing equation. procedure(abstract_init), public :: init Initialize the equation. procedure, public :: free Free dynamic memory. generic, public :: load => load_from_json Load equation definition from file. procedure, public :: load_from_json Load equation definition from jSON file. Description Abstract class for equation handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load equation definition from JSON file.","tags":"","loc":"module/opendiff_adt_equation.html","title":"opendiff_adt_equation – openpde"},{"text":"Uses: opendiff_adt_field module~~opendiff_adt_spatial_operator~~UsesGraph module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator. Used By module~~opendiff_adt_spatial_operator~~UsedByGraph module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff opendiff module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~myequations->program~burgers module~opendiff_spatial_operator_der1_fd_1d->module~opendiff var panmoduleopendiff_adt_spatial_operatorUsedByGraph = svgPanZoom('#moduleopendiff_adt_spatial_operatorUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Operator operation. private function abstract_operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Derived Types type, public, abstract :: spatial_operator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public :: operate Operator operation. Description Abstract class for spatial operator handling.","tags":"","loc":"module/opendiff_adt_spatial_operator.html","title":"opendiff_adt_spatial_operator – openpde"},{"text":"opendiff kinds: definition of reals and integer kind parameters of opendiff library. Used By module~~opendiff_kinds~~UsedByGraph module~opendiff_kinds opendiff_kinds module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff opendiff module~opendiff_kinds->module~opendiff module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~myequations->program~burgers module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff var panmoduleopendiff_kindsUsedByGraph = svgPanZoom('#moduleopendiff_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/opendiff_kinds.html","title":"opendiff_kinds – openpde"},{"text":"Uses: opendiff_adt_equation opendiff_adt_field opendiff_adt_integrator opendiff_field_fd_1d opendiff_kinds module~~opendiff_integrator_euler~~UsesGraph module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d json_module json_module json_module->module~opendiff_adt_equation var panmoduleopendiff_integrator_eulerUsesGraph = svgPanZoom('#moduleopendiff_integrator_eulerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of Euler integrator. Used By module~~opendiff_integrator_euler~~UsedByGraph module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff opendiff module~opendiff_integrator_euler->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( integrator ) :: integrator_euler Type-Bound Procedures procedure, public :: integrate Integrate the field accordingly the equation. Description Euler integrator. Functions private function integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation by means of the Euler scheme.","tags":"","loc":"module/opendiff_integrator_euler.html","title":"opendiff_integrator_euler – openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_spatial_operator_der1 opendiff_field_fd_1d opendiff_kinds opendiff_mesh_fd_1d module~~opendiff_spatial_operator_der1_fd_1d~~UsesGraph module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_field_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 var panmoduleopendiff_spatial_operator_der1_fd_1dUsesGraph = svgPanZoom('#moduleopendiff_spatial_operator_der1_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Used By module~~opendiff_spatial_operator_der1_fd_1d~~UsedByGraph module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator for first derivative for Finite Difference 1D. Functions private function operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"module/opendiff_spatial_operator_der1_fd_1d.html","title":"opendiff_spatial_operator_der1_fd_1d – openpde"},{"text":"Uses: opendiff_adt_equation opendiff_adt_field opendiff_adt_integrator opendiff_adt_mesh opendiff_adt_spatial_operator opendiff_adt_spatial_operator_der1 opendiff_field_fd_1d opendiff_integrator_euler opendiff_kinds opendiff_mesh_fd_1d opendiff_spatial_operator_der1_fd_1d module~~opendiff~~UsesGraph module~opendiff opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d json_module json_module json_module->module~opendiff_adt_equation vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d var panmoduleopendiffUsesGraph = svgPanZoom('#moduleopendiffUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. opendiff: Open Fortran Library for PDE solving. Used By module~~opendiff~~UsedByGraph module~opendiff opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/opendiff.html","title":"opendiff – openpde"},{"text":"Uses: opendiff_adt_mesh opendiff_kinds vtk_fortran module~~opendiff_mesh_fd_1d~~UsesGraph module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 1D. Used By module~~opendiff_mesh_fd_1d~~UsedByGraph module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff opendiff module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_integrator_euler->module~opendiff module~myequations->program~burgers var panmoduleopendiff_mesh_fd_1dUsedByGraph = svgPanZoom('#moduleopendiff_mesh_fd_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( mesh ) :: mesh_fd_1d Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n Number of points. integer(kind=I_P), public :: ng Number of ghost points. integer(kind=I_P), public :: s Number of replicas for steps/stages. real(kind=R_P), public :: h Cell size. Type-Bound Procedures procedure, public :: init Initilize mesh. procedure, public :: output Output data. procedure, public :: set Set mesh. Description Finite difference 1D class for mesh handling. Subroutines private pure subroutine init (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh.","tags":"","loc":"module/opendiff_mesh_fd_1d.html","title":"opendiff_mesh_fd_1d – openpde"},{"text":"Uses: opendiff_adt_spatial_operator module~~opendiff_adt_spatial_operator_der1~~UsesGraph module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field var panmoduleopendiff_adt_spatial_operator_der1UsesGraph = svgPanZoom('#moduleopendiff_adt_spatial_operator_der1UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator for 1D derivative. Used By module~~opendiff_adt_spatial_operator_der1~~UsedByGraph module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers var panmoduleopendiff_adt_spatial_operator_der1UsedByGraph = svgPanZoom('#moduleopendiff_adt_spatial_operator_der1UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_der1 Description Abstract class for first derivative for spatial operator handling.","tags":"","loc":"module/opendiff_adt_spatial_operator_der1.html","title":"opendiff_adt_spatial_operator_der1 – openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_equation opendiff_kinds module~~opendiff_adt_integrator~~UsesGraph module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field json_module json_module json_module->module~opendiff_adt_equation var panmoduleopendiff_adt_integratorUsesGraph = svgPanZoom('#moduleopendiff_adt_integratorUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of integrator. Used By module~~opendiff_adt_integrator~~UsedByGraph module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_integrator->module~opendiff_integrator_euler module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_integrator_euler->module~opendiff module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Integrate the field accordingly the equation. private function abstract_integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the equation. Derived Types type, public, abstract :: integrator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public :: free Free dynamic memory. procedure(abstract_integrate), public :: integrate Integrate the field accordingly the equation. Description Abstract class for integrator handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_integrator.html","title":"opendiff_adt_integrator – openpde"},{"text":"Uses: opendiff_kinds module~~opendiff_adt_mesh~~UsesGraph module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_mesh Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of mesh. Used By module~~opendiff_adt_mesh~~UsedByGraph module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_integrator_euler module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~myequations->program~burgers var panmoduleopendiff_adt_meshUsedByGraph = svgPanZoom('#moduleopendiff_adt_meshUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Initialize mesh. private subroutine abstract_meshinit (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. abstract interface Output mesh. private subroutine abstract_meshoutput (this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Derived Types type, public, abstract :: mesh Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure, public :: free Free dynamic memory. procedure(abstract_meshinit), public :: init Initilize mesh. procedure(abstract_meshoutput), public :: output Output mesh. Description Abstract class for mesh handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_mesh.html","title":"opendiff_adt_mesh – openpde"},{"text":"Uses: opendiff module~~myequations~~UsesGraph module~myequations myequations module~opendiff opendiff module~opendiff->module~myequations module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d json_module json_module json_module->module~opendiff_adt_equation vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d var panmodulemyequationsUsesGraph = svgPanZoom('#modulemyequationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Fake Burgers equation. Used By module~~myequations~~UsedByGraph module~myequations myequations program~burgers burgers module~myequations->program~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( equation ) :: burgers_equation Components Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1 First derivative. Type-Bound Procedures procedure, public :: bc => bc_burgers Equation boundary conditions imposition. procedure, public :: forcing => forcing_burgers Forcing equation. procedure, public :: init => init_burgers Initialize equation. Description Fake Burgers equations. Functions private function init_burgers (this) result(error) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(inout) :: this The equation. Return Value integer(kind=I_P) Error status. Description Initialize equation. private function forcing_burgers (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. Subroutines private subroutine bc_burgers (this, inp, t) Arguments Type Intent Optional Attributes Name class( burgers_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition.","tags":"","loc":"module/myequations.html","title":"myequations – openpde"},{"text":"Uses: opendiff myequations program~~burgers~~UsesGraph program~burgers burgers module~opendiff opendiff module~opendiff->program~burgers module~myequations myequations module~opendiff->module~myequations module~myequations->program~burgers module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d json_module json_module json_module->module~opendiff_adt_equation vtk_fortran vtk_fortran vtk_fortran->module~opendiff_mesh_fd_1d var panprogramburgersUsesGraph = svgPanZoom('#programburgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Testing program of fake Burgers equation. Variables Type Attributes Name Initial class( mesh ), allocatable :: m1 Mesh. class( field ), allocatable :: u1 Field 1. class( integrator ), allocatable :: integ Integrator. type( burgers_equation ) :: burg_equ Burgers equation. integer(kind=I_P) :: itmin = 0 Fist time step. integer(kind=I_P) :: itmax = 1000 Last time step. integer(kind=I_P) :: it Time step counter. integer(kind=I_P) :: er Error status. character(len=16) :: output_name Output file name. Source Code program burgers !< Testing program of fake Burgers equation. use opendiff use myequations class ( mesh ), allocatable :: m1 !< Mesh. class ( field ), allocatable :: u1 !< Field 1. !TEST class(field), allocatable      :: u2       !< Field 2. !TEST class(field), allocatable      :: u3       !< Field 3. class ( integrator ), allocatable :: integ !< Integrator. type ( burgers_equation ) :: burg_equ !< Burgers equation. integer ( I_P ) :: itmin = 0 !< Fist time step. integer ( I_P ) :: itmax = 1000 !< Last time step. integer ( I_P ) :: it !< Time step counter. integer ( I_P ) :: er !< Error status. !TEST class(spatialop), allocatable :: der1d character ( 16 ) :: output_name !< Output file name. ! These should be done reading from JSON input files and returning right ! pointers following factory pattern or similar allocate ( mesh_fd_1d :: m1 ) allocate ( field_fd_1d :: u1 ) !TEST allocate(field_fd_1d :: u2) !TEST allocate(spatialop_fd_1d_der1_c :: der1d) allocate ( integrator_euler :: integ ) !TEST allocate(u3, source=u1) integ % dt = 0.001_R_P call m1 % init ( error = er ) call u1 % init ( m1 , error = er ) er = burg_equ % init () !TEST call u2%init(m1, error=er) !TEST u3 = u1 + u1 * u2 !TEST u3 = der1d%operate(u1) output_name = \"out_XXXXXXXX.dat\" write ( output_name ( 5 : 12 ), \"(I8.8)\" ) itmin call u1 % output ( output_name , error = er ) do it = itmin , itmax er = integ % integrate ( inp = u1 , equ = burg_equ , t = it * integ % dt ) if ( mod ( it , 10 ) == 0 ) then print * , 'it: ' , it write ( output_name ( 5 : 12 ), \"(I8.8)\" ) it call u1 % output ( output_name , error = er ) endif enddo call m1 % output ( error = er ) end program burgers","tags":"","loc":"program/burgers.html","title":"burgers – openpde"}]}