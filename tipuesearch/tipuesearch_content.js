var tipuesearch = {"pages":[{"text":"openpde Developer Info Francesco Salvadore","tags":"","loc":"index.html","title":" openpde "},{"text":"Concrete class of field for Finite Difference 1D. Source Code !< Concrete class of field for Finite Difference 1D. module opendiff_field_fd_1d !< Concrete class of field for Finite Difference 1D. use opendiff_adt_field use opendiff_adt_mesh use opendiff_kinds use opendiff_mesh_fd_1d implicit none private public :: field_fd_1d type , extends ( field ) :: field_fd_1d !< Finite difference 1D class for *field* handling. real ( R8P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred methods procedure , private :: add !< Add fields. procedure , private :: assign_field !< Assign fields. procedure , private :: associate_mesh !< Associate field to a mesh. procedure :: init !< Initilize field. procedure :: output !< Output field data. procedure , private :: sub !< Subtract fields. procedure , private :: mul !< Multiply fields. procedure , private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. ! public methods procedure :: set !< Set field. ! operators endtype field_fd_1d contains function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_fd_1d ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to assign' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate if ( allocated ( lhs % val )) deallocate ( lhs % val ) allocate ( lhs % val ( 1 : mesh_cur % n )) lhs % m => rhs_cur % m lhs % val = rhs_cur % val end subroutine assign_field subroutine associate_mesh ( this , fieldmesh , error ) !< Associate field to a mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. integer ( I4P ), intent ( out ), optional :: error !< Error status. class ( mesh_fd_1d ), pointer :: fieldmesh_cur !< Dummy pointer for mesh. select type ( fieldmesh ) type is ( mesh_fd_1d ) fieldmesh_cur => fieldmesh class default STOP 'Error passing mesh' end select this % m => fieldmesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 : fieldmesh_cur % n )) if ( present ( error )) error = 0 end subroutine associate_mesh elemental subroutine free ( this ) !< Free dynamic memory. class ( field_fd_1d ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % val )) deallocate ( this % val ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free subroutine init ( this , fieldmesh , description , error ) !< Initialize finite difference 1D field. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( out ), optional :: error !< Error status. call this % free call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description call random_number ( this % val ) if ( present ( error )) error = 0 end subroutine init function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs end function mulreal subroutine output ( this , filename , error ) !< Output field data. class ( field_fd_1d ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I4P ), intent ( out ), optional :: error !< Error status. open ( unit = 11 , file = filename ) write ( 11 , * ) this % val (:) close ( 11 ) if ( present ( error )) error = 0 end subroutine output function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_fd_1d ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => rhs % m opr_cur % val = lhs * rhs % val end function realmul subroutine set ( this , fieldmesh , description , val , error ) !< Set mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R8P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( present ( fieldmesh )) call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val = val if ( present ( error )) error = 0 end subroutine set function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val - rhs_cur % val end function sub end module opendiff_field_fd_1d","tags":"","loc":"sourcefile/opendiff_field_fd_1d.f90.html","title":"opendiff_field_fd_1d.f90 â€“ openpde"},{"text":"Abstract class of field. Source Code !< Abstract class of field. module opendiff_adt_field !< Abstract class of field. use opendiff_adt_mesh use opendiff_kinds implicit none private public :: field type , abstract :: field !< Abstract class for *field* handling. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred methods procedure ( abstract_simmetric_operator ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_associate_mesh ), private , deferred :: associate_mesh !< Associate field to a mesh. procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_simmetric_operator ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_output ), deferred :: output !< Output field data. procedure ( abstract_simmetric_operator ), private , deferred :: sub !< Subtract fields. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. !RIMETTERE !procedure :: assigreal   => assigreal_mesh_fd_1d_scal ! public methods procedure :: free !< Free dynamic memory. ! operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. endtype field abstract interface function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) import :: field class ( field ), intent ( in ) :: lhs class ( field ), intent ( in ), target :: rhs class ( field ), allocatable :: opr end function abstract_simmetric_operator endinterface abstract interface function abstract_field_op_real ( lhs , rhs ) result ( opr ) import :: field , R8P class ( field ), intent ( in ) :: lhs real ( R8P ), intent ( in ) :: rhs class ( field ), allocatable :: opr end function abstract_field_op_real endinterface abstract interface function abstract_real_op_field ( lhs , rhs ) result ( opr ) import :: field , R8P real ( R8P ), intent ( in ) :: lhs class ( field ), intent ( in ) :: rhs class ( field ), allocatable :: opr end function abstract_real_op_field endinterface abstract interface subroutine abstract_assign ( lhs , rhs ) import :: field class ( field ), intent ( inout ) :: lhs class ( field ), intent ( in ), target :: rhs end subroutine abstract_assign endinterface abstract interface subroutine abstract_associate_mesh ( this , fieldmesh , error ) import :: field , I4P , mesh class ( field ), intent ( inout ) :: this class ( mesh ), intent ( in ), target :: fieldmesh integer ( I4P ), intent ( out ), optional :: error end subroutine abstract_associate_mesh endinterface abstract interface subroutine abstract_init ( this , fieldmesh , description , error ) import :: field , I4P , mesh class ( field ), intent ( inout ) :: this class ( mesh ), intent ( in ), target :: fieldmesh character ( * ), intent ( in ), optional :: description integer ( I4P ), intent ( out ), optional :: error end subroutine abstract_init endinterface abstract interface subroutine abstract_output ( this , filename , error ) import :: field , I4P class ( field ), intent ( in ) :: this character ( len =* ), intent ( in ) :: filename integer ( I4P ), intent ( out ), optional :: error end subroutine abstract_output endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( field ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free end module opendiff_adt_field","tags":"","loc":"sourcefile/opendiff_adt_field.f90.html","title":"opendiff_adt_field.f90 â€“ openpde"},{"text":"Abstract class of equation. Source Code !< Abstract class of equation. module opendiff_adt_equation !< Abstract class of equation. use opendiff_adt_field use opendiff_kinds implicit none private public :: equation type , abstract :: equation !< Abstract class for *equation* handling. !< !< The concrete types are implemented at application level (by the user) !< predefined examples might be provided as well. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred methods procedure ( abstract_forcing ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), deferred :: init !< Initialize the equation. ! public methods procedure :: free !< Free dynamic memory. endtype equation abstract interface function abstract_forcing ( this , inp , t ) result ( opr ) import :: equation , field , R8P class ( equation ) :: this class ( field ), target :: inp class ( field ), allocatable :: opr real ( R8P ) :: t end function abstract_forcing endinterface abstract interface function abstract_init ( this ) result ( res ) import :: equation , field class ( equation ) :: this integer :: res end function abstract_init endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module opendiff_adt_equation","tags":"","loc":"sourcefile/opendiff_adt_equation.f90.html","title":"opendiff_adt_equation.f90 â€“ openpde"},{"text":"Abstract class of spatial operator. Source Code !< Abstract class of spatial operator. module opendiff_adt_spatial_operator !< Abstract class of spatial operator. use opendiff_adt_field implicit none private public :: spatial_operator type , abstract :: spatial_operator character ( len = :), allocatable :: description !< Operator description. contains procedure ( abstract_operate ), deferred :: operate !< Operator operation. endtype spatial_operator abstract interface function abstract_operate ( this , inp ) result ( opr ) import :: spatial_operator , field class ( spatial_operator ) :: this class ( field ), target :: inp class ( field ), allocatable :: opr end function abstract_operate endinterface end module opendiff_adt_spatial_operator","tags":"","loc":"sourcefile/opendiff_adt_spatial_operator.f90.html","title":"opendiff_adt_spatial_operator.f90 â€“ openpde"},{"text":"opendiff kinds: definition of reals and integer kind parameters of opendiff library. Source Code !< opendiff kinds: definition of reals and integer kind parameters of opendiff library. module opendiff_kinds !< opendiff kinds: definition of reals and integer kind parameters of opendiff library. implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. endmodule opendiff_kinds","tags":"","loc":"sourcefile/opendiff_kinds.f90.html","title":"opendiff_kinds.f90 â€“ openpde"},{"text":"Concrete class of Euler integrator. Source Code !< Concrete class of Euler integrator. module opendiff_integrator_euler !< Concrete class of Euler integrator. use opendiff_adt_equation use opendiff_adt_field use opendiff_adt_integrator use opendiff_field_fd_1d use opendiff_kinds implicit none private public :: integrator_euler type , extends ( integrator ) :: integrator_euler !< Euler integrator. contains procedure :: integrate !< Integrate the field accordingly the equation. endtype integrator_euler contains function integrate ( this , equ , t , inp ) result ( res ) class ( integrator_euler ), intent ( in ) :: this class ( equation ), intent ( in ), target :: equ real ( R8P ), intent ( in ) :: t class ( field ), intent ( inout ), target :: inp integer :: res class ( field ), allocatable :: for select type ( inp ) type is ( field_fd_1d ) print * , \"t, dt, inp: \" , t , this % dt , inp % val end select allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for res = 0 end function integrate end module opendiff_integrator_euler","tags":"","loc":"sourcefile/opendiff_integrator_euler.f90.html","title":"opendiff_integrator_euler.f90 â€“ openpde"},{"text":"Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Source Code !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. module opendiff_spatial_operator_der1_fd_1d !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. use opendiff_adt_field use opendiff_adt_spatial_operator_der1 use opendiff_field_fd_1d use opendiff_kinds use opendiff_mesh_fd_1d implicit none private public :: spatial_operator_der1_fd_1d type , extends ( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. contains procedure :: operate !< Operator operation. endtype spatial_operator_der1_fd_1d contains function operate ( this , inp ) result ( opr ) class ( spatial_operator_der1_fd_1d ) :: this class ( field ), target :: inp class ( field_fd_1d ), pointer :: inp_cur class ( field ), allocatable , target :: opr class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. real ( R8P ) :: h integer :: i , n allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to spatial operate' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate h = mesh_cur % h n = mesh_cur % n allocate ( opr_cur % val ( 1 : n )) opr_cur % m => mesh_cur do i = 2 , n - 1 opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i - 1 )) / ( 2. * h ) enddo opr_cur % val ( 1 ) = ( inp_cur % val ( 2 ) - inp_cur % val ( n )) / ( 2. * h ) opr_cur % val ( n ) = ( inp_cur % val ( 1 ) - inp_cur % val ( n - 1 )) / ( 2. * h ) end function operate end module opendiff_spatial_operator_der1_fd_1d","tags":"","loc":"sourcefile/opendiff_spatial_operator_der1_fd_1d.f90.html","title":"opendiff_spatial_operator_der1_fd_1d.f90 â€“ openpde"},{"text":"opendiff: Open Fortran Library for PDE solving. Source Code !< opendiff: Open Fortran Library for PDE solving. module opendiff !< opendiff: Open Fortran Library for PDE solving. use opendiff_adt_equation use opendiff_adt_field use opendiff_adt_integrator use opendiff_adt_mesh use opendiff_adt_spatial_operator use opendiff_adt_spatial_operator_der1 use opendiff_field_fd_1d use opendiff_integrator_euler use opendiff_mesh_fd_1d use opendiff_spatial_operator_der1_fd_1d implicit none private public :: equation public :: field public :: field_fd_1d public :: integrator public :: integrator_euler public :: mesh public :: mesh_fd_1d public :: spatial_operator public :: spatial_operator_der1 public :: spatial_operator_der1_fd_1d end module opendiff","tags":"","loc":"sourcefile/opendiff.f90.html","title":"opendiff.f90 â€“ openpde"},{"text":"Concrete class of mesh for Finite Difference 1D. Source Code !< Concrete class of mesh for Finite Difference 1D. module opendiff_mesh_fd_1d !< Concrete class of mesh for Finite Difference 1D. use opendiff_adt_mesh use opendiff_kinds implicit none private public :: mesh_fd_1d type , extends ( mesh ) :: mesh_fd_1d !< Finite difference 1D class for *mesh* handling. integer ( I4P ) :: n !< Number of points. integer ( I4P ) :: ng !< Number of ghost points. integer ( I4P ) :: s !< Number of replicas for steps/stages. real ( R8P ) :: h !< Cell size. contains procedure :: init !< Initilize mesh. procedure :: output !< Output mesh data. procedure :: set !< Set mesh. endtype mesh_fd_1d contains pure subroutine init ( this , description , error ) !< Initialize finite difference 1D mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % n = 50 this % ng = 2 this % s = 1 this % h = 0.1_R8P if ( present ( error )) error = 0 end subroutine init subroutine output ( this , error ) !< Output mesh data. class ( mesh_fd_1d ), intent ( in ) :: this !< The mesh. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( in ), optional :: n !< Number of points. integer ( I4P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I4P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R8P ), intent ( in ), optional :: h !< Cell size. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set end module opendiff_mesh_fd_1d","tags":"","loc":"sourcefile/opendiff_mesh_fd_1d.f90.html","title":"opendiff_mesh_fd_1d.f90 â€“ openpde"},{"text":"Abstract class of spatial operator for 1D derivative. Source Code !< Abstract class of spatial operator for 1D derivative. module opendiff_adt_spatial_operator_der1 !< Abstract class of spatial operator for 1D derivative. use opendiff_adt_spatial_operator implicit none private public :: spatial_operator_der1 type , abstract , extends ( spatial_operator ) :: spatial_operator_der1 endtype spatial_operator_der1 end module opendiff_adt_spatial_operator_der1","tags":"","loc":"sourcefile/opendiff_adt_spatial_operator_der1.f90.html","title":"opendiff_adt_spatial_operator_der1.f90 â€“ openpde"},{"text":"Abstract class of integrator. Source Code !< Abstract class of integrator. module opendiff_adt_integrator !< Abstract class of integrator. use opendiff_adt_field use opendiff_adt_equation use opendiff_kinds implicit none private public :: integrator type , abstract :: integrator !< Abstract class for *integrator* handling. character ( len = :), allocatable :: description !< Mesh description. real ( R8P ) :: dt = 0._R8P !< Time step. contains procedure :: free !< Free dynamic memory. procedure ( abstract_integrate ), deferred :: integrate !< Integrate the field accordingly the equation. endtype integrator abstract interface function abstract_integrate ( this , equ , t , inp ) result ( res ) import :: equation , field , integrator , R8P class ( integrator ), intent ( in ) :: this class ( equation ), intent ( in ), target :: equ real ( R8P ), intent ( in ) :: t class ( field ), intent ( inout ), target :: inp integer :: res end function abstract_integrate endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module opendiff_adt_integrator","tags":"","loc":"sourcefile/opendiff_adt_integrator.f90.html","title":"opendiff_adt_integrator.f90 â€“ openpde"},{"text":"Abstract class of mesh. Source Code !< Abstract class of mesh. module opendiff_adt_mesh !< Abstract class of mesh. use opendiff_kinds implicit none private public :: mesh type , abstract :: mesh !< Abstract class for *mesh* handling. character ( len = :), allocatable :: description !< Mesh description. contains procedure :: free !< Free dynamic memory. procedure ( abstract_meshinit ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , deferred :: output !< Output mesh data. endtype mesh abstract interface subroutine abstract_meshinit ( this , description , error ) import :: I4P , mesh class ( mesh ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: description integer ( I4P ), intent ( out ), optional :: error end subroutine abstract_meshinit endinterface abstract interface subroutine abstract_meshoutput ( this , error ) import :: I4P , mesh class ( mesh ), intent ( in ) :: this integer ( I4P ), intent ( out ), optional :: error end subroutine abstract_meshoutput endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module opendiff_adt_mesh","tags":"","loc":"sourcefile/opendiff_adt_mesh.f90.html","title":"opendiff_adt_mesh.f90 â€“ openpde"},{"text":"Source Code module myequations use opendiff use opendiff_kinds implicit none private public :: burgers_equation type , extends ( equation ) :: burgers_equation ! The reason the next is a pointer is just to make it a pointee ! when pointed inside forcing_burgers function class ( spatial_operator_der1 ), pointer :: der1 contains procedure :: init => init_burgers procedure :: forcing => forcing_burgers endtype burgers_equation contains function init_burgers ( this ) result ( res ) class ( burgers_equation ) :: this integer :: res ! The next is to be read by JSON allocate ( spatial_operator_der1_fd_1d :: this % der1 ) res = 0 end function init_burgers function forcing_burgers ( this , inp , t ) result ( opr ) class ( burgers_equation ) :: this class ( field ), target :: inp real ( R8P ) :: t class ( field ), allocatable :: opr class ( spatial_operator_der1 ), pointer :: der1_cur allocate ( opr , source = inp ) !USELESS        associate(d1 => this%der1) !USELESS            select type(d1) !USELESS                type is(spatialop_fd_1d_der1_c) !USELESS                    der1_cur => this%der1 !USELESS                class default !USELESS                   STOP 'Error passing field to add' !USELESS            endselect !USELESS        endassociate der1_cur => this % der1 opr = der1_cur % operate ( inp ) !OK TOO        opr = this%der1%operate(inp) end function forcing_burgers end module myequations program burgers use opendiff use myequations integer :: it integer :: er class ( mesh ), allocatable :: m1 class ( field ), allocatable :: u1 class ( field ), allocatable :: u2 class ( field ), allocatable :: u3 !DER IN MAIN class(spatialop), allocatable :: der1d class ( integrator ), allocatable :: integ integer :: itmin = 0 , itmax = 10 type ( burgers_equation ) :: burg_equ ! These should be done reading from JSON input files and returning right ! pointers following factory pattern or similar allocate ( mesh_fd_1d :: m1 ) allocate ( field_fd_1d :: u1 ) allocate ( field_fd_1d :: u2 ) !DER IN MAIN allocate(spatialop_fd_1d_der1_c :: der1d) allocate ( integrator_euler :: integ ) allocate ( u3 , source = u1 ) integ % dt = 0.1 call m1 % init ( error = er ) call u1 % init ( m1 , error = er ) call u2 % init ( m1 , error = er ) er = burg_equ % init () u3 = u1 + u1 * u2 !DER IN MAIN u3 = der1d%operate(u1) !RIMETTERE    er = u1%output(filename=\"inizio.dat\") !RIMETTERE do it = itmin , itmax print * , 'it: ' , it er = integ % integrate ( inp = u1 , equ = burg_equ , t = it * integ % dt ) enddo !RIMETTERE !RIMETTERE    er = u1%output(filename=\"fine.dat\") call m1 % output ( error = er ) call u1 % output ( \"1ciao.dat\" , error = er ) call u2 % output ( \"2ciao.dat\" , error = er ) call u3 % output ( \"3ciao.dat\" , error = er ) end program burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 â€“ openpde"},{"text":"type, public, extends( field ) :: field_fd_1d type~~field_fd_1d~~InheritsGraph type~field_fd_1d field_fd_1d type~field field type~field->type~field_fd_1d type~mesh mesh type~mesh->type~field m Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Finite difference 1D class for field handling. Components Type Visibility Attributes Name Initial real(kind=R8P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, private :: add Add fields. private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. procedure, private :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. procedure, private :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I4P), intent(out), optional :: error Error status. Description Associate field to a mesh. procedure, public :: init Initilize field. private subroutine init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. procedure, public :: output Output field data. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I4P), intent(out), optional :: error Error status. Description Output field data. procedure, private :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. procedure, private :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. procedure, private :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. procedure, public :: set Set field. private subroutine set (this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R8P), intent(in), optional :: val (1:) Field value. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh. Source Code type , extends ( field ) :: field_fd_1d !< Finite difference 1D class for *field* handling. real ( R8P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred methods procedure , private :: add !< Add fields. procedure , private :: assign_field !< Assign fields. procedure , private :: associate_mesh !< Associate field to a mesh. procedure :: init !< Initilize field. procedure :: output !< Output field data. procedure , private :: sub !< Subtract fields. procedure , private :: mul !< Multiply fields. procedure , private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. ! public methods procedure :: set !< Set field. ! operators endtype field_fd_1d","tags":"","loc":"type/field_fd_1d.html","title":"field_fd_1d â€“ openpde "},{"text":"type, public, abstract :: field type~~field~~InheritsGraph type~field field type~mesh mesh type~mesh->type~field m Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class for field handling. Inherited By type~~field~~InheritedByGraph type~field field type~field_fd_1d field_fd_1d type~field->type~field_fd_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure( abstract_simmetric_operator ), private, deferred :: add Add fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable procedure( abstract_assign ), private, deferred :: assign_field Assign fields. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs class( field ), intent(in), target :: rhs procedure( abstract_associate_mesh ), private, deferred :: associate_mesh Associate field to a mesh. subroutine abstract_associate_mesh (this, fieldmesh, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh integer(kind=I4P), intent(out), optional :: error procedure( abstract_init ), public, deferred :: init Initilize field. subroutine abstract_init (this, fieldmesh, description, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error procedure( abstract_simmetric_operator ), private, deferred :: mul Multiply fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable procedure( abstract_field_op_real ), private, deferred :: mulreal Multiply field for real. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs real(kind=R8P), intent(in) :: rhs Return Value class( field ),\n  allocatable procedure( abstract_output ), public, deferred :: output Output field data. subroutine abstract_output (this, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this character(len=*), intent(in) :: filename integer(kind=I4P), intent(out), optional :: error procedure( abstract_simmetric_operator ), private, deferred :: sub Subtract fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable procedure( abstract_real_op_field ), private, deferred, pass(rhs) :: realmul Multiply real for field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs class( field ), intent(in) :: rhs Return Value class( field ),\n  allocatable procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory. generic, public :: operator(+) => add Operator + overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs class( field ), intent(in) :: rhs Return Value class( field ),\n  allocatable function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs real(kind=R8P), intent(in) :: rhs Return Value class( field ),\n  allocatable generic, public :: operator(-) => sub Operator - overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable generic, public :: assignment(=) => assign_field Assignment overloading. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs class( field ), intent(in), target :: rhs Source Code type , abstract :: field !< Abstract class for *field* handling. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred methods procedure ( abstract_simmetric_operator ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_associate_mesh ), private , deferred :: associate_mesh !< Associate field to a mesh. procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_simmetric_operator ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_output ), deferred :: output !< Output field data. procedure ( abstract_simmetric_operator ), private , deferred :: sub !< Subtract fields. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. !RIMETTERE !procedure :: assigreal   => assigreal_mesh_fd_1d_scal ! public methods procedure :: free !< Free dynamic memory. ! operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. endtype field","tags":"","loc":"type/field.html","title":"field â€“ openpde "},{"text":"type, public, abstract :: equation Abstract class for equation handling. The concrete types are implemented at application level (by the user)\n predefined examples might be provided as well. Inherited By type~~equation~~InheritedByGraph type~equation equation type~burgers_equation burgers_equation type~equation->type~burgers_equation Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure( abstract_forcing ), public, deferred :: forcing Forcing equation. function abstract_forcing (this, inp, t) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable procedure( abstract_init ), public, deferred :: init Initialize the equation. function abstract_init (this) result(res) Prototype Arguments Type Intent Optional Attributes Name class( equation ) :: this Return Value integer procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. Source Code type , abstract :: equation !< Abstract class for *equation* handling. !< !< The concrete types are implemented at application level (by the user) !< predefined examples might be provided as well. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred methods procedure ( abstract_forcing ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), deferred :: init !< Initialize the equation. ! public methods procedure :: free !< Free dynamic memory. endtype equation","tags":"","loc":"type/equation.html","title":"equation â€“ openpde "},{"text":"type, public, abstract :: spatial_operator Inherited By type~~spatial_operator~~InheritedByGraph type~spatial_operator spatial_operator type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator->type~spatial_operator_der1 type~burgers_equation burgers_equation type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1->type~spatial_operator_der1_fd_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred :: operate Operator operation. function abstract_operate (this, inp) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( spatial_operator ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable Source Code type , abstract :: spatial_operator character ( len = :), allocatable :: description !< Operator description. contains procedure ( abstract_operate ), deferred :: operate !< Operator operation. endtype spatial_operator","tags":"","loc":"type/spatial_operator.html","title":"spatial_operator â€“ openpde "},{"text":"type, public, extends( integrator ) :: integrator_euler type~~integrator_euler~~InheritsGraph type~integrator_euler integrator_euler type~integrator integrator type~integrator->type~integrator_euler Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler integrator. Type-Bound Procedures procedure, public :: integrate Integrate the field accordingly the equation. private function integrate (this, equ, t, inp) result(res) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer Source Code type , extends ( integrator ) :: integrator_euler !< Euler integrator. contains procedure :: integrate !< Integrate the field accordingly the equation. endtype integrator_euler","tags":"","loc":"type/integrator_euler.html","title":"integrator_euler â€“ openpde "},{"text":"type, public, extends( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d type~~spatial_operator_der1_fd_1d~~InheritsGraph type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator_der1->type~spatial_operator_der1_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable,target Source Code type , extends ( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d !< Concrete class of spatial operator for 1D derivative for Finite Difference 1D. contains procedure :: operate !< Operator operation. endtype spatial_operator_der1_fd_1d","tags":"","loc":"type/spatial_operator_der1_fd_1d.html","title":"spatial_operator_der1_fd_1d â€“ openpde "},{"text":"type, public, extends( mesh ) :: mesh_fd_1d type~~mesh_fd_1d~~InheritsGraph type~mesh_fd_1d mesh_fd_1d type~mesh mesh type~mesh->type~mesh_fd_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Finite difference 1D class for mesh handling. Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: n Number of points. integer(kind=I4P), public :: ng Number of ghost points. integer(kind=I4P), public :: s Number of replicas for steps/stages. real(kind=R8P), public :: h Cell size. Type-Bound Procedures procedure, public :: init Initilize mesh. private pure subroutine init (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D mesh. procedure, public :: output Output mesh data. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I4P), intent(out), optional :: error Error status. Description Output mesh data. procedure, public :: set Set mesh. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(in), optional :: n Number of points. integer(kind=I4P), intent(in), optional :: ng Number of ghost points. integer(kind=I4P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R8P), intent(in), optional :: h Cell size. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh. Source Code type , extends ( mesh ) :: mesh_fd_1d !< Finite difference 1D class for *mesh* handling. integer ( I4P ) :: n !< Number of points. integer ( I4P ) :: ng !< Number of ghost points. integer ( I4P ) :: s !< Number of replicas for steps/stages. real ( R8P ) :: h !< Cell size. contains procedure :: init !< Initilize mesh. procedure :: output !< Output mesh data. procedure :: set !< Set mesh. endtype mesh_fd_1d","tags":"","loc":"type/mesh_fd_1d.html","title":"mesh_fd_1d â€“ openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_der1 type~~spatial_operator_der1~~InheritsGraph type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Inherited By type~~spatial_operator_der1~~InheritedByGraph type~spatial_operator_der1 spatial_operator_der1 type~burgers_equation burgers_equation type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator_der1_fd_1d spatial_operator_der1_fd_1d type~spatial_operator_der1->type~spatial_operator_der1_fd_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_der1 endtype spatial_operator_der1","tags":"","loc":"type/spatial_operator_der1.html","title":"spatial_operator_der1 â€“ openpde "},{"text":"type, public, abstract :: integrator Abstract class for integrator handling. Inherited By type~~integrator~~InheritedByGraph type~integrator integrator type~integrator_euler integrator_euler type~integrator->type~integrator_euler Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. real(kind=R8P), public :: dt = 0._R8P Time step. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. procedure( abstract_integrate ), public, deferred :: integrate Integrate the field accordingly the equation. function abstract_integrate (this, equ, t, inp) result(res) Prototype Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer Source Code type , abstract :: integrator !< Abstract class for *integrator* handling. character ( len = :), allocatable :: description !< Mesh description. real ( R8P ) :: dt = 0._R8P !< Time step. contains procedure :: free !< Free dynamic memory. procedure ( abstract_integrate ), deferred :: integrate !< Integrate the field accordingly the equation. endtype integrator","tags":"","loc":"type/integrator.html","title":"integrator â€“ openpde "},{"text":"type, public, abstract :: mesh Abstract class for mesh handling. Inherited By type~~mesh~~InheritedByGraph type~mesh mesh type~field field type~mesh->type~field m type~mesh_fd_1d mesh_fd_1d type~mesh->type~mesh_fd_1d type~field_fd_1d field_fd_1d type~field->type~field_fd_1d Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. procedure( abstract_meshinit ), public, deferred :: init Initilize mesh. subroutine abstract_meshinit (this, description, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error procedure( abstract_meshoutput ), public, deferred :: output Output mesh data. subroutine abstract_meshoutput (this, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this integer(kind=I4P), intent(out), optional :: error Source Code type , abstract :: mesh !< Abstract class for *mesh* handling. character ( len = :), allocatable :: description !< Mesh description. contains procedure :: free !< Free dynamic memory. procedure ( abstract_meshinit ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , deferred :: output !< Output mesh data. endtype mesh","tags":"","loc":"type/mesh.html","title":"mesh â€“ openpde "},{"text":"type, public, extends( equation ) :: burgers_equation type~~burgers_equation~~InheritsGraph type~burgers_equation burgers_equation type~spatial_operator_der1 spatial_operator_der1 type~spatial_operator_der1->type~burgers_equation der1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_der1 type~equation equation type~equation->type~burgers_equation Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1 Type-Bound Procedures procedure, public :: init => init_burgers private function init_burgers (this) result(res) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this Return Value integer procedure, public :: forcing => forcing_burgers private function forcing_burgers (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable Source Code type , extends ( equation ) :: burgers_equation ! The reason the next is a pointer is just to make it a pointee ! when pointed inside forcing_burgers function class ( spatial_operator_der1 ), pointer :: der1 contains procedure :: init => init_burgers procedure :: forcing => forcing_burgers endtype burgers_equation","tags":"","loc":"type/burgers_equation.html","title":"burgers_equation â€“ openpde "},{"text":"abstract interface private function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable","tags":"","loc":"interface/abstract_simmetric_operator.html","title":"abstract_simmetric_operator â€“ openpde"},{"text":"abstract interface private function abstract_field_op_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs real(kind=R8P), intent(in) :: rhs Return Value class( field ),\n  allocatable","tags":"","loc":"interface/abstract_field_op_real.html","title":"abstract_field_op_real â€“ openpde"},{"text":"abstract interface private function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs class( field ), intent(in) :: rhs Return Value class( field ),\n  allocatable","tags":"","loc":"interface/abstract_real_op_field.html","title":"abstract_real_op_field â€“ openpde"},{"text":"abstract interface private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs class( field ), intent(in), target :: rhs","tags":"","loc":"interface/abstract_assign.html","title":"abstract_assign â€“ openpde"},{"text":"abstract interface private subroutine abstract_associate_mesh(this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh integer(kind=I4P), intent(out), optional :: error","tags":"","loc":"interface/abstract_associate_mesh.html","title":"abstract_associate_mesh â€“ openpde"},{"text":"abstract interface private subroutine abstract_init(this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error","tags":"","loc":"interface/abstract_init.html","title":"abstract_init â€“ openpde"},{"text":"abstract interface private subroutine abstract_output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this character(len=*), intent(in) :: filename integer(kind=I4P), intent(out), optional :: error","tags":"","loc":"interface/abstract_output.html","title":"abstract_output â€“ openpde"},{"text":"abstract interface private function abstract_forcing(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable","tags":"","loc":"interface/abstract_forcing.html","title":"abstract_forcing â€“ openpde"},{"text":"abstract interface private function abstract_init(this) result(res) Arguments Type Intent Optional Attributes Name class( equation ) :: this Return Value integer","tags":"","loc":"interface/abstract_init~2.html","title":"abstract_init â€“ openpde"},{"text":"abstract interface private function abstract_operate(this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable","tags":"","loc":"interface/abstract_operate.html","title":"abstract_operate â€“ openpde"},{"text":"abstract interface private function abstract_integrate(this, equ, t, inp) result(res) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer","tags":"","loc":"interface/abstract_integrate.html","title":"abstract_integrate â€“ openpde"},{"text":"abstract interface private subroutine abstract_meshinit(this, description, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error","tags":"","loc":"interface/abstract_meshinit.html","title":"abstract_meshinit â€“ openpde"},{"text":"abstract interface private subroutine abstract_meshoutput(this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this integer(kind=I4P), intent(out), optional :: error","tags":"","loc":"interface/abstract_meshoutput.html","title":"abstract_meshoutput â€“ openpde"},{"text":"private function add(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add.html","title":"add â€“ openpde"},{"text":"private function mul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul.html","title":"mul â€“ openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal.html","title":"mulreal â€“ openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_fd_1d ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => rhs % m opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul.html","title":"realmul â€“ openpde"},{"text":"private function sub(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_fd_1d ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to add' end select allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select associate ( mm => lhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate allocate ( opr_cur % val ( 1 : mesh_cur % n )) opr_cur % m => lhs % m opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub.html","title":"sub â€“ openpde"},{"text":"private subroutine assign_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: rhs_cur Dummy pointer for rhs. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_fd_1d ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_fd_1d ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. select type ( rhs ) type is ( field_fd_1d ) rhs_cur => rhs class default STOP 'Error passing field to assign' end select associate ( mm => rhs % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate if ( allocated ( lhs % val )) deallocate ( lhs % val ) allocate ( lhs % val ( 1 : mesh_cur % n )) lhs % m => rhs_cur % m lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field.html","title":"assign_field â€“ openpde"},{"text":"private subroutine associate_mesh(this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I4P), intent(out), optional :: error Error status. Description Associate field to a mesh. Variables Type Visibility Attributes Name Initial class( mesh_fd_1d ), public, pointer :: fieldmesh_cur Dummy pointer for mesh. Source Code subroutine associate_mesh ( this , fieldmesh , error ) !< Associate field to a mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. integer ( I4P ), intent ( out ), optional :: error !< Error status. class ( mesh_fd_1d ), pointer :: fieldmesh_cur !< Dummy pointer for mesh. select type ( fieldmesh ) type is ( mesh_fd_1d ) fieldmesh_cur => fieldmesh class default STOP 'Error passing mesh' end select this % m => fieldmesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 : fieldmesh_cur % n )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh.html","title":"associate_mesh â€“ openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_fd_1d ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % val )) deallocate ( this % val ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free","tags":"","loc":"proc/free.html","title":"free â€“ openpde"},{"text":"private subroutine init(this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. Source Code subroutine init ( this , fieldmesh , description , error ) !< Initialize finite difference 1D field. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( out ), optional :: error !< Error status. call this % free call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description call random_number ( this % val ) if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init.html","title":"init â€“ openpde"},{"text":"private subroutine output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I4P), intent(out), optional :: error Error status. Description Output field data. Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_fd_1d ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I4P ), intent ( out ), optional :: error !< Error status. open ( unit = 11 , file = filename ) write ( 11 , * ) this % val (:) close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output.html","title":"output â€“ openpde"},{"text":"private subroutine set(this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R8P), intent(in), optional :: val (1:) Field value. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh. Source Code subroutine set ( this , fieldmesh , description , val , error ) !< Set mesh. class ( field_fd_1d ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: fieldmesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R8P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( present ( fieldmesh )) call this % associate_mesh ( fieldmesh = fieldmesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val = val if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set.html","title":"set â€“ openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) deallocate(this%m) ; this%m => null() end subroutine free","tags":"","loc":"proc/free~2.html","title":"free â€“ openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~3.html","title":"free â€“ openpde"},{"text":"private function integrate(this, equ, t, inp) result(res) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer Variables Type Visibility Attributes Name Initial class( field ), public, allocatable :: for Source Code function integrate ( this , equ , t , inp ) result ( res ) class ( integrator_euler ), intent ( in ) :: this class ( equation ), intent ( in ), target :: equ real ( R8P ), intent ( in ) :: t class ( field ), intent ( inout ), target :: inp integer :: res class ( field ), allocatable :: for select type ( inp ) type is ( field_fd_1d ) print * , \"t, dt, inp: \" , t , this % dt , inp % val end select allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for res = 0 end function integrate","tags":"","loc":"proc/integrate.html","title":"integrate â€“ openpde"},{"text":"private function operate(this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable,target Variables Type Visibility Attributes Name Initial class( field_fd_1d ), public, pointer :: inp_cur class( field_fd_1d ), public, pointer :: opr_cur Dummy pointer for operator result. class( mesh_fd_1d ), public, pointer :: mesh_cur Dummy pointer for mesh. real(kind=R8P), public :: h integer, public :: i integer, public :: n Source Code function operate ( this , inp ) result ( opr ) class ( spatial_operator_der1_fd_1d ) :: this class ( field ), target :: inp class ( field_fd_1d ), pointer :: inp_cur class ( field ), allocatable , target :: opr class ( field_fd_1d ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_fd_1d ), pointer :: mesh_cur !< Dummy pointer for mesh. real ( R8P ) :: h integer :: i , n allocate ( field_fd_1d :: opr ) select type ( opr ) type is ( field_fd_1d ) opr_cur => opr class default STOP 'Error passing field to add' end select select type ( inp ) type is ( field_fd_1d ) inp_cur => inp class default STOP 'Error passing field to spatial operate' end select associate ( mm => inp % m ) select type ( mm ) type is ( mesh_fd_1d ) mesh_cur => mm class default STOP 'Error getting mesh' end select end associate h = mesh_cur % h n = mesh_cur % n allocate ( opr_cur % val ( 1 : n )) opr_cur % m => mesh_cur do i = 2 , n - 1 opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i - 1 )) / ( 2. * h ) enddo opr_cur % val ( 1 ) = ( inp_cur % val ( 2 ) - inp_cur % val ( n )) / ( 2. * h ) opr_cur % val ( n ) = ( inp_cur % val ( 1 ) - inp_cur % val ( n - 1 )) / ( 2. * h ) end function operate","tags":"","loc":"proc/operate.html","title":"operate â€“ openpde"},{"text":"private pure subroutine init(this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D mesh. Source Code pure subroutine init ( this , description , error ) !< Initialize finite difference 1D mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % n = 50 this % ng = 2 this % s = 1 this % h = 0.1_R8P if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~2.html","title":"init â€“ openpde"},{"text":"private subroutine output(this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I4P), intent(out), optional :: error Error status. Description Output mesh data. Source Code subroutine output ( this , error ) !< Output mesh data. class ( mesh_fd_1d ), intent ( in ) :: this !< The mesh. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~2.html","title":"output â€“ openpde"},{"text":"private pure subroutine set(this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(in), optional :: n Number of points. integer(kind=I4P), intent(in), optional :: ng Number of ghost points. integer(kind=I4P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R8P), intent(in), optional :: h Cell size. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh. Source Code pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_fd_1d ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I4P ), intent ( in ), optional :: n !< Number of points. integer ( I4P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I4P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R8P ), intent ( in ), optional :: h !< Cell size. integer ( I4P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~2.html","title":"set â€“ openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~4.html","title":"free â€“ openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~5.html","title":"free â€“ openpde"},{"text":"private function init_burgers(this) result(res) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this Return Value integer Source Code function init_burgers ( this ) result ( res ) class ( burgers_equation ) :: this integer :: res ! The next is to be read by JSON allocate ( spatial_operator_der1_fd_1d :: this % der1 ) res = 0 end function init_burgers","tags":"","loc":"proc/init_burgers.html","title":"init_burgers â€“ openpde"},{"text":"private function forcing_burgers(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable Variables Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1_cur Source Code function forcing_burgers ( this , inp , t ) result ( opr ) class ( burgers_equation ) :: this class ( field ), target :: inp real ( R8P ) :: t class ( field ), allocatable :: opr class ( spatial_operator_der1 ), pointer :: der1_cur allocate ( opr , source = inp ) !USELESS        associate(d1 => this%der1) !USELESS            select type(d1) !USELESS                type is(spatialop_fd_1d_der1_c) !USELESS                    der1_cur => this%der1 !USELESS                class default !USELESS                   STOP 'Error passing field to add' !USELESS            endselect !USELESS        endassociate der1_cur => this % der1 opr = der1_cur % operate ( inp ) !OK TOO        opr = this%der1%operate(inp) end function forcing_burgers","tags":"","loc":"proc/forcing_burgers.html","title":"forcing_burgers â€“ openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_mesh opendiff_kinds opendiff_mesh_fd_1d module~~opendiff_field_fd_1d~~UsesGraph module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_adt_field Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 1D. Used By module~~opendiff_field_fd_1d~~UsedByGraph module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_field_fd_1d->module~opendiff module~opendiff_integrator_euler->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( field ) :: field_fd_1d Components Type Visibility Attributes Name Initial real(kind=R8P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, private :: add Add fields. procedure, private :: assign_field Assign fields. procedure, private :: associate_mesh Associate field to a mesh. procedure, public :: init Initilize field. procedure, public :: output Output field data. procedure, private :: sub Subtract fields. procedure, private :: mul Multiply fields. procedure, private :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, public :: set Set field. Description Finite difference 1D class for field handling. Functions private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_fd_1d ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Subroutines private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. private subroutine associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. integer(kind=I4P), intent(out), optional :: error Error status. Description Associate field to a mesh. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The mesh. Description Free dynamic memory. private subroutine init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I4P), intent(out), optional :: error Error status. Description Output field data. private subroutine set (this, fieldmesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_fd_1d ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: fieldmesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R8P), intent(in), optional :: val (1:) Field value. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh.","tags":"","loc":"module/opendiff_field_fd_1d.html","title":"opendiff_field_fd_1d â€“ openpde"},{"text":"Uses: opendiff_adt_mesh opendiff_kinds module~~opendiff_adt_field~~UsesGraph module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_mesh Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of field. Used By module~~opendiff_adt_field~~UsedByGraph module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff opendiff module~opendiff_adt_field->module~opendiff module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_integrator_euler->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_integrator->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~myequations->program~burgers var panmoduleopendiff_adt_fieldUsedByGraph = svgPanZoom('#moduleopendiff_adt_fieldUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function abstract_simmetric_operator (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs class( field ), intent(in), target :: rhs Return Value class( field ),\n  allocatable abstract interface private function abstract_field_op_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs real(kind=R8P), intent(in) :: rhs Return Value class( field ),\n  allocatable abstract interface private function abstract_real_op_field (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs class( field ), intent(in) :: rhs Return Value class( field ),\n  allocatable abstract interface private subroutine abstract_assign (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs class( field ), intent(in), target :: rhs abstract interface private subroutine abstract_associate_mesh (this, fieldmesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh integer(kind=I4P), intent(out), optional :: error abstract interface private subroutine abstract_init (this, fieldmesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this class( mesh ), intent(in), target :: fieldmesh character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error abstract interface private subroutine abstract_output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this character(len=*), intent(in) :: filename integer(kind=I4P), intent(out), optional :: error Derived Types type, public, abstract :: field Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure(abstract_simmetric_operator), private :: add Add fields. procedure(abstract_assign), private :: assign_field Assign fields. procedure(abstract_associate_mesh), private :: associate_mesh Associate field to a mesh. procedure(abstract_init), public :: init Initilize field. procedure(abstract_simmetric_operator), private :: mul Multiply fields. procedure(abstract_field_op_real), private :: mulreal Multiply field for real. procedure(abstract_output), public :: output Output field data. procedure(abstract_simmetric_operator), private :: sub Subtract fields. procedure(abstract_real_op_field), private, pass(rhs) :: realmul Multiply real for field. procedure, public :: free Free dynamic memory. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. Description Abstract class for field handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The mesh. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_field.html","title":"opendiff_adt_field â€“ openpde"},{"text":"Uses: opendiff_adt_field opendiff_kinds module~~opendiff_adt_equation~~UsesGraph module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of equation. Used By module~~opendiff_adt_equation~~UsedByGraph module~opendiff_adt_equation opendiff_adt_equation module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff opendiff module~opendiff_adt_equation->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_integrator_euler->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_integrator->module~opendiff module~myequations->program~burgers var panmoduleopendiff_adt_equationUsedByGraph = svgPanZoom('#moduleopendiff_adt_equationUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function abstract_forcing (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable abstract interface private function abstract_init (this) result(res) Arguments Type Intent Optional Attributes Name class( equation ) :: this Return Value integer Derived Types type, public, abstract :: equation Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure(abstract_forcing), public :: forcing Forcing equation. procedure(abstract_init), public :: init Initialize the equation. procedure, public :: free Free dynamic memory. Description Abstract class for equation handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_equation.html","title":"opendiff_adt_equation â€“ openpde"},{"text":"Uses: opendiff_adt_field module~~opendiff_adt_spatial_operator~~UsesGraph module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_mesh Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator. Used By module~~opendiff_adt_spatial_operator~~UsedByGraph module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff opendiff module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations->program~burgers var panmoduleopendiff_adt_spatial_operatorUsedByGraph = svgPanZoom('#moduleopendiff_adt_spatial_operatorUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function abstract_operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable Derived Types type, public, abstract :: spatial_operator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public :: operate Operator operation.","tags":"","loc":"module/opendiff_adt_spatial_operator.html","title":"opendiff_adt_spatial_operator â€“ openpde"},{"text":"opendiff kinds: definition of reals and integer kind parameters of opendiff library. Used By module~~opendiff_kinds~~UsedByGraph module~opendiff_kinds opendiff_kinds module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~myequations myequations module~opendiff_kinds->module~myequations module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff opendiff module~opendiff_adt_equation->module~opendiff module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_integrator->module~opendiff module~opendiff_integrator_euler->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff program~burgers burgers module~myequations->program~burgers module~opendiff->module~myequations module~opendiff->program~burgers module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff var panmoduleopendiff_kindsUsedByGraph = svgPanZoom('#moduleopendiff_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/opendiff_kinds.html","title":"opendiff_kinds â€“ openpde"},{"text":"Uses: opendiff_adt_equation opendiff_adt_field opendiff_adt_integrator opendiff_field_fd_1d opendiff_kinds module~~opendiff_integrator_euler~~UsesGraph module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d var panmoduleopendiff_integrator_eulerUsesGraph = svgPanZoom('#moduleopendiff_integrator_eulerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of Euler integrator. Used By module~~opendiff_integrator_euler~~UsedByGraph module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff opendiff module~opendiff_integrator_euler->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( integrator ) :: integrator_euler Type-Bound Procedures procedure, public :: integrate Integrate the field accordingly the equation. Description Euler integrator. Functions private function integrate (this, equ, t, inp) result(res) Arguments Type Intent Optional Attributes Name class( integrator_euler ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer","tags":"","loc":"module/opendiff_integrator_euler.html","title":"opendiff_integrator_euler â€“ openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_spatial_operator_der1 opendiff_field_fd_1d opendiff_kinds opendiff_mesh_fd_1d module~~opendiff_spatial_operator_der1_fd_1d~~UsesGraph module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 var panmoduleopendiff_spatial_operator_der1_fd_1dUsesGraph = svgPanZoom('#moduleopendiff_spatial_operator_der1_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Used By module~~opendiff_spatial_operator_der1_fd_1d~~UsedByGraph module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_der1 ) :: spatial_operator_der1_fd_1d Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator for 1D derivative for Finite Difference 1D. Functions private function operate (this, inp) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_der1_fd_1d ) :: this class( field ), , target :: inp Return Value class( field ),\n  allocatable,target","tags":"","loc":"module/opendiff_spatial_operator_der1_fd_1d.html","title":"opendiff_spatial_operator_der1_fd_1d â€“ openpde"},{"text":"Uses: opendiff_adt_equation opendiff_adt_field opendiff_adt_integrator opendiff_adt_mesh opendiff_adt_spatial_operator opendiff_adt_spatial_operator_der1 opendiff_field_fd_1d opendiff_integrator_euler opendiff_mesh_fd_1d opendiff_spatial_operator_der1_fd_1d module~~opendiff~~UsesGraph module~opendiff opendiff module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_equation->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_adt_field var panmoduleopendiffUsesGraph = svgPanZoom('#moduleopendiffUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. opendiff: Open Fortran Library for PDE solving. Used By module~~opendiff~~UsedByGraph module~opendiff opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/opendiff.html","title":"opendiff â€“ openpde"},{"text":"Uses: opendiff_adt_mesh opendiff_kinds module~~opendiff_mesh_fd_1d~~UsesGraph module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_adt_mesh Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 1D. Used By module~~opendiff_mesh_fd_1d~~UsedByGraph module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_integrator_euler->module~opendiff module~myequations->program~burgers var panmoduleopendiff_mesh_fd_1dUsedByGraph = svgPanZoom('#moduleopendiff_mesh_fd_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( mesh ) :: mesh_fd_1d Components Type Visibility Attributes Name Initial integer(kind=I4P), public :: n Number of points. integer(kind=I4P), public :: ng Number of ghost points. integer(kind=I4P), public :: s Number of replicas for steps/stages. real(kind=R8P), public :: h Cell size. Type-Bound Procedures procedure, public :: init Initilize mesh. procedure, public :: output Output mesh data. procedure, public :: set Set mesh. Description Finite difference 1D class for mesh handling. Subroutines private pure subroutine init (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(out), optional :: error Error status. Description Initialize finite difference 1D mesh. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(in) :: this The mesh. integer(kind=I4P), intent(out), optional :: error Error status. Description Output mesh data. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_fd_1d ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I4P), intent(in), optional :: n Number of points. integer(kind=I4P), intent(in), optional :: ng Number of ghost points. integer(kind=I4P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R8P), intent(in), optional :: h Cell size. integer(kind=I4P), intent(out), optional :: error Error status. Description Set mesh.","tags":"","loc":"module/opendiff_mesh_fd_1d.html","title":"opendiff_mesh_fd_1d â€“ openpde"},{"text":"Uses: opendiff_adt_spatial_operator module~~opendiff_adt_spatial_operator_der1~~UsesGraph module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_mesh var panmoduleopendiff_adt_spatial_operator_der1UsesGraph = svgPanZoom('#moduleopendiff_adt_spatial_operator_der1UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator for 1D derivative. Used By module~~opendiff_adt_spatial_operator_der1~~UsedByGraph module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers var panmoduleopendiff_adt_spatial_operator_der1UsedByGraph = svgPanZoom('#moduleopendiff_adt_spatial_operator_der1UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_der1","tags":"","loc":"module/opendiff_adt_spatial_operator_der1.html","title":"opendiff_adt_spatial_operator_der1 â€“ openpde"},{"text":"Uses: opendiff_adt_field opendiff_adt_equation opendiff_kinds module~~opendiff_adt_integrator~~UsesGraph module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff_adt_field var panmoduleopendiff_adt_integratorUsesGraph = svgPanZoom('#moduleopendiff_adt_integratorUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of integrator. Used By module~~opendiff_adt_integrator~~UsedByGraph module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff opendiff module~opendiff_adt_integrator->module~opendiff module~opendiff_integrator_euler->module~opendiff module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private function abstract_integrate (this, equ, t, inp) result(res) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this class( equation ), intent(in), target :: equ real(kind=R8P), intent(in) :: t class( field ), intent(inout), target :: inp Return Value integer Derived Types type, public, abstract :: integrator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. real(kind=R8P), public :: dt = 0._R8P Time step. Type-Bound Procedures procedure, public :: free Free dynamic memory. procedure(abstract_integrate), public :: integrate Integrate the field accordingly the equation. Description Abstract class for integrator handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_integrator.html","title":"opendiff_adt_integrator â€“ openpde"},{"text":"Uses: opendiff_kinds module~~opendiff_adt_mesh~~UsesGraph module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~opendiff_adt_mesh Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of mesh. Used By module~~opendiff_adt_mesh~~UsedByGraph module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_field_fd_1d->module~opendiff module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~myequations myequations module~opendiff->module~myequations program~burgers burgers module~opendiff->program~burgers module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_integrator_euler->module~opendiff module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~myequations->program~burgers module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d var panmoduleopendiff_adt_meshUsedByGraph = svgPanZoom('#moduleopendiff_adt_meshUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine abstract_meshinit (this, description, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this character(len=*), intent(in), optional :: description integer(kind=I4P), intent(out), optional :: error abstract interface private subroutine abstract_meshoutput (this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this integer(kind=I4P), intent(out), optional :: error Derived Types type, public, abstract :: mesh Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure, public :: free Free dynamic memory. procedure(abstract_meshinit), public :: init Initilize mesh. procedure(abstract_meshoutput), public :: output Output mesh data. Description Abstract class for mesh handling. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory.","tags":"","loc":"module/opendiff_adt_mesh.html","title":"opendiff_adt_mesh â€“ openpde"},{"text":"Uses: opendiff opendiff_kinds module~~myequations~~UsesGraph module~myequations myequations module~opendiff opendiff module~opendiff->module~myequations module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~myequations module~opendiff_adt_equation opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_kinds->module~opendiff_adt_field module~opendiff_adt_equation->module~opendiff module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d var panmodulemyequationsUsesGraph = svgPanZoom('#modulemyequationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~myequations~~UsedByGraph module~myequations myequations program~burgers burgers module~myequations->program~burgers Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( equation ) :: burgers_equation Components Type Visibility Attributes Name Initial class( spatial_operator_der1 ), public, pointer :: der1 Type-Bound Procedures procedure, public :: init => init_burgers procedure, public :: forcing => forcing_burgers Functions private function init_burgers (this) result(res) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this Return Value integer private function forcing_burgers (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( burgers_equation ) :: this class( field ), , target :: inp real(kind=R8P) :: t Return Value class( field ),\n  allocatable","tags":"","loc":"module/myequations.html","title":"myequations â€“ openpde"},{"text":"Uses: opendiff myequations program~~burgers~~UsesGraph program~burgers burgers module~opendiff opendiff module~opendiff->program~burgers module~myequations myequations module~opendiff->module~myequations module~myequations->program~burgers module~opendiff_adt_equation opendiff_adt_equation module~opendiff_adt_equation->module~opendiff module~opendiff_adt_integrator opendiff_adt_integrator module~opendiff_adt_equation->module~opendiff_adt_integrator module~opendiff_integrator_euler opendiff_integrator_euler module~opendiff_adt_equation->module~opendiff_integrator_euler module~opendiff_adt_spatial_operator opendiff_adt_spatial_operator module~opendiff_adt_spatial_operator->module~opendiff module~opendiff_adt_spatial_operator_der1 opendiff_adt_spatial_operator_der1 module~opendiff_adt_spatial_operator->module~opendiff_adt_spatial_operator_der1 module~opendiff_adt_integrator->module~opendiff module~opendiff_adt_integrator->module~opendiff_integrator_euler module~opendiff_integrator_euler->module~opendiff module~opendiff_mesh_fd_1d opendiff_mesh_fd_1d module~opendiff_mesh_fd_1d->module~opendiff module~opendiff_spatial_operator_der1_fd_1d opendiff_spatial_operator_der1_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_field_fd_1d opendiff_field_fd_1d module~opendiff_mesh_fd_1d->module~opendiff_field_fd_1d module~opendiff_spatial_operator_der1_fd_1d->module~opendiff module~opendiff_adt_mesh opendiff_adt_mesh module~opendiff_adt_mesh->module~opendiff module~opendiff_adt_mesh->module~opendiff_mesh_fd_1d module~opendiff_adt_mesh->module~opendiff_field_fd_1d module~opendiff_adt_field opendiff_adt_field module~opendiff_adt_mesh->module~opendiff_adt_field module~opendiff_field_fd_1d->module~opendiff module~opendiff_field_fd_1d->module~opendiff_integrator_euler module~opendiff_field_fd_1d->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_spatial_operator_der1->module~opendiff module~opendiff_adt_spatial_operator_der1->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff module~opendiff_adt_field->module~opendiff_adt_equation module~opendiff_adt_field->module~opendiff_adt_spatial_operator module~opendiff_adt_field->module~opendiff_adt_integrator module~opendiff_adt_field->module~opendiff_integrator_euler module~opendiff_adt_field->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_adt_field->module~opendiff_field_fd_1d module~opendiff_kinds opendiff_kinds module~opendiff_kinds->module~myequations module~opendiff_kinds->module~opendiff_adt_equation module~opendiff_kinds->module~opendiff_adt_integrator module~opendiff_kinds->module~opendiff_integrator_euler module~opendiff_kinds->module~opendiff_mesh_fd_1d module~opendiff_kinds->module~opendiff_spatial_operator_der1_fd_1d module~opendiff_kinds->module~opendiff_adt_mesh module~opendiff_kinds->module~opendiff_field_fd_1d module~opendiff_kinds->module~opendiff_adt_field var panprogramburgersUsesGraph = svgPanZoom('#programburgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: it integer :: er class( mesh ), allocatable :: m1 class( field ), allocatable :: u1 class( field ), allocatable :: u2 class( field ), allocatable :: u3 class( integrator ), allocatable :: integ integer :: itmin = 0 integer :: itmax = 10 type( burgers_equation ) :: burg_equ Source Code program burgers use opendiff use myequations integer :: it integer :: er class ( mesh ), allocatable :: m1 class ( field ), allocatable :: u1 class ( field ), allocatable :: u2 class ( field ), allocatable :: u3 !DER IN MAIN class(spatialop), allocatable :: der1d class ( integrator ), allocatable :: integ integer :: itmin = 0 , itmax = 10 type ( burgers_equation ) :: burg_equ ! These should be done reading from JSON input files and returning right ! pointers following factory pattern or similar allocate ( mesh_fd_1d :: m1 ) allocate ( field_fd_1d :: u1 ) allocate ( field_fd_1d :: u2 ) !DER IN MAIN allocate(spatialop_fd_1d_der1_c :: der1d) allocate ( integrator_euler :: integ ) allocate ( u3 , source = u1 ) integ % dt = 0.1 call m1 % init ( error = er ) call u1 % init ( m1 , error = er ) call u2 % init ( m1 , error = er ) er = burg_equ % init () u3 = u1 + u1 * u2 !DER IN MAIN u3 = der1d%operate(u1) !RIMETTERE    er = u1%output(filename=\"inizio.dat\") !RIMETTERE do it = itmin , itmax print * , 'it: ' , it er = integ % integrate ( inp = u1 , equ = burg_equ , t = it * integ % dt ) enddo !RIMETTERE !RIMETTERE    er = u1%output(filename=\"fine.dat\") call m1 % output ( error = er ) call u1 % output ( \"1ciao.dat\" , error = er ) call u2 % output ( \"2ciao.dat\" , error = er ) call u3 % output ( \"3ciao.dat\" , error = er ) end program burgers","tags":"","loc":"program/burgers.html","title":"burgers â€“ openpde"}]}