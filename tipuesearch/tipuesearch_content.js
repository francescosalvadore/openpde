var tipuesearch = {"pages":[{"text":"openpde Developer Info Francesco Salvadore","tags":"","loc":"index.html","title":" openpde "},{"text":"Definition of reals and integer kind parameters of openpde library. Source Code !< Definition of reals and integer kind parameters of openpde library. module openpde_kinds !< Definition of reals and integer kind parameters of openpde library. implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. end module openpde_kinds","tags":"","loc":"sourcefile/openpde_kinds.f90.html","title":"openpde_kinds.f90 – openpde"},{"text":"Open Fortran Library for PDE solving. Source Code !< Open Fortran Library for PDE solving. module openpde !< Open Fortran Library for PDE solving. ! abstract classes definition use openpde_equation_abstract use openpde_field_abstract use openpde_integrator_abstract use openpde_mesh_abstract use openpde_spatial_operator_abstract use openpde_spatial_operator_d1_abstract use openpde_spatial_operator_d2_abstract ! concrete classes definition use openpde_field_FD_1D use openpde_field_FD_2D use openpde_integrator_euler_explicit use openpde_mesh_FD_1D use openpde_mesh_FD_2D use openpde_spatial_operator_d1_FD_1D use openpde_spatial_operator_d1_FD_2D use openpde_spatial_operator_d2_FD_1D use openpde_spatial_operator_d2_FD_2D ! kinds definition use openpde_kinds implicit none private ! abstract classes public :: equation public :: field public :: integrator public :: mesh public :: spatial_operator public :: spatial_operator_d1 public :: spatial_operator_d2 ! concrete classes public :: associate_field_FD_1D , field_FD_1D public :: associate_field_FD_2D , field_FD_2D public :: integrator_euler_explicit public :: associate_mesh_FD_1D , mesh_FD_1D public :: associate_mesh_FD_2D , mesh_FD_2D public :: spatial_operator_d1_FD_1D public :: spatial_operator_d1_FD_2D public :: spatial_operator_d2_FD_1D public :: spatial_operator_d2_FD_2D ! kinds public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P end module openpde","tags":"","loc":"sourcefile/openpde.f90.html","title":"openpde.f90 – openpde"},{"text":"Concrete class of field for Finite Difference 2D methods. Source Code !< Concrete class of field for Finite Difference 2D methods. module openpde_field_FD_2D !< Concrete class of field for Finite Difference 2D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_mesh_abstract use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: associate_field_FD_2D , field_FD_2D type , extends ( field ) :: field_FD_2D !< Concrete class of field for Finite Difference 2D methods. real ( R_P ), allocatable , dimension (:,:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_2D contains ! public, non TBP subroutine associate_field_FD_2D ( field_input , calling_procedure , field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( field_FD_2D ), intent ( inout ), pointer :: field_pointer !< Finite Difference 2D field pointer. select type ( field_input ) type is ( field_FD_2D ) field_pointer => field_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_field_FD_2D ! deferred public methods subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. call associate_mesh_FD_2D ( mesh_input = field_mesh , & calling_procedure = 'associate_mesh_field_FD_2D(field_mesh)' , & mesh_pointer = mesh_cur ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) allocate ( this % val ( 1 - mesh_cur % ngx : mesh_cur % nx + mesh_cur % ngx , 1 - mesh_cur % ngy : mesh_cur % ny + mesh_cur % ngy )) if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 2D field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description call associate_mesh_FD_2D ( mesh_input = field_mesh , & calling_procedure = 'init_field_FD_2D(field_mesh)' , & mesh_pointer = mesh_cur ) do j = 1 - mesh_cur % ngy , mesh_cur % ny + mesh_cur % ngy do i = 1 - mesh_cur % ngx , mesh_cur % nx + mesh_cur % ngx this % val ( i , j ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % nx ) * sin ( j * 2._R_P * acos ( - 1._R_P ) / mesh_cur % ny ) enddo enddo if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_2D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: jmin !< Lower extent. integer ( I_P ) :: jmax !< Upper extent. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) jmin = lbound ( this % val , dim = 2 ) jmax = ubound ( this % val , dim = 2 ) open ( unit = 11 , file = filename ) do j = jmin , jmax do i = imin , imax write ( 11 , * ) this % val ( i , j ) enddo enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_2D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_2D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub ! public methods subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :, 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :, 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_2D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free end module openpde_field_FD_2D","tags":"","loc":"sourcefile/openpde_field_fd_2d.f90.html","title":"openpde_field_FD_2D.f90 – openpde"},{"text":"Abstract class of field. Source Code !< Abstract class of field. module openpde_field_abstract !< Abstract class of field. use openpde_mesh_abstract use openpde_kinds implicit none private public :: field type , abstract :: field !< Abstract class of field. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred public methods procedure ( abstract_associate_mesh ), pass ( this ), deferred :: associate_mesh !< Associate mesh. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize field. procedure ( abstract_output ), pass ( this ), deferred :: output !< Output field data. ! deferred private methods procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), pass ( lhs ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), pass ( lhs ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: sub !< Subtract fields. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype field ! deferred public methods interfaces abstract interface !< Associate a mesh to field. subroutine abstract_associate_mesh ( this , field_mesh , error ) !< Associate a mesh to field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_associate_mesh endinterface abstract interface !< Initialize the field. subroutine abstract_init ( this , field_mesh , description , error ) !< Initialize the field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< The mesh. character ( * ), intent ( in ), optional :: description !< Description of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Output the field. subroutine abstract_output ( this , filename , error ) !< Output the field. import :: field , I_P class ( field ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output fiel name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_output endinterface ! deferred private methods interfaces abstract interface !< Symmetric operator field.op.field. function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) !< Symmetric operator field.op.field. import :: field class ( field ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_simmetric_operator endinterface abstract interface !< Non symmetric operator field.op.real. function abstract_field_op_real ( lhs , rhs ) result ( opr ) !< Non symmetric operator field.op.real. import :: field , R_P class ( field ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_field_op_real endinterface abstract interface !< Non symmetric operator real.op.field. function abstract_real_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator real.op.field. import :: field , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_real_op_field endinterface abstract interface !< Assignment overloading. subroutine abstract_assign ( lhs , rhs ) !< Assignment overloading. import :: field class ( field ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. end subroutine abstract_assign endinterface contains ! public methods elemental subroutine free ( this ) !< Free dynamic memory. !< !< @todo Discuss about the *free* of mesh pointer. class ( field ), intent ( inout ) :: this !< The field. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) then !   call this%m%free !   deallocate(this%m) ! endif ! this%m => null() end subroutine free end module openpde_field_abstract","tags":"","loc":"sourcefile/openpde_field_abstract.f90.html","title":"openpde_field_abstract.f90 – openpde"},{"text":"Concrete class of field for Finite Difference 1D methods. Source Code !< Concrete class of field for Finite Difference 1D methods. module openpde_field_FD_1D !< Concrete class of field for Finite Difference 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_mesh_abstract use openpde_kinds use openpde_mesh_FD_1D implicit none private public :: associate_field_FD_1D , field_FD_1D type , extends ( field ) :: field_FD_1D !< Concrete class of field for Finite Difference 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_1D contains ! public, non TBP subroutine associate_field_FD_1D ( field_input , calling_procedure , field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( field_FD_1D ), intent ( inout ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) ' error: wrong field class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_field_FD_1D ! deferred public methods subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. call associate_mesh_FD_1D ( mesh_input = field_mesh , & calling_procedure = 'associate_mesh_field_FD_1D(field_mesh)' , & mesh_pointer = mesh_cur ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - mesh_cur % ng : mesh_cur % n + mesh_cur % ng )) if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description call associate_mesh_FD_1D ( mesh_input = field_mesh , & calling_procedure = 'init_field_FD_1D(field_mesh)' , & mesh_pointer = mesh_cur ) do i = 1 - mesh_cur % ng , mesh_cur % n + mesh_cur % ng this % val ( i ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % n ) enddo if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub ! public methods subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free end module openpde_field_FD_1D","tags":"","loc":"sourcefile/openpde_field_fd_1d.f90.html","title":"openpde_field_FD_1D.f90 – openpde"},{"text":"Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Source Code !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. module openpde_spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. use openpde_field_abstract use openpde_spatial_operator_d2_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: spatial_operator_d2_FD_2D type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_2D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_2D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_2D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_2D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_2D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_2D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - 2._R_P * inp_cur % val ( i , :) + inp_cur % val ( i - 1 , :)) / ( mesh_cur % hx ** 2 ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - 2._R_P * inp_cur % val (:, j ) + inp_cur % val (:, j - 1 )) / ( mesh_cur % hy ** 2 ) enddo endif end function operate end module openpde_spatial_operator_d2_FD_2D","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_fd_2d.f90.html","title":"openpde_spatial_operator_d2_FD_2D.f90 – openpde"},{"text":"Abstract class of spatial operator of second derivative. Source Code !< Abstract class of spatial operator of second derivative. module openpde_spatial_operator_d2_abstract !< Abstract class of spatial operator of second derivative. use openpde_spatial_operator_abstract implicit none private public :: spatial_operator_d2 type , abstract , extends ( spatial_operator ) :: spatial_operator_d2 !< Abstract class of spatial operator of second derivative. endtype spatial_operator_d2 end module openpde_spatial_operator_d2_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_abstract.f90.html","title":"openpde_spatial_operator_d2_abstract.f90 – openpde"},{"text":"Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Source Code !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. module openpde_spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. use openpde_field_abstract use openpde_spatial_operator_d1_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: spatial_operator_d1_FD_2D type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_2D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_2D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_2D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_2D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_2D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_2D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - inp_cur % val ( i , :)) / ( mesh_cur % hx ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - inp_cur % val (:, j )) / ( mesh_cur % hy ) enddo endif end function operate end module openpde_spatial_operator_d1_FD_2D","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_fd_2d.f90.html","title":"openpde_spatial_operator_d1_FD_2D.f90 – openpde"},{"text":"Abstract class of spatial operator of first derivative. Source Code !< Abstract class of spatial operator of first derivative. module openpde_spatial_operator_d1_abstract !< Abstract class of spatial operator of first derivative. use openpde_spatial_operator_abstract implicit none private public :: spatial_operator_d1 type , abstract , extends ( spatial_operator ) :: spatial_operator_d1 !< Abstract class of spatial operator of first derivative. endtype spatial_operator_d1 end module openpde_spatial_operator_d1_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_abstract.f90.html","title":"openpde_spatial_operator_d1_abstract.f90 – openpde"},{"text":"Abstract class of spatial operator. Source Code !< Abstract class of spatial operator. module openpde_spatial_operator_abstract !< Abstract class of spatial operator. use openpde_field_abstract use openpde_kinds implicit none private public :: spatial_operator type , abstract :: spatial_operator !< Abstract class of spatial operator. character ( len = :), allocatable :: description !< Operator description. contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype spatial_operator abstract interface !< Operator operation. function abstract_operate ( this , inp , dir ) result ( opr ) !< Operator function. import :: spatial_operator , field , I_P class ( spatial_operator ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. end function abstract_operate endinterface end module openpde_spatial_operator_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_abstract.f90.html","title":"openpde_spatial_operator_abstract.f90 – openpde"},{"text":"Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Source Code !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. module openpde_spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. use openpde_field_abstract use openpde_spatial_operator_d1_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D implicit none private public :: spatial_operator_d1_FD_1D type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_1D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_1D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_1D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_1D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( mesh_cur % h ) enddo end function operate end module openpde_spatial_operator_d1_FD_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_fd_1d.f90.html","title":"openpde_spatial_operator_d1_FD_1D.f90 – openpde"},{"text":"Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Source Code !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. module openpde_spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. use openpde_field_abstract use openpde_spatial_operator_d2_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D implicit none private public :: spatial_operator_d2_FD_1D type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_1D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_1D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_1D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_1D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - 2._R_P * inp_cur % val ( i ) + inp_cur % val ( i - 1 )) / ( mesh_cur % h ** 2 ) enddo end function operate end module openpde_spatial_operator_d2_FD_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_fd_1d.f90.html","title":"openpde_spatial_operator_d2_FD_1D.f90 – openpde"},{"text":"Concrete class of integrator, Euler explicit scheme. Source Code !< Concrete class of integrator, Euler explicit scheme. module openpde_integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_equation_abstract use openpde_field_abstract use openpde_integrator_abstract use openpde_kinds implicit none private public :: integrator_euler_explicit type , extends ( integrator ) :: integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_euler_explicit contains ! deferred public methods subroutine init ( this , description , filename , error ) !< Initialize integrator. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. class ( integrator_euler_explicit ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary call equ % bc ( inp = inp , t = t ) allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate ! private methods subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json end module openpde_integrator_euler_explicit","tags":"","loc":"sourcefile/openpde_integrator_euler_explicit.f90.html","title":"openpde_integrator_euler_explicit.f90 – openpde"},{"text":"Abstract class of integrator. Source Code !< Abstract class of integrator. module openpde_integrator_abstract !< Abstract class of integrator. use openpde_field_abstract use openpde_equation_abstract use openpde_kinds implicit none private public :: integrator type , abstract :: integrator !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator abstract interface !< Initialize integrator. subroutine abstract_init ( this , description , filename , error ) !< Initialize integrator. import :: I_P , integrator class ( integrator ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Integrate the field accordingly the equation. function abstract_integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly to the equation. import :: equation , field , integrator , I_P , R_P class ( integrator ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. end function abstract_integrate endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_integrator_abstract","tags":"","loc":"sourcefile/openpde_integrator_asbtract.f90.html","title":"openpde_integrator_asbtract.f90 – openpde"},{"text":"Abstract class of equation. Source Code !< Abstract class of equation. module openpde_equation_abstract !< Abstract class of equation. use openpde_field_abstract use openpde_kinds implicit none private public :: equation type , abstract :: equation !< Abstract class of equation. !< !< The concrete types are implemented at application level (by the user) predefined examples might be provided as well. character ( len = :), allocatable :: description !< Equation description. contains ! deferred public methods procedure ( abstract_bc ), pass ( this ), deferred :: bc !< Equation boundary conditions. procedure ( abstract_forcing ), pass ( this ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initialize the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype equation abstract interface !< Equation boundary conditions. subroutine abstract_bc ( this , inp , t ) !< Equation boundary condition. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. end subroutine abstract_bc endinterface abstract interface !< Initialize equation. subroutine abstract_init ( this , description , filename , error ) !< Initialize equation. import :: equation , I_P class ( equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Return the field after forcing the equation. function abstract_forcing ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed. end function abstract_forcing endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_equation_abstract","tags":"","loc":"sourcefile/openpde_equation_abstract.f90.html","title":"openpde_equation_abstract.f90 – openpde"},{"text":"Concrete class of mesh for Finite Difference 2D methods. Source Code !< Concrete class of mesh for Finite Difference 2D methods. module openpde_mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_mesh_abstract use openpde_kinds use vtk_fortran implicit none private public :: associate_mesh_FD_2D , mesh_FD_2D type , extends ( mesh ) :: mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. integer ( I_P ) :: nx = 0 !< Number of X points. integer ( I_P ) :: ny = 0 !< Number of Y points. integer ( I_P ) :: ngx = 0 !< Number of X ghost points. integer ( I_P ) :: ngy = 0 !< Number of Y ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: hx = 0._R_P !< Cell X size. real ( R_P ) :: hy = 0._R_P !< Cell Y size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods procedure , pass ( this ) :: set !< Set mesh. endtype mesh_FD_2D contains ! public, non TBP subroutine associate_mesh_FD_2D ( mesh_input , calling_procedure , mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( mesh_FD_2D ), intent ( inout ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_2D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_mesh_FD_2D ! deferred public methods pure subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % nx = 10 this % ny = 8 this % ngx = 2 this % ngy = 2 this % s = 1 this % hx = 0.05_R8P this % hy = 0.08_R8P if ( present ( error )) error = 0 end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_2D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"nx: \" , this % nx print * , \"ny: \" , this % ny print * , \"ngx: \" , this % ngx print * , \"ngy: \" , this % ngy print * , \"s: \" , this % s print * , \"hx: \" , this % hx print * , \"hy: \" , this % hy if ( present ( error )) error = 0 end subroutine output ! public methods pure subroutine set ( this , description , nx , ny , ngx , ngy , s , hx , hy , error ) !< Set mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nx !< Number of X points. integer ( I_P ), intent ( in ), optional :: ny !< Number of Y points. integer ( I_P ), intent ( in ), optional :: ngx !< Number of X ghost points. integer ( I_P ), intent ( in ), optional :: ngy !< Number of Y ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: hx !< Cell X size. real ( R_P ), intent ( in ), optional :: hy !< Cell Y size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( nx )) this % nx = nx if ( present ( ny )) this % ny = ny if ( present ( ngx )) this % ngx = ngx if ( present ( ngy )) this % ngy = ngy if ( present ( s )) this % s = s if ( present ( hx )) this % hx = hx if ( present ( hy )) this % hy = hy if ( present ( error )) error = 0 end subroutine set end module openpde_mesh_FD_2D","tags":"","loc":"sourcefile/openpde_mesh_fd_2d.f90.html","title":"openpde_mesh_FD_2D.f90 – openpde"},{"text":"Abstract class of mesh. Source Code !< Abstract class of mesh. module openpde_mesh_abstract !< Abstract class of mesh. use openpde_kinds implicit none private public :: mesh type , abstract :: mesh !< Abstract class of mesh. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred public methods procedure ( abstract_meshinit ), pass ( this ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , pass ( this ), deferred :: output !< Output mesh. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype mesh abstract interface !< Initialize mesh. subroutine abstract_meshinit ( this , description , filename , error ) !< Initialize mesh. import :: I_P , mesh class ( mesh ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshinit endinterface abstract interface !< Output mesh. subroutine abstract_meshoutput ( this , error ) !< Output mesh. import :: I_P , mesh class ( mesh ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshoutput endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_mesh_abstract","tags":"","loc":"sourcefile/openpde_mesh_abstract.f90.html","title":"openpde_mesh_abstract.f90 – openpde"},{"text":"Concrete class of mesh for Finite Difference 1D methods. Source Code !< Concrete class of mesh for Finite Difference 1D methods. module openpde_mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_mesh_abstract use openpde_kinds use vtk_fortran implicit none private public :: associate_mesh_FD_1D , mesh_FD_1D type , extends ( mesh ) :: mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. integer ( I_P ) :: n = 0 !< Number of points. integer ( I_P ) :: ng = 0 !< Number of ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! private methods procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FD_1D contains ! public, non TBP subroutine associate_mesh_FD_1D ( mesh_input , calling_procedure , mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( mesh_FD_1D ), intent ( inout ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_mesh_FD_1D ! deferred public methods subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % n = 50 this % ng = 2 this % s = 1 this % h = 0.05_R8P if ( present ( error )) error = 0 endif end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output ! public methods pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set ! private methods subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then call json % get ( 'mesh.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif call json % get ( 'mesh.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"ng\" missing' stop endif call json % get ( 'mesh.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"h\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif endsubroutine load_from_json end module openpde_mesh_FD_1D","tags":"","loc":"sourcefile/openpde_mesh_fd_1d.f90.html","title":"openpde_mesh_FD_1D.f90 – openpde"},{"text":"Openpde test: scalar simple equation. Source Code !< Openpde test: scalar simple equation. module scalar_simple_equation_m !< Scalar simple equation definition. !< The PDE solved is !< !<  \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} + b \\frac{\\partial&#94;2 u}{\\partial x&#94;2} = 0  !< where `a` and `b` are two constant scalars. !< !< This is a one dimensional, unsteady, linear PDE. It is solved adopting a finite difference approximations of !< first and second derivatives computed on a uniform mesh. !< !< The spatial operators are approximated as: !< !<  \\frac{\\partial u}{\\partial x}|_i = \\frac{u_{i+1}-u_i}{h} \\quad i=1,N  !<  \\frac{\\partial&#94;2 u}{\\partial x&#94;2}|_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{h&#94;2} \\quad i=1,N  !< where `N` is the number of discrete points and `h=L/N` is the (uniform) grid resolution, `L` is the domain length. !< !< The explicit Euler's method is used for advancing on time. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde implicit none private public :: scalar_simple_equation type , extends ( equation ) :: scalar_simple_equation !< (Fake) scalar_simple equations. !< !< @note The reason the `du` and `ddu` are pointers is just to make them a pointee when pointed !< inside [[equation:forcing]] function. real ( R_P ) :: a = 0._R_P !< `a` equation coefficient. real ( R_P ) :: b = 0._R_P !< `b` equation coefficient. class ( spatial_operator_d1 ), pointer :: du !< First derivative. class ( spatial_operator_d2 ), pointer :: ddu !< Second derivative. contains ! deferred public methods procedure , pass ( this ) :: bc !< Equation boundary conditions. procedure , pass ( this ) :: forcing !< Forcing equation. procedure , pass ( this ) :: init !< Initialize equation. ! public methods generic :: load => load_from_json !< Load equation definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load equation definition from jSON file. endtype scalar_simple_equation contains ! deferred public methods subroutine bc ( this , inp , t ) !< Equation boundary conditions imposition. class ( scalar_simple_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Field. real ( R_P ), intent ( in ) :: t !< Time. class ( field_FD_1D ), pointer :: inp_cur !< Pointer to input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Pointer to input mehs. integer ( I_P ) :: i !< Counter. call associate_field_FD_1D ( field_input = inp , calling_procedure = 'bc(inp)' , field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , calling_procedure = 'bc(inp%m)' , mesh_pointer = mesh_cur ) do i = 1 - mesh_cur % ng , 0 inp_cur % val ( i ) = inp_cur % val ( i + mesh_cur % n ) enddo do i = mesh_cur % n + 1 , mesh_cur % n + mesh_cur % ng inp_cur % val ( i ) = inp_cur % val ( i - mesh_cur % n ) enddo end subroutine bc function forcing ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. class ( scalar_simple_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed after forcing the residual function. class ( spatial_operator_d1 ), pointer :: du_opr !< Dummy pointer of the first derivative operator. class ( spatial_operator_d2 ), pointer :: ddu_opr !< Dummy pointer of the second derivative operator. class ( field ), allocatable :: du !< Dummy storage of the first derivative operator result. class ( field ), allocatable :: ddu !< Dummy storage of the second derivative operator result. allocate ( opr , source = inp ) allocate ( du , source = inp ) allocate ( ddu , source = inp ) du_opr => this % du ddu_opr => this % ddu du = du_opr % operate ( inp ) ddu = ddu_opr % operate ( inp ) opr = ( - this % a ) * du - this % b * ddu end function forcing subroutine init ( this , description , filename , error ) !< Initialize equation. class ( scalar_simple_equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % a = - 1.0_R_P this % b = - 0.1_R_P allocate ( spatial_operator_d1_FD_1D :: this % du ) allocate ( spatial_operator_d2_FD_1D :: this % ddu ) if ( present ( error )) error = 0 endif end subroutine init ! private methods subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( scalar_simple_equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then allocate ( spatial_operator_d1_FD_1D :: this % du ) allocate ( spatial_operator_d2_FD_1D :: this % ddu ) call json % get ( 'equation.a' , this % a , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: equation definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"a\" missing' stop endif call json % get ( 'equation.b' , this % b , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: equation definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"b\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif endsubroutine load_from_json end module scalar_simple_equation_m program scalar_simple !< Openpde test program: scalar_simple equation. use openpde use scalar_simple_equation_m class ( mesh ), allocatable :: mesh_ !< The mesh. class ( field ), allocatable :: u !< The field. class ( integrator ), allocatable :: integrator_ !< The integrator. class ( equation ), allocatable :: equation_ !< The equation. integer ( I_P ) :: itmin = 0 !< Fist time step. integer ( I_P ) :: itmax = 1000 !< Last time step. integer ( I_P ) :: it !< Time step counter. integer ( I_P ) :: er !< Error status. character ( 16 ) :: output_name !< Output file name. logical :: json_found !< Flag inquiring the presence of json input file. allocate ( mesh_FD_1D :: mesh_ ) allocate ( field_FD_1D :: u ) allocate ( scalar_simple_equation :: equation_ ) allocate ( integrator_euler_explicit :: integrator_ ) inquire ( file = 'scalar_simple.json' , exist = json_found ) if ( json_found ) then call mesh_ % init ( filename = 'scalar_simple.json' ) call u % init ( field_mesh = mesh_ ) call equation_ % init ( filename = 'scalar_simple.json' ) call integrator_ % init ( filename = 'scalar_simple.json' ) else call mesh_ % init call u % init ( field_mesh = mesh_ ) call equation_ % init call integrator_ % init endif output_name = \"out_XXXXXXXX.dat\" write ( output_name ( 5 : 12 ), \"(I8.8)\" ) itmin call u % output ( output_name , error = er ) do it = itmin , itmax er = integrator_ % integrate ( inp = u , equ = equation_ , t = it * integrator_ % dt ) if ( mod ( it , 10 ) == 0 ) then print * , 'it: ' , it write ( output_name ( 5 : 12 ), \"(I8.8)\" ) it call u % output ( output_name , error = er ) endif enddo call mesh_ % output ( error = er ) end program scalar_simple","tags":"","loc":"sourcefile/scalar_simple.f90.html","title":"scalar_simple.f90 – openpde"},{"text":"type, public, extends( field ) :: field_FD_2D type~~field_fd_2d~~InheritsGraph type~field_fd_2d field_FD_2D type~field field type~field->type~field_fd_2d type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:,:) :: val Field value. Type-Bound Procedures procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 2D field. procedure, public, pass(this) :: output Output field data. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. procedure, public, pass(this) :: set Set field. private subroutine set (this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. Source Code type , extends ( field ) :: field_FD_2D !< Concrete class of field for Finite Difference 2D methods. real ( R_P ), allocatable , dimension (:,:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_2D","tags":"","loc":"type/field_fd_2d.html","title":"field_FD_2D – openpde "},{"text":"type, public, abstract :: field type~~field~~InheritsGraph type~field field type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of field. Inherited By type~~field~~InheritedByGraph type~field field type~field_fd_1d field_FD_1D type~field->type~field_fd_1d type~field_fd_2d field_FD_2D type~field->type~field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure( abstract_associate_mesh ), public, deferred, pass(this) :: associate_mesh Associate mesh. subroutine abstract_associate_mesh (this, field_mesh, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field. procedure( abstract_init ), public, deferred, pass(this) :: init Initilize field. subroutine abstract_init (this, field_mesh, description, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field. procedure( abstract_output ), public, deferred, pass(this) :: output Output field data. subroutine abstract_output (this, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: add Add fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. procedure( abstract_assign ), private, deferred, pass(lhs) :: assign_field Assign fields. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: mul Multiply fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. procedure( abstract_field_op_real ), private, deferred, pass(lhs) :: mulreal Multiply field for real. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. procedure( abstract_real_op_field ), private, deferred, pass(rhs) :: realmul Multiply real for field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: sub Subtract fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. generic, public :: operator(+) => add Operator + overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. generic, public :: operator(-) => sub Operator - overloading. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. generic, public :: assignment(=) => assign_field Assignment overloading. subroutine abstract_assign (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. Description Free dynamic memory. Source Code type , abstract :: field !< Abstract class of field. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred public methods procedure ( abstract_associate_mesh ), pass ( this ), deferred :: associate_mesh !< Associate mesh. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize field. procedure ( abstract_output ), pass ( this ), deferred :: output !< Output field data. ! deferred private methods procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), pass ( lhs ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), pass ( lhs ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: sub !< Subtract fields. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype field","tags":"","loc":"type/field.html","title":"field – openpde "},{"text":"type, public, extends( field ) :: field_FD_1D type~~field_fd_1d~~InheritsGraph type~field_fd_1d field_FD_1D type~field field type~field->type~field_fd_1d type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. procedure, public, pass(this) :: output Output field data. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. procedure, public, pass(this) :: set Set field. private subroutine set (this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. Source Code type , extends ( field ) :: field_FD_1D !< Concrete class of field for Finite Difference 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_1D","tags":"","loc":"type/field_fd_1d.html","title":"field_FD_1D – openpde "},{"text":"type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D type~~spatial_operator_d2_fd_2d~~InheritsGraph type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_2D","tags":"","loc":"type/spatial_operator_d2_fd_2d.html","title":"spatial_operator_d2_FD_2D – openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_d2 type~~spatial_operator_d2~~InheritsGraph type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator of second derivative. Inherited By type~~spatial_operator_d2~~InheritedByGraph type~spatial_operator_d2 spatial_operator_d2 type~scalar_simple_equation scalar_simple_equation type~spatial_operator_d2->type~scalar_simple_equation ddu type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2->type~spatial_operator_d2_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_d2 !< Abstract class of spatial operator of second derivative. endtype spatial_operator_d2","tags":"","loc":"type/spatial_operator_d2.html","title":"spatial_operator_d2 – openpde "},{"text":"type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D type~~spatial_operator_d1_fd_2d~~InheritsGraph type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_2D","tags":"","loc":"type/spatial_operator_d1_fd_2d.html","title":"spatial_operator_d1_FD_2D – openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_d1 type~~spatial_operator_d1~~InheritsGraph type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator of first derivative. Inherited By type~~spatial_operator_d1~~InheritedByGraph type~spatial_operator_d1 spatial_operator_d1 type~scalar_simple_equation scalar_simple_equation type~spatial_operator_d1->type~scalar_simple_equation du type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1->type~spatial_operator_d1_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_d1 !< Abstract class of spatial operator of first derivative. endtype spatial_operator_d1","tags":"","loc":"type/spatial_operator_d1.html","title":"spatial_operator_d1 – openpde "},{"text":"type, public, abstract :: spatial_operator Abstract class of spatial operator. Inherited By type~~spatial_operator~~InheritedByGraph type~spatial_operator spatial_operator type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator->type~spatial_operator_d1 type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator->type~spatial_operator_d2 type~scalar_simple_equation scalar_simple_equation type~spatial_operator_d1->type~scalar_simple_equation du type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1->type~spatial_operator_d1_fd_1d type~spatial_operator_d2->type~scalar_simple_equation ddu type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2->type~spatial_operator_d2_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. function abstract_operate (this, inp, dir) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator function. Source Code type , abstract :: spatial_operator !< Abstract class of spatial operator. character ( len = :), allocatable :: description !< Operator description. contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype spatial_operator","tags":"","loc":"type/spatial_operator.html","title":"spatial_operator – openpde "},{"text":"type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D type~~spatial_operator_d1_fd_1d~~InheritsGraph type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~spatial_operator_d1_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_1D","tags":"","loc":"type/spatial_operator_d1_fd_1d.html","title":"spatial_operator_d1_FD_1D – openpde "},{"text":"type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D type~~spatial_operator_d2_fd_1d~~InheritsGraph type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~spatial_operator_d2_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Source Code type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_1D","tags":"","loc":"type/spatial_operator_d2_fd_1d.html","title":"spatial_operator_d2_FD_1D – openpde "},{"text":"type, public, extends( integrator ) :: integrator_euler_explicit type~~integrator_euler_explicit~~InheritsGraph type~integrator_euler_explicit integrator_euler_explicit type~integrator integrator type~integrator->type~integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of integrator, Euler explicit scheme. Type-Bound Procedures procedure, public, pass(this) :: init Initilize integrator. private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. private function integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the to equation by means of the Euler explicit scheme. generic, public :: load => load_from_json Load integrator definition from file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load integrator definition from JSON file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load integrator definition from JSON file. Source Code type , extends ( integrator ) :: integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_euler_explicit","tags":"","loc":"type/integrator_euler_explicit.html","title":"integrator_euler_explicit – openpde "},{"text":"type, public, abstract :: integrator Abstract class of integrator. Inherited By type~~integrator~~InheritedByGraph type~integrator integrator type~integrator_euler_explicit integrator_euler_explicit type~integrator->type~integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure( abstract_init ), public, deferred, pass(this) :: init Initilize integrator. subroutine abstract_init (this, description, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator. procedure( abstract_integrate ), public, deferred, pass(this) :: integrate Integrate the field accordingly to the equation. function abstract_integrate (this, equ, t, inp) result(error) Prototype Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly to the equation. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. Source Code type , abstract :: integrator !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator","tags":"","loc":"type/integrator.html","title":"integrator – openpde "},{"text":"type, public, abstract :: equation Abstract class of equation. The concrete types are implemented at application level (by the user) predefined examples might be provided as well. Inherited By type~~equation~~InheritedByGraph type~equation equation type~scalar_simple_equation scalar_simple_equation type~equation->type~scalar_simple_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. Type-Bound Procedures procedure( abstract_bc ), public, deferred, pass(this) :: bc Equation boundary conditions. subroutine abstract_bc (this, inp, t) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition. procedure( abstract_forcing ), public, deferred, pass(this) :: forcing Forcing equation. function abstract_forcing (this, inp, t) result(opr) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. procedure( abstract_init ), public, deferred, pass(this) :: init Initialize the equation. subroutine abstract_init (this, description, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. Source Code type , abstract :: equation !< Abstract class of equation. !< !< The concrete types are implemented at application level (by the user) predefined examples might be provided as well. character ( len = :), allocatable :: description !< Equation description. contains ! deferred public methods procedure ( abstract_bc ), pass ( this ), deferred :: bc !< Equation boundary conditions. procedure ( abstract_forcing ), pass ( this ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initialize the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype equation","tags":"","loc":"type/equation.html","title":"equation – openpde "},{"text":"type, public, extends( mesh ) :: mesh_FD_2D type~~mesh_fd_2d~~InheritsGraph type~mesh_fd_2d mesh_FD_2D type~mesh mesh type~mesh->type~mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: nx = 0 Number of X points. integer(kind=I_P), public :: ny = 0 Number of Y points. integer(kind=I_P), public :: ngx = 0 Number of X ghost points. integer(kind=I_P), public :: ngy = 0 Number of Y ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: hx = 0._R_P Cell X size. real(kind=R_P), public :: hy = 0._R_P Cell Y size. Type-Bound Procedures procedure, public, pass(this) :: init Initilize mesh. private pure subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. procedure, public, pass(this) :: set Set mesh. private pure subroutine set (this, description, nx, ny, ngx, ngy, s, hx, hy, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code type , extends ( mesh ) :: mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. integer ( I_P ) :: nx = 0 !< Number of X points. integer ( I_P ) :: ny = 0 !< Number of Y points. integer ( I_P ) :: ngx = 0 !< Number of X ghost points. integer ( I_P ) :: ngy = 0 !< Number of Y ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: hx = 0._R_P !< Cell X size. real ( R_P ) :: hy = 0._R_P !< Cell Y size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods procedure , pass ( this ) :: set !< Set mesh. endtype mesh_FD_2D","tags":"","loc":"type/mesh_fd_2d.html","title":"mesh_FD_2D – openpde "},{"text":"type, public, abstract :: mesh Abstract class of mesh. Inherited By type~~mesh~~InheritedByGraph type~mesh mesh type~field field type~mesh->type~field m type~mesh_fd_2d mesh_FD_2D type~mesh->type~mesh_fd_2d type~mesh_fd_1d mesh_FD_1D type~mesh->type~mesh_fd_1d type~field_fd_1d field_FD_1D type~field->type~field_fd_1d type~field_fd_2d field_FD_2D type~field->type~field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure( abstract_meshinit ), public, deferred, pass(this) :: init Initilize mesh. subroutine abstract_meshinit (this, description, filename, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. procedure( abstract_meshoutput ), public, deferred, pass(this) :: output Output mesh. subroutine abstract_meshoutput (this, error) Prototype Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code type , abstract :: mesh !< Abstract class of mesh. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred public methods procedure ( abstract_meshinit ), pass ( this ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , pass ( this ), deferred :: output !< Output mesh. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype mesh","tags":"","loc":"type/mesh.html","title":"mesh – openpde "},{"text":"type, public, extends( mesh ) :: mesh_FD_1D type~~mesh_fd_1d~~InheritsGraph type~mesh_fd_1d mesh_FD_1D type~mesh mesh type~mesh->type~mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n = 0 Number of points. integer(kind=I_P), public :: ng = 0 Number of ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: init Initilize mesh. private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. generic, public :: load => load_from_json Load mesh definition from file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. procedure, public, pass(this) :: set Set mesh. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. Source Code type , extends ( mesh ) :: mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. integer ( I_P ) :: n = 0 !< Number of points. integer ( I_P ) :: ng = 0 !< Number of ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! private methods procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FD_1D","tags":"","loc":"type/mesh_fd_1d.html","title":"mesh_FD_1D – openpde "},{"text":"type, public, extends( equation ) :: scalar_simple_equation type~~scalar_simple_equation~~InheritsGraph type~scalar_simple_equation scalar_simple_equation type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~scalar_simple_equation du type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~scalar_simple_equation ddu type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 type~spatial_operator->type~spatial_operator_d2 type~equation equation type~equation->type~scalar_simple_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. (Fake) scalar_simple equations. Note The reason the du and ddu are pointers is just to make them a pointee when pointed\n inside forcing function. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: a = 0._R_P a equation coefficient. real(kind=R_P), public :: b = 0._R_P b equation coefficient. class( spatial_operator_d1 ), public, pointer :: du First derivative. class( spatial_operator_d2 ), public, pointer :: ddu Second derivative. Type-Bound Procedures procedure, public, pass(this) :: bc Equation boundary conditions. private subroutine bc (this, inp, t) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition. procedure, public, pass(this) :: forcing Forcing equation. private function forcing (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed after forcing the residual function. Description Return the field after forcing the equation. procedure, public, pass(this) :: init Initialize equation. private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation. generic, public :: load => load_from_json Load equation definition from file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. procedure, private, pass(this) :: load_from_json Load equation definition from jSON file. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. Source Code type , extends ( equation ) :: scalar_simple_equation !< (Fake) scalar_simple equations. !< !< @note The reason the `du` and `ddu` are pointers is just to make them a pointee when pointed !< inside [[equation:forcing]] function. real ( R_P ) :: a = 0._R_P !< `a` equation coefficient. real ( R_P ) :: b = 0._R_P !< `b` equation coefficient. class ( spatial_operator_d1 ), pointer :: du !< First derivative. class ( spatial_operator_d2 ), pointer :: ddu !< Second derivative. contains ! deferred public methods procedure , pass ( this ) :: bc !< Equation boundary conditions. procedure , pass ( this ) :: forcing !< Forcing equation. procedure , pass ( this ) :: init !< Initialize equation. ! public methods generic :: load => load_from_json !< Load equation definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load equation definition from jSON file. endtype scalar_simple_equation","tags":"","loc":"type/scalar_simple_equation.html","title":"scalar_simple_equation – openpde "},{"text":"abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh(this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field.","tags":"","loc":"interface/abstract_associate_mesh.html","title":"abstract_associate_mesh – openpde"},{"text":"abstract interface Initialize the field. private subroutine abstract_init(this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field.","tags":"","loc":"interface/abstract_init.html","title":"abstract_init – openpde"},{"text":"abstract interface Output the field. private subroutine abstract_output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field.","tags":"","loc":"interface/abstract_output.html","title":"abstract_output – openpde"},{"text":"abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field.","tags":"","loc":"interface/abstract_simmetric_operator.html","title":"abstract_simmetric_operator – openpde"},{"text":"abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real.","tags":"","loc":"interface/abstract_field_op_real.html","title":"abstract_field_op_real – openpde"},{"text":"abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field.","tags":"","loc":"interface/abstract_real_op_field.html","title":"abstract_real_op_field – openpde"},{"text":"abstract interface Assignment overloading. private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading.","tags":"","loc":"interface/abstract_assign.html","title":"abstract_assign – openpde"},{"text":"abstract interface Operator operation. private function abstract_operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator function.","tags":"","loc":"interface/abstract_operate.html","title":"abstract_operate – openpde"},{"text":"abstract interface Initialize integrator. private subroutine abstract_init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator.","tags":"","loc":"interface/abstract_init~2.html","title":"abstract_init – openpde"},{"text":"abstract interface Integrate the field accordingly the equation. private function abstract_integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly to the equation.","tags":"","loc":"interface/abstract_integrate.html","title":"abstract_integrate – openpde"},{"text":"abstract interface Equation boundary conditions. private subroutine abstract_bc(this, inp, t) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition.","tags":"","loc":"interface/abstract_bc.html","title":"abstract_bc – openpde"},{"text":"abstract interface Initialize equation. private subroutine abstract_init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation.","tags":"","loc":"interface/abstract_init~3.html","title":"abstract_init – openpde"},{"text":"abstract interface Return the field after forcing the equation. private function abstract_forcing(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation.","tags":"","loc":"interface/abstract_forcing.html","title":"abstract_forcing – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_meshinit(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh.","tags":"","loc":"interface/abstract_meshinit.html","title":"abstract_meshinit – openpde"},{"text":"abstract interface Output mesh. private subroutine abstract_meshoutput(this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh.","tags":"","loc":"interface/abstract_meshoutput.html","title":"abstract_meshoutput – openpde"},{"text":"private function add(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. Calls proc~~add~~CallsGraph proc~add add proc~associate_field_fd_2d associate_field_FD_2D proc~add->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_2D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. Calls proc~~mul~~CallsGraph proc~mul mul proc~associate_field_fd_2d associate_field_FD_2D proc~mul->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_2D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. Calls proc~~mulreal~~CallsGraph proc~mulreal mulreal proc~associate_field_fd_2d associate_field_FD_2D proc~mulreal->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. Calls proc~~realmul~~CallsGraph proc~realmul realmul proc~associate_field_fd_2d associate_field_FD_2D proc~realmul->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_2D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Calls proc~~sub~~CallsGraph proc~sub sub proc~associate_field_fd_2d associate_field_FD_2D proc~sub->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_2D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'add_field_FD_2D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub.html","title":"sub – openpde"},{"text":"public subroutine associate_field_FD_2D(field_input, calling_procedure, field_pointer) Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( field_FD_2D ), intent(inout), pointer :: field_pointer Finite Difference 2D field pointer. Description Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. Called By proc~~associate_field_fd_2d~~CalledByGraph proc~associate_field_fd_2d associate_field_FD_2D proc~sub sub proc~sub->proc~associate_field_fd_2d proc~operate~2 operate proc~operate~2->proc~associate_field_fd_2d proc~realmul realmul proc~realmul->proc~associate_field_fd_2d proc~mul mul proc~mul->proc~associate_field_fd_2d proc~assign_field assign_field proc~assign_field->proc~associate_field_fd_2d proc~operate operate proc~operate->proc~associate_field_fd_2d proc~mulreal mulreal proc~mulreal->proc~associate_field_fd_2d proc~add add proc~add->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine associate_field_FD_2D ( field_input , calling_procedure , field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( field_FD_2D ), intent ( inout ), pointer :: field_pointer !< Finite Difference 2D field pointer. select type ( field_input ) type is ( field_FD_2D ) field_pointer => field_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_field_FD_2D","tags":"","loc":"proc/associate_field_fd_2d.html","title":"associate_field_FD_2D – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. Calls proc~~associate_mesh~~CallsGraph proc~associate_mesh associate_mesh proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~associate_mesh->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(mesh_FD_2D), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. call associate_mesh_FD_2D ( mesh_input = field_mesh , & calling_procedure = 'associate_mesh_field_FD_2D(field_mesh)' , & mesh_pointer = mesh_cur ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) allocate ( this % val ( 1 - mesh_cur % ngx : mesh_cur % nx + mesh_cur % ngx , 1 - mesh_cur % ngy : mesh_cur % ny + mesh_cur % ngy )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 2D field. Calls proc~~init~~CallsGraph proc~init init proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~init->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(mesh_FD_2D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 2D field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description call associate_mesh_FD_2D ( mesh_input = field_mesh , & calling_procedure = 'init_field_FD_2D(field_mesh)' , & mesh_pointer = mesh_cur ) do j = 1 - mesh_cur % ngy , mesh_cur % ny + mesh_cur % ngy do i = 1 - mesh_cur % ngx , mesh_cur % nx + mesh_cur % ngx this % val ( i , j ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % nx ) * sin ( j * 2._R_P * acos ( - 1._R_P ) / mesh_cur % ny ) enddo enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: imin Lower extent. integer(kind=I_P), public :: imax Upper extent. integer(kind=I_P), public :: jmin Lower extent. integer(kind=I_P), public :: jmax Upper extent. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_2D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: jmin !< Lower extent. integer ( I_P ) :: jmax !< Upper extent. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) jmin = lbound ( this % val , dim = 2 ) jmax = ubound ( this % val , dim = 2 ) open ( unit = 11 , file = filename ) do j = jmin , jmax do i = imin , imax write ( 11 , * ) this % val ( i , j ) enddo enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output.html","title":"output – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. Calls proc~~assign_field~~CallsGraph proc~assign_field assign_field proc~associate_field_fd_2d associate_field_FD_2D proc~assign_field->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_2D ), public, pointer :: rhs_cur Dummy pointer for rhs. Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_2D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. call associate_field_FD_2D ( field_input = rhs , & calling_procedure = 'add_field_FD_2D(rhs)' , & field_pointer = rhs_cur ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field.html","title":"assign_field – openpde"},{"text":"private subroutine set(this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. Source Code subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :, 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :, 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_2D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. Description Free dynamic memory. ToDo Discuss about the free of mesh pointer. Source Code elemental subroutine free ( this ) !< Free dynamic memory. !< !< @todo Discuss about the *free* of mesh pointer. class ( field ), intent ( inout ) :: this !< The field. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) then !   call this%m%free !   deallocate(this%m) ! endif ! this%m => null() end subroutine free","tags":"","loc":"proc/free~2.html","title":"free – openpde"},{"text":"private function add(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. Calls proc~~add~2~~CallsGraph proc~add~2 add proc~associate_field_fd_1d associate_field_FD_1D proc~add~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_1D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add~2.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. Calls proc~~mul~2~~CallsGraph proc~mul~2 mul proc~associate_field_fd_1d associate_field_FD_1D proc~mul~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_1D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul~2.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. Calls proc~~mulreal~2~~CallsGraph proc~mulreal~2 mulreal proc~associate_field_fd_1d associate_field_FD_1D proc~mulreal~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal~2.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. Calls proc~~realmul~2~~CallsGraph proc~realmul~2 realmul proc~associate_field_fd_1d associate_field_FD_1D proc~realmul~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul~2.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Calls proc~~sub~2~~CallsGraph proc~sub~2 sub proc~associate_field_fd_1d associate_field_FD_1D proc~sub~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: rhs_cur Dummy pointer for rhs. class( field_FD_1D ), public, pointer :: opr_cur Dummy pointer for operator result. Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'add_field_FD_1D(opr)' , & field_pointer = opr_cur ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub~2.html","title":"sub – openpde"},{"text":"public subroutine associate_field_FD_1D(field_input, calling_procedure, field_pointer) Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( field_FD_1D ), intent(inout), pointer :: field_pointer Finite Difference 1D field pointer. Description Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Called By proc~~associate_field_fd_1d~~CalledByGraph proc~associate_field_fd_1d associate_field_FD_1D proc~operate~4 operate proc~operate~4->proc~associate_field_fd_1d proc~sub~2 sub proc~sub~2->proc~associate_field_fd_1d proc~add~2 add proc~add~2->proc~associate_field_fd_1d proc~realmul~2 realmul proc~realmul~2->proc~associate_field_fd_1d proc~operate~3 operate proc~operate~3->proc~associate_field_fd_1d proc~mul~2 mul proc~mul~2->proc~associate_field_fd_1d proc~mulreal~2 mulreal proc~mulreal~2->proc~associate_field_fd_1d proc~assign_field~2 assign_field proc~assign_field~2->proc~associate_field_fd_1d proc~bc bc proc~bc->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine associate_field_FD_1D ( field_input , calling_procedure , field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( field_FD_1D ), intent ( inout ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) ' error: wrong field class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_field_FD_1D","tags":"","loc":"proc/associate_field_fd_1d.html","title":"associate_field_FD_1D – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. Calls proc~~associate_mesh~2~~CallsGraph proc~associate_mesh~2 associate_mesh proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~associate_mesh~2->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(mesh_FD_1D), public, pointer :: mesh_cur Dummy pointer for mesh. Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. call associate_mesh_FD_1D ( mesh_input = field_mesh , & calling_procedure = 'associate_mesh_field_FD_1D(field_mesh)' , & mesh_pointer = mesh_cur ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - mesh_cur % ng : mesh_cur % n + mesh_cur % ng )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh~2.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. Calls proc~~init~2~~CallsGraph proc~init~2 init proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~init~2->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(mesh_FD_1D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: i Counter. Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description call associate_mesh_FD_1D ( mesh_input = field_mesh , & calling_procedure = 'init_field_FD_1D(field_mesh)' , & mesh_pointer = mesh_cur ) do i = 1 - mesh_cur % ng , mesh_cur % n + mesh_cur % ng this % val ( i ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % n ) enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~2.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: imin Lower extent. integer(kind=I_P), public :: imax Upper extent. integer(kind=I_P), public :: i Counter. Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~2.html","title":"output – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. Calls proc~~assign_field~2~~CallsGraph proc~assign_field~2 assign_field proc~associate_field_fd_1d associate_field_FD_1D proc~assign_field~2->proc~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class( field_FD_1D ), public, pointer :: rhs_cur Dummy pointer for rhs. Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. call associate_field_FD_1D ( field_input = rhs , & calling_procedure = 'add_field_FD_1D(rhs)' , & field_pointer = rhs_cur ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field~2.html","title":"assign_field – openpde"},{"text":"private subroutine set(this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. Source Code subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~2.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free~3.html","title":"free – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Calls proc~~operate~~CallsGraph proc~operate operate proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate->proc~associate_mesh_fd_2d proc~associate_field_fd_2d associate_field_FD_2D proc~operate->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(field_FD_2D), public, pointer :: inp_cur Dummy pointer for input field. class(field_FD_2D), public, pointer :: opr_cur Dummy pointer for operator result. class(mesh_FD_2D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: dir_ Direction of operation. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_2D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_2D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_2D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_2D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_2D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - 2._R_P * inp_cur % val ( i , :) + inp_cur % val ( i - 1 , :)) / ( mesh_cur % hx ** 2 ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - 2._R_P * inp_cur % val (:, j ) + inp_cur % val (:, j - 1 )) / ( mesh_cur % hy ** 2 ) enddo endif end function operate","tags":"","loc":"proc/operate.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Calls proc~~operate~2~~CallsGraph proc~operate~2 operate proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~2->proc~associate_mesh_fd_2d proc~associate_field_fd_2d associate_field_FD_2D proc~operate~2->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(field_FD_2D), public, pointer :: inp_cur Dummy pointer for input field. class(field_FD_2D), public, pointer :: opr_cur Dummy pointer for operator result. class(mesh_FD_2D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: dir_ Direction of operation. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) call associate_field_FD_2D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_2D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_2D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_2D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_2D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_2D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - inp_cur % val ( i , :)) / ( mesh_cur % hx ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - inp_cur % val (:, j )) / ( mesh_cur % hy ) enddo endif end function operate","tags":"","loc":"proc/operate~2.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Calls proc~~operate~3~~CallsGraph proc~operate~3 operate proc~associate_field_fd_1d associate_field_FD_1D proc~operate~3->proc~associate_field_fd_1d proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~3->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(field_FD_1D), public, pointer :: inp_cur Dummy pointer for input field. class(field_FD_1D), public, pointer :: opr_cur Dummy pointer for operator result. class(mesh_FD_1D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: i Counter. Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_1D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_1D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_1D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_1D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( mesh_cur % h ) enddo end function operate","tags":"","loc":"proc/operate~3.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation. Calls proc~~operate~4~~CallsGraph proc~operate~4 operate proc~associate_field_fd_1d associate_field_FD_1D proc~operate~4->proc~associate_field_fd_1d proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~4->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(field_FD_1D), public, pointer :: inp_cur Dummy pointer for input field. class(field_FD_1D), public, pointer :: opr_cur Dummy pointer for operator result. class(mesh_FD_1D), public, pointer :: mesh_cur Dummy pointer for mesh. integer(kind=I_P), public :: i Counter. Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) call associate_field_FD_1D ( field_input = opr , & calling_procedure = 'operate_spatial_operator_FD_1D(opr)' , & field_pointer = opr_cur ) call associate_field_FD_1D ( field_input = inp , & calling_procedure = 'operate_spatial_operator_FD_1D(inp)' , & field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , & calling_procedure = 'operate_spatial_operator_FD_1D(inp%m)' , & mesh_pointer = mesh_cur ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - 2._R_P * inp_cur % val ( i ) + inp_cur % val ( i - 1 )) / ( mesh_cur % h ** 2 ) enddo end function operate","tags":"","loc":"proc/operate~4.html","title":"operate – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the to equation by means of the Euler explicit scheme. Variables Type Visibility Attributes Name Initial class( field ), public, allocatable :: for Temporary Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. class ( integrator_euler_explicit ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary call equ % bc ( inp = inp , t = t ) allocate ( for , source = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate","tags":"","loc":"proc/integrate.html","title":"integrate – openpde"},{"text":"private subroutine init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator. Source Code subroutine init ( this , description , filename , error ) !< Initialize integrator. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~3.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load integrator definition from JSON file. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: integrator_type Integrator type. type(json_file), public :: json JSON file handler. logical, public :: found Flag inquiring the result json parsing. Source Code subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json.html","title":"load_from_json – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~4.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~5.html","title":"free – openpde"},{"text":"public subroutine associate_mesh_FD_2D(mesh_input, calling_procedure, mesh_pointer) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( mesh_FD_2D ), intent(inout), pointer :: mesh_pointer Finite Difference 1D mesh pointer. Description Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. Called By proc~~associate_mesh_fd_2d~~CalledByGraph proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~associate_mesh associate_mesh proc~associate_mesh->proc~associate_mesh_fd_2d proc~operate~2 operate proc~operate~2->proc~associate_mesh_fd_2d proc~init init proc~init->proc~associate_mesh_fd_2d proc~operate operate proc~operate->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine associate_mesh_FD_2D ( mesh_input , calling_procedure , mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( mesh_FD_2D ), intent ( inout ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_2D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_mesh_FD_2D","tags":"","loc":"proc/associate_mesh_fd_2d.html","title":"associate_mesh_FD_2D – openpde"},{"text":"private pure subroutine init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. Source Code pure subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % nx = 10 this % ny = 8 this % ngx = 2 this % ngy = 2 this % s = 1 this % hx = 0.05_R8P this % hy = 0.08_R8P if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~4.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_2D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"nx: \" , this % nx print * , \"ny: \" , this % ny print * , \"ngx: \" , this % ngx print * , \"ngy: \" , this % ngy print * , \"s: \" , this % s print * , \"hx: \" , this % hx print * , \"hy: \" , this % hy if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~3.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, nx, ny, ngx, ngy, s, hx, hy, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code pure subroutine set ( this , description , nx , ny , ngx , ngy , s , hx , hy , error ) !< Set mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nx !< Number of X points. integer ( I_P ), intent ( in ), optional :: ny !< Number of Y points. integer ( I_P ), intent ( in ), optional :: ngx !< Number of X ghost points. integer ( I_P ), intent ( in ), optional :: ngy !< Number of Y ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: hx !< Cell X size. real ( R_P ), intent ( in ), optional :: hy !< Cell Y size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( nx )) this % nx = nx if ( present ( ny )) this % ny = ny if ( present ( ngx )) this % ngx = ngx if ( present ( ngy )) this % ngy = ngy if ( present ( s )) this % s = s if ( present ( hx )) this % hx = hx if ( present ( hy )) this % hy = hy if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~3.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory. Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~6.html","title":"free – openpde"},{"text":"public subroutine associate_mesh_FD_1D(mesh_input, calling_procedure, mesh_pointer) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( mesh_FD_1D ), intent(inout), pointer :: mesh_pointer Finite Difference 1D mesh pointer. Description Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Called By proc~~associate_mesh_fd_1d~~CalledByGraph proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~3 operate proc~operate~3->proc~associate_mesh_fd_1d proc~bc bc proc~bc->proc~associate_mesh_fd_1d proc~operate~4 operate proc~operate~4->proc~associate_mesh_fd_1d proc~associate_mesh~2 associate_mesh proc~associate_mesh~2->proc~associate_mesh_fd_1d proc~init~2 init proc~init~2->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine associate_mesh_FD_1D ( mesh_input , calling_procedure , mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ) :: calling_procedure !< Name of the calling procedure. class ( mesh_FD_1D ), intent ( inout ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) ' error: wrong mesh class' write ( stderr , '(A)' ) ' Calling procedure \"' // calling_procedure // '\"' stop end select end subroutine associate_mesh_FD_1D","tags":"","loc":"proc/associate_mesh_fd_1d.html","title":"associate_mesh_FD_1D – openpde"},{"text":"private subroutine init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. Source Code subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % n = 50 this % ng = 2 this % s = 1 this % h = 0.05_R8P if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~5.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~4.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. Source Code pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~4.html","title":"set – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mesh_type Mesh type. type(json_file), public :: json JSON file handler. logical, public :: found Flag inquiring the result json parsing. Source Code subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then call json % get ( 'mesh.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif call json % get ( 'mesh.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"ng\" missing' stop endif call json % get ( 'mesh.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"h\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~2.html","title":"load_from_json – openpde"},{"text":"private function forcing(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed after forcing the residual function. Description Return the field after forcing the equation. Variables Type Visibility Attributes Name Initial class( spatial_operator_d1 ), public, pointer :: du_opr Dummy pointer of the first derivative operator. class( spatial_operator_d2 ), public, pointer :: ddu_opr Dummy pointer of the second derivative operator. class( field ), public, allocatable :: du Dummy storage of the first derivative operator result. class( field ), public, allocatable :: ddu Dummy storage of the second derivative operator result. Source Code function forcing ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. class ( scalar_simple_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed after forcing the residual function. class ( spatial_operator_d1 ), pointer :: du_opr !< Dummy pointer of the first derivative operator. class ( spatial_operator_d2 ), pointer :: ddu_opr !< Dummy pointer of the second derivative operator. class ( field ), allocatable :: du !< Dummy storage of the first derivative operator result. class ( field ), allocatable :: ddu !< Dummy storage of the second derivative operator result. allocate ( opr , source = inp ) allocate ( du , source = inp ) allocate ( ddu , source = inp ) du_opr => this % du ddu_opr => this % ddu du = du_opr % operate ( inp ) ddu = ddu_opr % operate ( inp ) opr = ( - this % a ) * du - this % b * ddu end function forcing","tags":"","loc":"proc/forcing.html","title":"forcing – openpde"},{"text":"private subroutine bc(this, inp, t) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition. Calls proc~~bc~~CallsGraph proc~bc bc proc~associate_field_fd_1d associate_field_FD_1D proc~bc->proc~associate_field_fd_1d proc~associate_mesh_fd_1d associate_mesh_FD_1D proc~bc->proc~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial class(field_FD_1D), public, pointer :: inp_cur Pointer to input field. class(mesh_FD_1D), public, pointer :: mesh_cur Pointer to input mehs. integer(kind=I_P), public :: i Counter. Source Code subroutine bc ( this , inp , t ) !< Equation boundary conditions imposition. class ( scalar_simple_equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Field. real ( R_P ), intent ( in ) :: t !< Time. class ( field_FD_1D ), pointer :: inp_cur !< Pointer to input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Pointer to input mehs. integer ( I_P ) :: i !< Counter. call associate_field_FD_1D ( field_input = inp , calling_procedure = 'bc(inp)' , field_pointer = inp_cur ) call associate_mesh_FD_1D ( mesh_input = inp % m , calling_procedure = 'bc(inp%m)' , mesh_pointer = mesh_cur ) do i = 1 - mesh_cur % ng , 0 inp_cur % val ( i ) = inp_cur % val ( i + mesh_cur % n ) enddo do i = mesh_cur % n + 1 , mesh_cur % n + mesh_cur % ng inp_cur % val ( i ) = inp_cur % val ( i - mesh_cur % n ) enddo end subroutine bc","tags":"","loc":"proc/bc.html","title":"bc – openpde"},{"text":"private subroutine init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation. Source Code subroutine init ( this , description , filename , error ) !< Initialize equation. class ( scalar_simple_equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % a = - 1.0_R_P this % b = - 0.1_R_P allocate ( spatial_operator_d1_FD_1D :: this % du ) allocate ( spatial_operator_d2_FD_1D :: this % ddu ) if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~6.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: mesh_type Mesh type. type(json_file), public :: json JSON file handler. logical, public :: found Flag inquiring the result json parsing. Source Code subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( scalar_simple_equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then allocate ( spatial_operator_d1_FD_1D :: this % du ) allocate ( spatial_operator_d2_FD_1D :: this % ddu ) call json % get ( 'equation.a' , this % a , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: equation definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"a\" missing' stop endif call json % get ( 'equation.b' , this % b , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: equation definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"b\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~3.html","title":"load_from_json – openpde"},{"text":"Definition of reals and integer kind parameters of openpde library. Used By module~~openpde_kinds~~UsedByGraph module~openpde_kinds openpde_kinds module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_kinds->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_kinds->module~openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde openpde module~openpde_kinds->module~openpde module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_mesh_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_kindsUsedByGraph = svgPanZoom('#moduleopenpde_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/openpde_kinds.html","title":"openpde_kinds – openpde"},{"text":"Uses: openpde_equation_abstract openpde_field_abstract openpde_integrator_abstract openpde_mesh_abstract openpde_spatial_operator_abstract openpde_spatial_operator_d1_abstract openpde_spatial_operator_d2_abstract openpde_field_FD_1D openpde_field_FD_2D openpde_integrator_euler_explicit openpde_mesh_FD_1D openpde_mesh_FD_2D openpde_spatial_operator_d1_FD_1D openpde_spatial_operator_d1_FD_2D openpde_spatial_operator_d2_FD_1D openpde_spatial_operator_d2_FD_2D openpde_kinds module~~openpde~~UsesGraph module~openpde openpde module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_mesh_abstract->module~openpde module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_spatial_operator_d2_fd_2d->module~openpde vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d vtk_fortran->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_integrator_euler_explicit iso_fortran_env->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_integrator_euler_explicit json_module->module~openpde_mesh_fd_1d var panmoduleopenpdeUsesGraph = svgPanZoom('#moduleopenpdeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Open Fortran Library for PDE solving. Used By module~~openpde~~UsedByGraph module~openpde openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/openpde.html","title":"openpde – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_mesh_abstract openpde_kinds openpde_mesh_FD_2D module~~openpde_field_fd_2d~~UsesGraph module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_2d iso_fortran_env->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_field_abstract->module~openpde_field_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 2D methods. Used By module~~openpde_field_fd_2d~~UsedByGraph module~openpde_field_fd_2d openpde_field_FD_2D module~openpde openpde module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_field_fd_2dUsedByGraph = svgPanZoom('#moduleopenpde_field_fd_2dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( field ) :: field_FD_2D Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:,:) :: val Field value. Type-Bound Procedures procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field data. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, public, pass(this) :: set Set field. Description Concrete class of field for Finite Difference 2D methods. Functions private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Subroutines public subroutine associate_field_FD_2D (field_input, calling_procedure, field_pointer) Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( field_FD_2D ), intent(inout), pointer :: field_pointer Finite Difference 2D field pointer. Description Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. private subroutine associate_mesh (this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. private subroutine init (this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 2D field. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. private subroutine set (this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. Description Free dynamic memory.","tags":"","loc":"module/openpde_field_fd_2d.html","title":"openpde_field_FD_2D – openpde"},{"text":"Uses: openpde_mesh_abstract openpde_kinds module~~openpde_field_abstract~~UsesGraph module~openpde_field_abstract openpde_field_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of field. Used By module~~openpde_field_abstract~~UsedByGraph module~openpde_field_abstract openpde_field_abstract module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde openpde module~openpde_field_abstract->module~openpde module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d2_fd_1d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_equation_abstract->module~openpde module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_euler_explicit->module~openpde module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_fd_2d->module~openpde module~scalar_simple_equation_m->program~scalar_simple module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d var panmoduleopenpde_field_abstractUsedByGraph = svgPanZoom('#moduleopenpde_field_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh (this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field. abstract interface Initialize the field. private subroutine abstract_init (this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field. abstract interface Output the field. private subroutine abstract_output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field. abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field. abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real. abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field. abstract interface Assignment overloading. private subroutine abstract_assign (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading. Derived Types type, public, abstract :: field Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure(abstract_associate_mesh), public, pass(this) :: associate_mesh Associate mesh. procedure(abstract_init), public, pass(this) :: init Initilize field. procedure(abstract_output), public, pass(this) :: output Output field data. procedure(abstract_simmetric_operator), private, pass(lhs) :: add Add fields. procedure(abstract_assign), private, pass(lhs) :: assign_field Assign fields. procedure(abstract_simmetric_operator), private, pass(lhs) :: mul Multiply fields. procedure(abstract_field_op_real), private, pass(lhs) :: mulreal Multiply field for real. procedure(abstract_real_op_field), private, pass(rhs) :: realmul Multiply real for field. procedure(abstract_simmetric_operator), private, pass(lhs) :: sub Subtract fields. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. Description Abstract class of field. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. Description Free dynamic memory.","tags":"","loc":"module/openpde_field_abstract.html","title":"openpde_field_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_mesh_abstract openpde_kinds openpde_mesh_FD_1D module~~openpde_field_fd_1d~~UsesGraph module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_field_abstract->module~openpde_field_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of field for Finite Difference 1D methods. Used By module~~openpde_field_fd_1d~~UsedByGraph module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde openpde module~openpde_field_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_fd_1d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d1_fd_1d->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_field_fd_1dUsedByGraph = svgPanZoom('#moduleopenpde_field_fd_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( field ) :: field_FD_1D Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field data. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, public, pass(this) :: set Set field. Description Concrete class of field for Finite Difference 1D methods. Functions private function add (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Add fields. private function mul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply fields. private function mulreal (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply field for real. private function realmul (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Multiply real for field. private function sub (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Description Subtract fields. Subroutines public subroutine associate_field_FD_1D (field_input, calling_procedure, field_pointer) Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( field_FD_1D ), intent(inout), pointer :: field_pointer Finite Difference 1D field pointer. Description Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. private subroutine associate_mesh (this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate field to a mesh. private subroutine init (this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize finite difference 1D field. private subroutine output (this, filename, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output field data. private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assign fields. private subroutine set (this, field_mesh, description, val, error) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Description Set field. private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. Description Free dynamic memory.","tags":"","loc":"module/openpde_field_fd_1d.html","title":"openpde_field_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d2_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D module~~openpde_spatial_operator_d2_fd_2d~~UsesGraph module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_field_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract var panmoduleopenpde_spatial_operator_d2_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Used By module~~openpde_spatial_operator_d2_fd_2d~~UsedByGraph module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Functions private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"module/openpde_spatial_operator_d2_fd_2d.html","title":"openpde_spatial_operator_d2_FD_2D – openpde"},{"text":"Uses: openpde_spatial_operator_abstract module~~openpde_spatial_operator_d2_abstract~~UsesGraph module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_spatial_operator_d2_abstractUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator of second derivative. Used By module~~openpde_spatial_operator_d2_abstract~~UsedByGraph module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde openpde module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_spatial_operator_d2_abstractUsedByGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_d2 Description Abstract class of spatial operator of second derivative.","tags":"","loc":"module/openpde_spatial_operator_d2_abstract.html","title":"openpde_spatial_operator_d2_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d1_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D module~~openpde_spatial_operator_d1_fd_2d~~UsesGraph module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_field_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract var panmoduleopenpde_spatial_operator_d1_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Used By module~~openpde_spatial_operator_d1_fd_2d~~UsedByGraph module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Functions private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"module/openpde_spatial_operator_d1_fd_2d.html","title":"openpde_spatial_operator_d1_FD_2D – openpde"},{"text":"Uses: openpde_spatial_operator_abstract module~~openpde_spatial_operator_d1_abstract~~UsesGraph module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_spatial_operator_d1_abstractUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator of first derivative. Used By module~~openpde_spatial_operator_d1_abstract~~UsedByGraph module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde openpde module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_spatial_operator_d1_abstractUsedByGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_d1 Description Abstract class of spatial operator of first derivative.","tags":"","loc":"module/openpde_spatial_operator_d1_abstract.html","title":"openpde_spatial_operator_d1_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_kinds module~~openpde_spatial_operator_abstract~~UsesGraph module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of spatial operator. Used By module~~openpde_spatial_operator_abstract~~UsedByGraph module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~scalar_simple_equation_m->program~scalar_simple module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde var panmoduleopenpde_spatial_operator_abstractUsedByGraph = svgPanZoom('#moduleopenpde_spatial_operator_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Operator operation. private function abstract_operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator function. Derived Types type, public, abstract :: spatial_operator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function. Description Abstract class of spatial operator.","tags":"","loc":"module/openpde_spatial_operator_abstract.html","title":"openpde_spatial_operator_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d1_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D module~~openpde_spatial_operator_d1_fd_1d~~UsesGraph module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_1d iso_fortran_env->module~openpde_field_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d var panmoduleopenpde_spatial_operator_d1_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Used By module~~openpde_spatial_operator_d1_fd_1d~~UsedByGraph module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Functions private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"module/openpde_spatial_operator_d1_fd_1d.html","title":"openpde_spatial_operator_d1_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d2_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D module~~openpde_spatial_operator_d2_fd_1d~~UsesGraph module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract var panmoduleopenpde_spatial_operator_d2_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Used By module~~openpde_spatial_operator_d2_fd_1d~~UsedByGraph module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D Type-Bound Procedures procedure, public :: operate Operator operation. Description Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Functions private function operate (this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator operation.","tags":"","loc":"module/openpde_spatial_operator_d2_fd_1d.html","title":"openpde_spatial_operator_d2_FD_1D – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_equation_abstract openpde_field_abstract openpde_integrator_abstract openpde_kinds module~~openpde_integrator_euler_explicit~~UsesGraph module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit json_module json_module json_module->module~openpde_integrator_euler_explicit module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_integrator_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_euler_explicit module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_integrator_euler_explicitUsesGraph = svgPanZoom('#moduleopenpde_integrator_euler_explicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of integrator, Euler explicit scheme. Used By module~~openpde_integrator_euler_explicit~~UsedByGraph module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde openpde module~openpde_integrator_euler_explicit->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( integrator ) :: integrator_euler_explicit Type-Bound Procedures procedure, public, pass(this) :: init Initilize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. generic, public :: load => load_from_json Load integrator definition from file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. Description Concrete class of integrator, Euler explicit scheme. Functions private function integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly the to equation by means of the Euler explicit scheme. Subroutines private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load integrator definition from JSON file.","tags":"","loc":"module/openpde_integrator_euler_explicit.html","title":"openpde_integrator_euler_explicit – openpde"},{"text":"Uses: openpde_field_abstract openpde_equation_abstract openpde_kinds module~~openpde_integrator_abstract~~UsesGraph module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_equation_abstract openpde_equation_abstract module~openpde_kinds->module~openpde_equation_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_integrator_abstractUsesGraph = svgPanZoom('#moduleopenpde_integrator_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of integrator. Used By module~~openpde_integrator_abstract~~UsedByGraph module~openpde_integrator_abstract openpde_integrator_abstract module~openpde openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_integrator_euler_explicit->module~openpde module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_integrator_abstractUsedByGraph = svgPanZoom('#moduleopenpde_integrator_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Initialize integrator. private subroutine abstract_init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator. abstract interface Integrate the field accordingly the equation. private function abstract_integrate (this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly to the equation. Derived Types type, public, abstract :: integrator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure(abstract_init), public, pass(this) :: init Initilize integrator. procedure(abstract_integrate), public, pass(this) :: integrate Integrate the field accordingly to the equation. procedure, public, pass(this) :: free Free dynamic memory. Description Abstract class of integrator. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Description Free dynamic memory.","tags":"","loc":"module/openpde_integrator_abstract.html","title":"openpde_integrator_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_kinds module~~openpde_equation_abstract~~UsesGraph module~openpde_equation_abstract openpde_equation_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_equation_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of equation. Used By module~~openpde_equation_abstract~~UsedByGraph module~openpde_equation_abstract openpde_equation_abstract module~openpde openpde module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_integrator_euler_explicit->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_equation_abstractUsedByGraph = svgPanZoom('#moduleopenpde_equation_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Equation boundary conditions. private subroutine abstract_bc (this, inp, t) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition. abstract interface Initialize equation. private subroutine abstract_init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation. abstract interface Return the field after forcing the equation. private function abstract_forcing (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation. Derived Types type, public, abstract :: equation Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. Type-Bound Procedures procedure(abstract_bc), public, pass(this) :: bc Equation boundary conditions. procedure(abstract_forcing), public, pass(this) :: forcing Forcing equation. procedure(abstract_init), public, pass(this) :: init Initialize the equation. procedure, public, pass(this) :: free Free dynamic memory. Description Abstract class of equation. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Description Free dynamic memory.","tags":"","loc":"module/openpde_equation_abstract.html","title":"openpde_equation_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_mesh_abstract openpde_kinds vtk_fortran module~~openpde_mesh_fd_2d~~UsesGraph module~openpde_mesh_fd_2d openpde_mesh_FD_2D vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 2D methods. Used By module~~openpde_mesh_fd_2d~~UsedByGraph module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde openpde module~openpde_mesh_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_mesh_fd_2dUsedByGraph = svgPanZoom('#moduleopenpde_mesh_fd_2dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( mesh ) :: mesh_FD_2D Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: nx = 0 Number of X points. integer(kind=I_P), public :: ny = 0 Number of Y points. integer(kind=I_P), public :: ngx = 0 Number of X ghost points. integer(kind=I_P), public :: ngy = 0 Number of Y ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: hx = 0._R_P Cell X size. real(kind=R_P), public :: hy = 0._R_P Cell Y size. Type-Bound Procedures procedure, public, pass(this) :: init Initilize mesh. procedure, public, pass(this) :: output Output data. procedure, public, pass(this) :: set Set mesh. Description Concrete class of mesh for Finite Difference 2D methods. Subroutines public subroutine associate_mesh_FD_2D (mesh_input, calling_procedure, mesh_pointer) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( mesh_FD_2D ), intent(inout), pointer :: mesh_pointer Finite Difference 1D mesh pointer. Description Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. private pure subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. private pure subroutine set (this, description, nx, ny, ngx, ngy, s, hx, hy, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh.","tags":"","loc":"module/openpde_mesh_fd_2d.html","title":"openpde_mesh_FD_2D – openpde"},{"text":"Uses: openpde_kinds module~~openpde_mesh_abstract~~UsesGraph module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract class of mesh. Used By module~~openpde_mesh_abstract~~UsedByGraph module~openpde_mesh_abstract openpde_mesh_abstract module~openpde openpde module~openpde_mesh_abstract->module~openpde module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~openpde_mesh_fd_2d->module~openpde module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_equation_abstract openpde_equation_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~scalar_simple_equation_m->program~scalar_simple module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d var panmoduleopenpde_mesh_abstractUsedByGraph = svgPanZoom('#moduleopenpde_mesh_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Initialize mesh. private subroutine abstract_meshinit (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. abstract interface Output mesh. private subroutine abstract_meshoutput (this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. Derived Types type, public, abstract :: mesh Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure(abstract_meshinit), public, pass(this) :: init Initilize mesh. procedure(abstract_meshoutput), public, pass(this) :: output Output mesh. procedure, public, pass(this) :: free Free dynamic memory. Description Abstract class of mesh. Subroutines private elemental subroutine free (this) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Description Free dynamic memory.","tags":"","loc":"module/openpde_mesh_abstract.html","title":"openpde_mesh_abstract – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_mesh_abstract openpde_kinds vtk_fortran module~~openpde_mesh_fd_1d~~UsesGraph module~openpde_mesh_fd_1d openpde_mesh_FD_1D vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Concrete class of mesh for Finite Difference 1D methods. Used By module~~openpde_mesh_fd_1d~~UsedByGraph module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde openpde module~openpde_mesh_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m program~scalar_simple scalar_simple module~openpde->program~scalar_simple module~scalar_simple_equation_m->program~scalar_simple var panmoduleopenpde_mesh_fd_1dUsedByGraph = svgPanZoom('#moduleopenpde_mesh_fd_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( mesh ) :: mesh_FD_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n = 0 Number of points. integer(kind=I_P), public :: ng = 0 Number of ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: init Initilize mesh. procedure, public, pass(this) :: output Output data. generic, public :: load => load_from_json Load mesh definition from file. procedure, public, pass(this) :: set Set mesh. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. Description Concrete class of mesh for Finite Difference 1D methods. Subroutines public subroutine associate_mesh_FD_1D (mesh_input, calling_procedure, mesh_pointer) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in) :: calling_procedure Name of the calling procedure. class( mesh_FD_1D ), intent(inout), pointer :: mesh_pointer Finite Difference 1D mesh pointer. Description Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh. private subroutine output (this, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh. private pure subroutine set (this, description, n, ng, s, h, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Description Set mesh. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file.","tags":"","loc":"module/openpde_mesh_fd_1d.html","title":"openpde_mesh_FD_1D – openpde"},{"text":"Uses: iso_fortran_env json_module openpde module~~scalar_simple_equation_m~~UsesGraph module~scalar_simple_equation_m scalar_simple_equation_m module~openpde openpde module~openpde->module~scalar_simple_equation_m iso_fortran_env iso_fortran_env iso_fortran_env->module~scalar_simple_equation_m module~openpde_mesh_fd_2d openpde_mesh_FD_2D iso_fortran_env->module~openpde_mesh_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D iso_fortran_env->module~openpde_field_fd_2d module~openpde_field_fd_1d openpde_field_FD_1D iso_fortran_env->module~openpde_field_fd_1d module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit iso_fortran_env->module~openpde_integrator_euler_explicit module~openpde_mesh_fd_1d openpde_mesh_FD_1D iso_fortran_env->module~openpde_mesh_fd_1d json_module json_module json_module->module~scalar_simple_equation_m json_module->module~openpde_integrator_euler_explicit json_module->module~openpde_mesh_fd_1d module~openpde_mesh_fd_2d->module~openpde module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_mesh_abstract->module~openpde module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_spatial_operator_d2_fd_2d->module~openpde vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d vtk_fortran->module~openpde_mesh_fd_1d var panmodulescalar_simple_equation_mUsesGraph = svgPanZoom('#modulescalar_simple_equation_mUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Scalar simple equation definition.\n The PDE solved is  \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} + b \\frac{\\partial&#94;2 u}{\\partial x&#94;2} = 0 \n where a and b are two constant scalars. This is a one dimensional, unsteady, linear PDE. It is solved adopting a finite difference approximations of\n first and second derivatives computed on a uniform mesh. The spatial operators are approximated as:  \\frac{\\partial u}{\\partial x}|_i = \\frac{u_{i+1}-u_i}{h} \\quad i=1,N \n  \\frac{\\partial&#94;2 u}{\\partial x&#94;2}|_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{h&#94;2} \\quad i=1,N \n where N is the number of discrete points and h=L/N is the (uniform) grid resolution, L is the domain length. The explicit Euler's method is used for advancing on time. Used By module~~scalar_simple_equation_m~~UsedByGraph module~scalar_simple_equation_m scalar_simple_equation_m program~scalar_simple scalar_simple module~scalar_simple_equation_m->program~scalar_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( equation ) :: scalar_simple_equation Components Type Visibility Attributes Name Initial real(kind=R_P), public :: a = 0._R_P a equation coefficient. real(kind=R_P), public :: b = 0._R_P b equation coefficient. class( spatial_operator_d1 ), public, pointer :: du First derivative. class( spatial_operator_d2 ), public, pointer :: ddu Second derivative. Type-Bound Procedures procedure, public, pass(this) :: bc Equation boundary conditions. procedure, public, pass(this) :: forcing Forcing equation. procedure, public, pass(this) :: init Initialize equation. generic, public :: load => load_from_json Load equation definition from file. procedure, private, pass(this) :: load_from_json Load equation definition from jSON file. Description (Fake) scalar_simple equations. Functions private function forcing (this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed after forcing the residual function. Description Return the field after forcing the equation. Subroutines private subroutine bc (this, inp, t) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary conditions imposition. private subroutine init (this, description, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation. private subroutine load_from_json (this, filename, error) Arguments Type Intent Optional Attributes Name class( scalar_simple_equation ), intent(inout) :: this The equation. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Description Load mesh definition from JSON file.","tags":"","loc":"module/scalar_simple_equation_m.html","title":"scalar_simple_equation_m – openpde"},{"text":"Uses: openpde scalar_simple_equation_m program~~scalar_simple~~UsesGraph program~scalar_simple scalar_simple module~openpde openpde module~openpde->program~scalar_simple module~scalar_simple_equation_m scalar_simple_equation_m module~openpde->module~scalar_simple_equation_m module~scalar_simple_equation_m->program~scalar_simple module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_mesh_abstract->module~openpde module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_spatial_operator_d2_fd_2d->module~openpde vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d vtk_fortran->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~scalar_simple_equation_m iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_integrator_euler_explicit iso_fortran_env->module~openpde_mesh_fd_1d json_module json_module json_module->module~scalar_simple_equation_m json_module->module~openpde_integrator_euler_explicit json_module->module~openpde_mesh_fd_1d var panprogramscalar_simpleUsesGraph = svgPanZoom('#programscalar_simpleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Openpde test program: scalar_simple equation. Variables Type Attributes Name Initial class( mesh ), allocatable :: mesh_ The mesh. class( field ), allocatable :: u The field. class( integrator ), allocatable :: integrator_ The integrator. class( equation ), allocatable :: equation_ The equation. integer(kind=I_P) :: itmin = 0 Fist time step. integer(kind=I_P) :: itmax = 1000 Last time step. integer(kind=I_P) :: it Time step counter. integer(kind=I_P) :: er Error status. character(len=16) :: output_name Output file name. logical :: json_found Flag inquiring the presence of json input file. Source Code program scalar_simple !< Openpde test program: scalar_simple equation. use openpde use scalar_simple_equation_m class ( mesh ), allocatable :: mesh_ !< The mesh. class ( field ), allocatable :: u !< The field. class ( integrator ), allocatable :: integrator_ !< The integrator. class ( equation ), allocatable :: equation_ !< The equation. integer ( I_P ) :: itmin = 0 !< Fist time step. integer ( I_P ) :: itmax = 1000 !< Last time step. integer ( I_P ) :: it !< Time step counter. integer ( I_P ) :: er !< Error status. character ( 16 ) :: output_name !< Output file name. logical :: json_found !< Flag inquiring the presence of json input file. allocate ( mesh_FD_1D :: mesh_ ) allocate ( field_FD_1D :: u ) allocate ( scalar_simple_equation :: equation_ ) allocate ( integrator_euler_explicit :: integrator_ ) inquire ( file = 'scalar_simple.json' , exist = json_found ) if ( json_found ) then call mesh_ % init ( filename = 'scalar_simple.json' ) call u % init ( field_mesh = mesh_ ) call equation_ % init ( filename = 'scalar_simple.json' ) call integrator_ % init ( filename = 'scalar_simple.json' ) else call mesh_ % init call u % init ( field_mesh = mesh_ ) call equation_ % init call integrator_ % init endif output_name = \"out_XXXXXXXX.dat\" write ( output_name ( 5 : 12 ), \"(I8.8)\" ) itmin call u % output ( output_name , error = er ) do it = itmin , itmax er = integrator_ % integrate ( inp = u , equ = equation_ , t = it * integrator_ % dt ) if ( mod ( it , 10 ) == 0 ) then print * , 'it: ' , it write ( output_name ( 5 : 12 ), \"(I8.8)\" ) it call u % output ( output_name , error = er ) endif enddo call mesh_ % output ( error = er ) end program scalar_simple","tags":"","loc":"program/scalar_simple.html","title":"scalar_simple – openpde"}]}