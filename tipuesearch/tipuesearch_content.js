var tipuesearch = {"pages":[{"text":"openpde Developer Info Francesco Salvadore","tags":"","loc":"index.html","title":" openpde "},{"text":"Definition of reals and integer kind parameters of openpde library. Files Dependent On This One sourcefile~~openpde_kinds.f90~~AfferentGraph sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 var pansourcefileopenpde_kindsf90AfferentGraph = svgPanZoom('#sourcefileopenpde_kindsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_kinds Source Code openpde_kinds.f90 Source Code !< Definition of reals and integer kind parameters of openpde library. module openpde_kinds !< Definition of reals and integer kind parameters of openpde library. implicit none private public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. end module openpde_kinds","tags":"","loc":"sourcefile/openpde_kinds.f90.html","title":"openpde_kinds.f90 – openpde"},{"text":"Open Fortran Library for PDE solving. This File Depends On sourcefile~~openpde.f90~~EfferentGraph sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 var pansourcefileopenpdef90EfferentGraph = svgPanZoom('#sourcefileopenpdef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde Source Code openpde.f90 Source Code !< Open Fortran Library for PDE solving. module openpde !< Open Fortran Library for PDE solving. ! abstract classes definition use openpde_equation_abstract use openpde_field_abstract use openpde_field_surface_abstract use openpde_integrator_abstract use openpde_integrator_adv_abstract use openpde_mesh_abstract use openpde_spatial_operator_abstract use openpde_spatial_operator_d1_abstract use openpde_spatial_operator_d2_abstract use openpde_vector_abstract use openpde_matrix_abstract use openpde_f2v_abstract use openpde_v2f_abstract use openpde_f2m_abstract use openpde_f2m_d1_abstract use openpde_f2m_d2_abstract use openpde_linsolver_abstract use openpde_equation_adv ! fake concrete, acts as fake-abstract ! concrete classes definition use openpde_field_FD_1D use openpde_field_FD_2D use openpde_field_FV_1D use openpde_field_surface_FV_1D use openpde_integrator_euler_explicit use openpde_integrator_adv_euler_explicit use openpde_integrator_adv_euler_implicit use openpde_integrator_adv_rk_implicit use openpde_mesh_FD_1D use openpde_mesh_FD_2D use openpde_mesh_FV_1D use openpde_spatial_operator_d1_FD_1D use openpde_spatial_operator_d1_FD_2D use openpde_spatial_operator_d1_FV_1D use openpde_spatial_operator_d2_FD_1D use openpde_spatial_operator_d2_FD_2D use openpde_spatial_operator_d2_FV_1D use openpde_vector_simple use openpde_matrix_simple use openpde_f2v_FD_1D use openpde_v2f_FD_1D use openpde_f2v_FD_2D use openpde_v2f_FD_2D use openpde_f2m_d1_FD_1D use openpde_f2m_d2_FD_1D use openpde_f2m_d2_FD_2D use openpde_linsolver_gmlapack use openpde_multigrid_FD_1D ! kinds definition use openpde_kinds implicit none private ! abstract classes public :: equation public :: field public :: field_surface public :: integrator public :: mesh public :: spatial_operator public :: spatial_operator_d1 public :: spatial_operator_d2 public :: vector public :: matrix public :: f2v public :: v2f public :: f2m public :: f2m_d1 public :: f2m_d2 public :: linsolver public :: equation_adv ! fake abstract public :: integrator_adv ! concrete classes public :: associate_field_FD_1D , field_FD_1D public :: associate_field_FD_2D , field_FD_2D public :: associate_field_FV_1D , field_FV_1D public :: associate_field_surface_FV_1D , field_surface_FV_1D public :: integrator_euler_explicit public :: associate_mesh_FD_1D , mesh_FD_1D public :: associate_mesh_FD_2D , mesh_FD_2D public :: associate_mesh_FV_1D , mesh_FV_1D public :: spatial_operator_d1_FD_1D public :: spatial_operator_d1_FD_2D public :: spatial_operator_d1_FV_1D public :: spatial_operator_d2_FD_1D public :: spatial_operator_d2_FD_2D public :: spatial_operator_d2_FV_1D public :: vector_simple public :: matrix_simple public :: f2v_FD_1D public :: v2f_FD_1D public :: f2v_FD_2D public :: v2f_FD_2D public :: f2m_d1_FD_1D public :: f2m_d2_FD_1D public :: f2m_d2_FD_2D public :: linsolver_gmlapack public :: multigrid_FD_1D public :: integrator_adv_euler_explicit public :: integrator_adv_euler_implicit public :: integrator_adv_rk_implicit ! kinds public :: R8P public :: R4P public :: R_P public :: I8P public :: I4P public :: I2P public :: I1P public :: I_P end module openpde","tags":"","loc":"sourcefile/openpde.f90.html","title":"openpde.f90 – openpde"},{"text":"Concrete class of field for Finite Difference 2D methods. This File Depends On sourcefile~~openpde_field_fd_2d.f90~~EfferentGraph sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_field_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_fd_2d.f90~~AfferentGraph sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_FD_2D Source Code openpde_field_FD_2D.f90 Source Code !< Concrete class of field for Finite Difference 2D methods. module openpde_field_FD_2D !< Concrete class of field for Finite Difference 2D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_mesh_abstract use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: associate_field_FD_2D , field_FD_2D type , extends ( field ) :: field_FD_2D !< Concrete class of field for Finite Difference 2D methods. real ( R_P ), allocatable , dimension (:,:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_2D contains ! public, non TBP function associate_field_FD_2D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_2D ), pointer :: field_pointer !< Finite Difference 2D field pointer. select type ( field_input ) type is ( field_FD_2D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_2D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_2D ! deferred public methods subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. mesh_cur => associate_mesh_FD_2D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_2D%associate_mesh' ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) allocate ( this % val ( 1 - mesh_cur % ngx : mesh_cur % nx + mesh_cur % ngx , 1 - mesh_cur % ngy : mesh_cur % ny + mesh_cur % ngy )) if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 2D field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FD_2D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_2D%init' ) do j = 1 - mesh_cur % ngy , mesh_cur % ny + mesh_cur % ngy do i = 1 - mesh_cur % ngx , mesh_cur % nx + mesh_cur % ngx this % val ( i , j ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % nx ) * sin ( j * 2._R_P * acos ( - 1._R_P ) / mesh_cur % ny ) enddo enddo if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_2D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: jmin !< Lower extent. integer ( I_P ) :: jmax !< Upper extent. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) jmin = lbound ( this % val , dim = 2 ) jmax = ubound ( this % val , dim = 2 ) open ( unit = 11 , file = filename ) do j = jmin , jmax do i = imin , imax write ( 11 , * ) i , j , this % val ( i , j ) enddo write ( 11 , * ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%add' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_2D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%mul' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_2D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%sub' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%sub' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val / rhs_cur % val end function div ! public methods subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :, 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :, 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_2D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free end module openpde_field_FD_2D","tags":"","loc":"sourcefile/openpde_field_fd_2d.f90.html","title":"openpde_field_FD_2D.f90 – openpde"},{"text":"Abstract class of field. This File Depends On sourcefile~~openpde_field_abstract.f90~~EfferentGraph sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_abstract.f90~~AfferentGraph sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 var pansourcefileopenpde_field_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_field_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_abstract Source Code openpde_field_abstract.f90 Source Code !< Abstract class of field. module openpde_field_abstract !< Abstract class of field. use openpde_mesh_abstract use openpde_kinds implicit none private public :: field type , abstract :: field !< Abstract class of field. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred public methods procedure ( abstract_associate_mesh ), pass ( this ), deferred :: associate_mesh !< Associate mesh. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize field. procedure ( abstract_output ), pass ( this ), deferred :: output !< Output field data. ! deferred private methods procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), pass ( lhs ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), pass ( lhs ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: sub !< Subtract fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: div !< Divide fields. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype field ! deferred public methods interfaces abstract interface !< Associate a mesh to field. subroutine abstract_associate_mesh ( this , field_mesh , error ) !< Associate a mesh to field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_associate_mesh endinterface abstract interface !< Initialize the field. subroutine abstract_init ( this , field_mesh , description , error ) !< Initialize the field. import :: field , I_P , mesh class ( field ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< The mesh. character ( * ), intent ( in ), optional :: description !< Description of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Output the field. subroutine abstract_output ( this , filename , error ) !< Output the field. import :: field , I_P class ( field ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output fiel name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_output endinterface ! deferred private methods interfaces abstract interface !< Symmetric operator field.op.field. function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) !< Symmetric operator field.op.field. import :: field class ( field ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_simmetric_operator endinterface abstract interface !< Non symmetric operator field.op.real. function abstract_field_op_real ( lhs , rhs ) result ( opr ) !< Non symmetric operator field.op.real. import :: field , R_P class ( field ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_field_op_real endinterface abstract interface !< Non symmetric operator real.op.field. function abstract_real_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator real.op.field. import :: field , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable :: opr !< Operator result. end function abstract_real_op_field endinterface abstract interface !< Assignment overloading. subroutine abstract_assign ( lhs , rhs ) !< Assignment overloading. import :: field class ( field ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. end subroutine abstract_assign endinterface contains ! public methods elemental subroutine free ( this ) !< Free dynamic memory. !< !< @todo Discuss about the *free* of mesh pointer. class ( field ), intent ( inout ) :: this !< The field. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) then !   call this%m%free !   deallocate(this%m) ! endif ! this%m => null() end subroutine free end module openpde_field_abstract","tags":"","loc":"sourcefile/openpde_field_abstract.f90.html","title":"openpde_field_abstract.f90 – openpde"},{"text":"Concrete class of field surface block for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_field_surface_block_fv_1d.f90~~EfferentGraph sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 var pansourcefileopenpde_field_surface_block_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_surface_block_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_surface_block_fv_1d.f90~~AfferentGraph sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_surface_block_FV_1D Source Code openpde_field_surface_block_FV_1D.f90 Source Code !< Concrete class of field surface block for Finite Volume 1D methods. module openpde_field_surface_block_FV_1D !< Concrete class of field surface block for Finite Volume 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_kinds use openpde_field_block_FV_1D use openpde_mesh_FV_1D use openpde_mesh_block_FV_1D implicit none private public :: field_surface_block_FV_1D type :: field_surface_block_FV_1D !< Concrete class of field surface block for Finite Volume 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Block value. contains ! public methods procedure , pass ( this ) :: alloc !< Allocate block. procedure , pass ( this ) :: compute_fluxes !< Compute fluxes of field through surfaces. procedure , pass ( this ) :: free !< Free dynamic memory. procedure , pass ( this ) :: init !< Initilize block. procedure , pass ( this ) :: output !< Output block data. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `/` overloading. generic , public :: assignment ( = ) => assign_block !< Assignment overloading. ! private methods procedure , pass ( lhs ), private :: add !< Add blocks. procedure , pass ( lhs ), private :: assign_block !< Assign blocks. procedure , pass ( lhs ), private :: mul !< Multiply blocks. procedure , pass ( lhs ), private :: mulreal !< Multiply block for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for block. procedure , pass ( lhs ), private :: sub !< Divide blocks. procedure , pass ( lhs ), private :: div !< Divide blocks. endtype field_surface_block_FV_1D contains ! public methods subroutine alloc ( this , mesh_block , error ) !< Allocate block. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free allocate ( this % val ( 0 : mesh_block % n )) if ( present ( error )) error = 0 end subroutine alloc subroutine compute_fluxes ( this , field_cell , mesh_block , error ) !< Compute fluxes of field through surfaces. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( field_block_FV_1D ), intent ( in ) :: field_cell !< Field at cells center. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 0 , mesh_block % n this % val ( i ) = field_cell % val ( i ) enddo end subroutine compute_fluxes elemental subroutine free ( this ) !< Free dynamic memory. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The field. if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free subroutine init ( this , mesh_block , error ) !< Initialize block. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % alloc ( mesh_block = mesh_block , error = error ) this % val = 0._R_P if ( present ( error )) error = 0 end subroutine init subroutine output ( this , unit , mesh_block , error ) !< Output block data. class ( field_surface_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( in ) :: unit !< Unit file. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 0 , mesh_block % n write ( unit , * ) this % val ( i ) enddo if ( present ( error )) error = 0 end subroutine output ! private methods elemental function add ( lhs , rhs ) result ( opr ) !< Add blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val + rhs % val end function add elemental subroutine assign_block ( lhs , rhs ) !< Assign blocks. class ( field_surface_block_FV_1D ), intent ( inout ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. lhs % val = rhs % val end subroutine assign_block elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs % val end function mul elemental function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs end function mulreal elemental function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Right hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs * rhs % val end function realmul elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val - rhs % val end function sub elemental function div ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val / rhs % val end function div end module openpde_field_surface_block_FV_1D","tags":"","loc":"sourcefile/openpde_field_surface_block_fv_1d.f90.html","title":"openpde_field_surface_block_FV_1D.f90 – openpde"},{"text":"Concrete class of field for Finite Difference 1D methods. This File Depends On sourcefile~~openpde_field_fd_1d.f90~~EfferentGraph sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_field_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_fd_1d.f90~~AfferentGraph sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_FD_1D Source Code openpde_field_FD_1D.f90 Source Code !< Concrete class of field for Finite Difference 1D methods. module openpde_field_FD_1D !< Concrete class of field for Finite Difference 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_kinds use openpde_mesh_abstract use openpde_mesh_FD_1D implicit none private public :: associate_field_FD_1D , field_FD_1D type , extends ( field ) :: field_FD_1D !< Concrete class of field for Finite Difference 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. !procedure, pass(rhs) :: newrealmul !public :: operator(**) => newrealmul endtype field_FD_1D interface associate_field_FD_1D module procedure associate_field_FD_1D_scalar , & associate_field_FD_1D_rank1 , & associate_field_FD_1D_rank2 end interface contains ! public, non TBP function associate_field_FD_1D_scalar ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_scalar function associate_field_FD_1D_rank1 ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input (:) !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer (:) !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_rank1 function associate_field_FD_1D_rank2 ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input (:,:) !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer (:,:) !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_rank2 ! deferred public methods subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. mesh_cur => associate_mesh_FD_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_1D%associate_mesh' ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - mesh_cur % ng : mesh_cur % n + mesh_cur % ng )) if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FD_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_1D%init' ) this % val (:) = 0._R_P !        do i = 1, mesh_cur%n do i = 1 - mesh_cur % ng , mesh_cur % n + mesh_cur % ng this % val ( i ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % n ) enddo if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%add' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%mul' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul function newrealmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function newrealmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%sub' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%sub' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val / rhs_cur % val end function div ! public methods subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free end module openpde_field_FD_1D","tags":"","loc":"sourcefile/openpde_field_fd_1d.f90.html","title":"openpde_field_FD_1D.f90 – openpde"},{"text":"Abstract class of field surface. This File Depends On sourcefile~~openpde_field_surface_abstract.f90~~EfferentGraph sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_field_surface_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_surface_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_surface_abstract.f90~~AfferentGraph sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_surface_abstract Source Code openpde_field_surface_abstract.f90 Source Code !< Abstract class of field surface. module openpde_field_surface_abstract !< Abstract class of field surface. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_kinds implicit none private public :: field_surface type , abstract , extends ( field ) :: field_surface !< Abstract class of field surface. contains ! deferred public methods procedure ( abstract_compute_fluxes ), pass ( this ), deferred :: compute_fluxes !< Compute fluxes of field through surfaces. endtype field_surface ! deferred public methods interfaces abstract interface !< Compute fluxes of field through surfaces. subroutine abstract_compute_fluxes ( this , field_cell , error ) !< Compute fluxes of field through surfaces. import :: field , field_surface , I_P class ( field_surface ), intent ( inout ) :: this !< Fluxex. class ( field ), intent ( in ) :: field_cell !< Field at cells center. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_compute_fluxes endinterface end module openpde_field_surface_abstract","tags":"","loc":"sourcefile/openpde_field_surface_abstract.f90.html","title":"openpde_field_surface_abstract.f90 – openpde"},{"text":"Concrete class of field surface for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_field_surface_fv_1d.f90~~EfferentGraph sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 var pansourcefileopenpde_field_surface_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_surface_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_surface_fv_1d.f90~~AfferentGraph sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_surface_FV_1D Source Code openpde_field_surface_FV_1D.f90 Source Code !< Concrete class of field surface for Finite Volume 1D methods. module openpde_field_surface_FV_1D !< Concrete class of field surface for Finite Volume 1D methods. !< !< This field is associated to a meh based on a uniform, Cartesian cell-centered discretization of the domain, !< that is a multiblock mesh. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_field_FV_1D use openpde_field_surface_abstract use openpde_field_surface_block_FV_1D use openpde_kinds use openpde_mesh_abstract use openpde_mesh_FV_1D use openpde_mesh_block_FV_1D implicit none private public :: associate_field_surface_FV_1D , field_surface_FV_1D type , extends ( field_surface ) :: field_surface_FV_1D !< Concrete class of field surface for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( field_surface_block_FV_1D ), allocatable , dimension (:) :: blocks !< The blocks. contains ! deferred public methods of field abstract procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field. ! deferred public methods of field_surface abstract procedure , pass ( this ) :: compute_fluxes !< Compute fluxes of field through surfaces. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. endtype field_surface_FV_1D contains ! public, non TBP function associate_field_surface_FV_1D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Volume 1D field surface pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_surface_FV_1D ), pointer :: field_pointer !< Concrete field pointer. select type ( field_input ) type is ( field_surface_FV_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_surface_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_surface_FV_1D ! deferred public methods of field abstract subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_surface_FV_1D%associate_mesh' ) this % m => mesh_cur this % nb = mesh_cur % nb if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = 1 , this % nb call this % blocks ( b )% alloc ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize field. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_surface_FV_1D%init' ) do b = 1 , this % nb call this % blocks ( b )% init ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field. class ( field_surface_FV_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: unit !< File unit. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = this % m , emsg = 'calling procedure field_surface_FV_1D%output' ) open ( newunit = unit , file = filename ) do b = 1 , mesh_cur % nb call this % blocks ( b )% output ( unit = unit , mesh_block = mesh_cur % blocks ( b ), error = error ) enddo close ( unit ) if ( present ( error )) error = 0 end subroutine output ! deferred public methods of field_surface abstract subroutine compute_fluxes ( this , field_cell , error ) !< Compute fluxes of field through surfaces. class ( field_surface_FV_1D ), intent ( inout ) :: this !< Fluxex. class ( field ), intent ( in ) :: field_cell !< Field at cells center. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( field_FV_1D ), pointer :: field_cell_cur !< Dummy pointer for field at cells center. class ( field_surface_FV_1D ), pointer :: flux_cur !< Dummy pointer for fluxes. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. field_cell_cur => associate_field_FV_1D ( field_input = field_cell , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = field_cell_cur % m , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) flux_cur => associate_field_surface_FV_1D ( field_input = this , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) do b = 1 , mesh_cur % nb call flux_cur % blocks ( b )% compute_fluxes ( field_cell = field_cell_cur % blocks ( b ), mesh_block = mesh_cur % blocks ( b ), error = error ) end do end subroutine compute_fluxes ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%add' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks + rhs_cur % blocks end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_surface_FV_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % blocks = rhs_cur % blocks end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%mul' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs_cur % blocks end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_surface_FV_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % blocks = lhs * rhs % blocks end function realmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%sub' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks - rhs_cur % blocks end function sub function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%sub' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks / rhs_cur % blocks end function div ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free end module openpde_field_surface_FV_1D","tags":"","loc":"sourcefile/openpde_field_surface_fv_1d.f90.html","title":"openpde_field_surface_FV_1D.f90 – openpde"},{"text":"Concrete class of field block for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_field_block_fv_1d.f90~~EfferentGraph sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 var pansourcefileopenpde_field_block_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_block_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_block_fv_1d.f90~~AfferentGraph sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 var pansourcefileopenpde_field_block_fv_1df90AfferentGraph = svgPanZoom('#sourcefileopenpde_field_block_fv_1df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_block_FV_1D Source Code openpde_field_block_FV_1D.f90 Source Code !< Concrete class of field block for Finite Volume 1D methods. module openpde_field_block_FV_1D !< Concrete class of field block for Finite Volume 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_kinds use openpde_mesh_FV_1D use openpde_mesh_block_FV_1D implicit none private public :: field_block_FV_1D type :: field_block_FV_1D !< Concrete class of field block for Finite Volume 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Block value. contains ! public methods procedure , pass ( this ) :: alloc !< Allocate block. procedure , pass ( this ) :: free !< Free dynamic memory. procedure , pass ( this ) :: init !< Initilize block. procedure , pass ( this ) :: output !< Output block data. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_block !< Assignment overloading. ! private methods procedure , pass ( lhs ), private :: add !< Add blocks. procedure , pass ( lhs ), private :: assign_block !< Assign blocks. procedure , pass ( lhs ), private :: mul !< Multiply blocks. procedure , pass ( lhs ), private :: mulreal !< Multiply block for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for block. procedure , pass ( lhs ), private :: sub !< Subtract blocks. procedure , pass ( lhs ), private :: div !< Subtract blocks. endtype field_block_FV_1D contains ! public methods subroutine alloc ( this , mesh_block , error ) !< Allocate block. class ( field_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free allocate ( this % val ( 1 - mesh_block % ng : mesh_block % n + mesh_block % ng )) if ( present ( error )) error = 0 end subroutine alloc elemental subroutine free ( this ) !< Free dynamic memory. class ( field_block_FV_1D ), intent ( inout ) :: this !< The field. if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free subroutine init ( this , mesh_field , b , error ) !< Initialize block. class ( field_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_FV_1D ), intent ( in ) :: mesh_field !< Mesh of the whole field. integer ( I_P ), intent ( in ) :: b !< Block index. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: offset !< Cells offset. integer ( I_P ) :: n !< Total number of Cells. integer ( I_P ) :: i !< Counter. offset = 0 ; if ( b > 1 ) offset = sum ( mesh_field % blocks ( 1 : b - 1 )% n , dim = 1 ) n = sum ( mesh_field % blocks % n , dim = 1 ) call this % alloc ( mesh_block = mesh_field % blocks ( b ), error = error ) do i = 1 , mesh_field % blocks ( b )% n this % val ( i ) = sin (( i + offset ) * 2._R_P * acos ( - 1._R_P ) / n ) enddo if ( present ( error )) error = 0 end subroutine init subroutine output ( this , unit , mesh_block , error ) !< Output block data. class ( field_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( in ) :: unit !< Unit file. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 1 , mesh_block % n write ( unit , * ) this % val ( i ) enddo if ( present ( error )) error = 0 end subroutine output ! private methods elemental function add ( lhs , rhs ) result ( opr ) !< Add blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val + rhs % val end function add elemental subroutine assign_block ( lhs , rhs ) !< Assign blocks. class ( field_block_FV_1D ), intent ( inout ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. lhs % val = rhs % val end subroutine assign_block elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs % val end function mul elemental function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs end function mulreal elemental function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_block_FV_1D ), intent ( in ) :: rhs !< Right hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs * rhs % val end function realmul elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val - rhs % val end function sub elemental function div ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val / rhs % val end function div end module openpde_field_block_FV_1D","tags":"","loc":"sourcefile/openpde_field_block_fv_1d.f90.html","title":"openpde_field_block_FV_1D.f90 – openpde"},{"text":"Concrete class of field for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_field_fv_1d.f90~~EfferentGraph sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 var pansourcefileopenpde_field_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_field_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_field_fv_1d.f90~~AfferentGraph sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_field_FV_1D Source Code openpde_field_FV_1D.f90 Source Code !< Concrete class of field for Finite Volume 1D methods. module openpde_field_FV_1D !< Concrete class of field for Finite Volume 1D methods. !< !< This field is associated to a meh based on a uniform, Cartesian cell-centered discretization of the domain, !< that is a multiblock mesh. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_field_abstract use openpde_field_block_FV_1D use openpde_kinds use openpde_mesh_abstract use openpde_mesh_FV_1D use openpde_mesh_block_FV_1D implicit none private public :: associate_field_FV_1D , field_FV_1D type , extends ( field ) :: field_FV_1D !< Concrete class of field for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( field_block_FV_1D ), allocatable , dimension (:) :: blocks !< The blocks. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. endtype field_FV_1D contains ! public, non TBP function associate_field_FV_1D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FV_1D ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FV_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FV_1D ! deferred public methods subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FV_1D%associate_mesh' ) this % m => mesh_cur this % nb = mesh_cur % nb if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = 1 , this % nb call this % blocks ( b )% alloc ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine associate_mesh subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FV_1D%init' ) do b = 1 , this % nb call this % blocks ( b )% init ( mesh_field = mesh_cur , b = b , error = error ) end do if ( present ( error )) error = 0 end subroutine init subroutine output ( this , filename , error ) !< Output field data. class ( field_FV_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = this % m , emsg = 'calling procedure field_FV_1D%output' ) open ( unit = 11 , file = filename ) do b = 1 , mesh_cur % nb call this % blocks ( b )% output ( unit = 11 , mesh_block = mesh_cur % blocks ( b ), error = error ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output ! deferred private methods function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%add' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks + rhs_cur % blocks end function add subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FV_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % blocks = rhs_cur % blocks end subroutine assign_field function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%mul' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs_cur % blocks end function mul function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs end function mulreal function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FV_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % blocks = lhs * rhs % blocks end function realmul function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%sub' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks - rhs_cur % blocks end function sub function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%sub' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks / rhs_cur % blocks end function div ! public overridden methods elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FV_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free end module openpde_field_FV_1D","tags":"","loc":"sourcefile/openpde_field_fv_1d.f90.html","title":"openpde_field_FV_1D.f90 – openpde"},{"text":"Concrete class of v2f (vector to field) for FD 1D This File Depends On sourcefile~~openpde_v2f_fd_2d.f90~~EfferentGraph sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 var pansourcefileopenpde_v2f_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_v2f_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_v2f_fd_2d.f90~~AfferentGraph sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_v2f_FD_2D Source Code openpde_v2f_FD_2D.f90 Source Code !< Concrete class of v2f (vector to field) for FD 1D module openpde_v2f_FD_2D !< Concrete class of v2f (vector to field) for FD 1D use openpde_field_abstract use openpde_v2f_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D use openpde_vector_abstract implicit none private public :: v2f_FD_2D type , extends ( v2f ) :: v2f_FD_2D !< Concrete class of v2f (vector to field) for FD 1D contains procedure :: operate !< Operator operation. endtype v2f_FD_2D contains subroutine operate ( this , vec , fie ) !< Operator operation. class ( v2f_FD_2D ), intent ( in ) :: this !< The operator. class ( vector ), intent ( in ) :: vec !< Input vector. class ( field ), intent ( inout ), dimension (:) :: fie !< Returned field. class ( field_FD_2D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = this % n_equ mesh_cur => associate_mesh_FD_2D ( mesh_input = this % mesh ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny do i_equ = 1 , n_equ call fie ( i_equ )% init ( field_mesh = this % mesh ) fie_cur => associate_field_FD_2D ( field_input = fie ( i_equ )) ! No concrete features of vector are used so dynamic casting is not needed do j = 1 , ny do i = 1 , nx i_vec = n * ( n_equ - 1 ) + ( j - 1 ) * nx + i fie_cur % val ( i , j ) = vec % get ( i_vec ) enddo enddo enddo end subroutine operate end module openpde_v2f_FD_2D","tags":"","loc":"sourcefile/openpde_v2f_fd_2d.f90.html","title":"openpde_v2f_FD_2D.f90 – openpde"},{"text":"Concrete class of v2f (vector to field) for FD 1D This File Depends On sourcefile~~openpde_v2f_fd_1d.f90~~EfferentGraph sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 var pansourcefileopenpde_v2f_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_v2f_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_v2f_fd_1d.f90~~AfferentGraph sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_v2f_FD_1D Source Code openpde_v2f_FD_1D.f90 Source Code !< Concrete class of v2f (vector to field) for FD 1D module openpde_v2f_FD_1D !< Concrete class of v2f (vector to field) for FD 1D use openpde_field_abstract use openpde_v2f_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D use openpde_vector_abstract implicit none private public :: v2f_FD_1D type , extends ( v2f ) :: v2f_FD_1D !< Concrete class of v2f (vector to field) for FD 1D contains procedure :: operate !< Operator operation. endtype v2f_FD_1D contains subroutine operate ( this , vec , fie ) !< Operator operation. class ( v2f_FD_1D ), intent ( in ) :: this !< The operator. class ( vector ), intent ( in ) :: vec !< Input vector. class ( field ), intent ( inout ), dimension (:) :: fie !< Returned field. class ( field_FD_1D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = this % n_equ n = vec % n / n_equ do i_equ = 1 , n_equ call fie ( i_equ )% init ( field_mesh = this % mesh ) fie_cur => associate_field_FD_1D ( field_input = fie ( i_equ )) ! No concrete features of vector are used so dynamic casting is not needed do i = 1 , n i_vec = n * ( n_equ - 1 ) + i fie_cur % val ( i ) = vec % get ( i_vec ) enddo enddo end subroutine operate end module openpde_v2f_FD_1D","tags":"","loc":"sourcefile/openpde_v2f_fd_1d.f90.html","title":"openpde_v2f_FD_1D.f90 – openpde"},{"text":"Abstract class of v2f (vector to field). This File Depends On sourcefile~~openpde_v2f_abstract.f90~~EfferentGraph sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_v2f_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_v2f_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_v2f_abstract.f90~~AfferentGraph sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_v2f_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_v2f_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_v2f_abstract Source Code openpde_v2f_abstract.f90 Source Code !< Abstract class of v2f (vector to field). module openpde_v2f_abstract !< Abstract class of v2f (vector to field). use openpde_field_abstract use openpde_mesh_abstract use openpde_vector_abstract use openpde_kinds implicit none private public :: v2f type , abstract :: v2f !< Abstract class of v2f. class ( mesh ), pointer :: mesh integer ( I_P ) :: n_equ contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype v2f abstract interface !< Operator operation. subroutine abstract_operate ( this , vec , fie ) !< Operator function. import :: I_P , v2f , field , vector class ( v2f ), intent ( in ) :: this !< The operator. class ( vector ), intent ( in ) :: vec !< Input vector. class ( field ), intent ( inout ), dimension (:) :: fie !< Resulting field. end subroutine abstract_operate endinterface end module openpde_v2f_abstract","tags":"","loc":"sourcefile/openpde_v2f_abstract.f90.html","title":"openpde_v2f_abstract.f90 – openpde"},{"text":"Abstract class of linsolver A*x=b. This File Depends On sourcefile~~openpde_linsolver_abstract.f90~~EfferentGraph sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_linsolver_abstract.f90~~AfferentGraph sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_linsolver_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_linsolver_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_linsolver_abstract Source Code openpde_linsolver_abstract.f90 Source Code !< Abstract class of linsolver A*x=b. module openpde_linsolver_abstract !< Abstract class of linsolver. use openpde_matrix_abstract use openpde_vector_abstract use openpde_kinds implicit none private public :: linsolver type , abstract :: linsolver !< Abstract class of linsolver. character ( len = :), allocatable :: description !< Description. class ( matrix ), allocatable :: mat !< Matrix A class ( vector ), allocatable :: vec !< Vector b class ( vector ), allocatable :: sol !< Solution x contains ! deferred public methods procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_set_matrix ), deferred :: set_matrix !< Associate matrix procedure ( abstract_set_vector ), deferred :: set_vector !< Associate vector procedure ( abstract_solve ) , deferred :: solve !< Solve system. endtype linsolver ! deferred public methods interfaces abstract interface subroutine abstract_init ( this , n ) !< Init linsolver. import :: I_P , linsolver class ( linsolver ), intent ( inout ) :: this integer ( I_P ) :: n end subroutine abstract_init endinterface abstract interface subroutine abstract_set_matrix ( this , mat ) !< Set matrix. import :: linsolver , matrix class ( linsolver ), intent ( inout ) :: this !< The field. class ( matrix ), intent ( in ), target :: mat !< The mesh. end subroutine abstract_set_matrix endinterface abstract interface subroutine abstract_set_vector ( this , vec ) !< Set vector. import :: linsolver , vector class ( linsolver ), intent ( inout ) :: this !< The field. class ( vector ), intent ( in ), target :: vec !< The mesh. end subroutine abstract_set_vector endinterface abstract interface !< Initialize the field. subroutine abstract_solve ( this ) !< Solve system. import :: linsolver class ( linsolver ), intent ( inout ), target :: this !< The field. end subroutine abstract_solve endinterface contains ! public methods elemental subroutine free ( this ) !< Free dynamic memory. class ( linsolver ), intent ( inout ) :: this !< The linsolver. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_linsolver_abstract","tags":"","loc":"sourcefile/openpde_linsolver_abstract.f90.html","title":"openpde_linsolver_abstract.f90 – openpde"},{"text":"Concrete class of linsolver using LAPACK with general matrix. This File Depends On sourcefile~~openpde_linsolver_gmlapack.f90~~EfferentGraph sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_simple.f90 var pansourcefileopenpde_linsolver_gmlapackf90EfferentGraph = svgPanZoom('#sourcefileopenpde_linsolver_gmlapackf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_linsolver_gmlapack.f90~~AfferentGraph sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_linsolver_gmlapack Source Code openpde_linsolver_gmlapack.f90 Source Code !< Concrete class of linsolver using LAPACK with general matrix. module openpde_linsolver_gmlapack !< Concrete class of linsolver using LAPACK with general matrix. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_linsolver_abstract use openpde_matrix_abstract use openpde_vector_abstract use openpde_matrix_simple use openpde_vector_simple use openpde_kinds implicit none private public :: linsolver_gmlapack type , extends ( linsolver ) :: linsolver_gmlapack !< Concrete class of linsolver using LAPACK with general matrix. integer ( I_P ), allocatable :: ipiv (:) integer ( I_P ) :: info integer ( I_P ) :: lda contains ! deferred public methods procedure :: init procedure :: set_matrix procedure :: set_vector procedure :: solve endtype linsolver_gmlapack contains subroutine init ( this , n ) !< Init linsolver class ( linsolver_gmlapack ), intent ( inout ) :: this integer ( I_P ) :: n allocate ( matrix_simple :: this % mat ) allocate ( vector_simple :: this % vec ) allocate ( vector_simple :: this % sol ) call this % mat % init ( n ) call this % vec % init ( n ) call this % sol % init ( n ) allocate ( this % ipiv ( n )) this % lda = n end subroutine init subroutine set_matrix ( this , mat ) !< Set the solver matrix A. class ( linsolver_gmlapack ), intent ( inout ) :: this class ( matrix ), intent ( in ), target :: mat !debug select type(mat) !debug     type is(matrix_simple) !debug         print*,\"SET_MATRIX allocated(mat%val)      : \",allocated(mat%val),      size(mat%val) !debug end select !debug associate(m => this%mat) !debug select type(m) !debug     type is(matrix_simple) !debug        print*,\"SET_MATRIX allocated(this%mat%val) : \",allocated(m%val), size(m%val) !debug end select !debug end associate this % mat = mat end subroutine set_matrix subroutine set_vector ( this , vec ) !< Set the solver vector b. class ( linsolver_gmlapack ), intent ( inout ) :: this class ( vector ), intent ( in ), target :: vec this % vec = vec end subroutine set_vector subroutine solve ( this ) !< Solve the linear system. class ( linsolver_gmlapack ), intent ( inout ), target :: this integer ( I_P ) :: n class ( matrix_simple ), pointer :: mat_cur class ( vector_simple ), pointer :: vec_cur n = this % mat % n !debug print*,\"allocated(this%mat): \",allocated(this%mat) !debug associate(v => this%mat) !debug select type(v) !debug     type is(matrix_simple) !debug         mat_cur => v !debug         print*,\"allocated(this%mat%val): \",allocated(v%val) !debug         print*,\"this%mat%val: \",v%val(:,:) !debug end select !debug end associate !debug associate(v => this%vec) !debug select type(v) !debug     type is(vector_simple) !debug         print*,\"this%vec%val: \",v%val(:) !debug         vec_cur => v !debug end select !debug end associate vec_cur => associate_vector_simple ( vector_input = this % vec ) mat_cur => associate_matrix_simple ( matrix_input = this % mat ) ! Factorize matrix call dgetrf ( n , n , mat_cur % val , this % lda , this % ipiv , this % info ) ! Solver linear system call dgetrs ( 'n' , n , 1 , mat_cur % val , this % lda , this % ipiv , vec_cur % val , n , this % info ) ! Assign solution to sol vector this % sol = this % vec !debug associate(v => this%sol) !debug select type(v) !debug     type is(vector_simple) !debug         print*,\"this%sol%val: \",v%val(:) !debug end select !debug end associate end subroutine solve end module openpde_linsolver_gmlapack","tags":"","loc":"sourcefile/openpde_linsolver_gmlapack.f90.html","title":"openpde_linsolver_gmlapack.f90 – openpde"},{"text":"Concrete class of field to matrix (implicit) second derivative operator for FD 1D This File Depends On sourcefile~~openpde_f2m_d2_fd_1d.f90~~EfferentGraph sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 var pansourcefileopenpde_f2m_d2_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_d2_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_d2_fd_1d.f90~~AfferentGraph sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_d2_FD_1D Source Code openpde_f2m_d2_FD_1D.f90 Source Code !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D module openpde_f2m_d2_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D use openpde_field_abstract use openpde_f2m_d2_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D use openpde_matrix_abstract implicit none private public :: f2m_d2_FD_1D type , extends ( f2m_d2 ) :: f2m_d2_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d2_FD_1D contains function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. real ( R_P ) :: invd !< Temporary 1/D**2 integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp ( i_equ_ )% m ) n = mesh_cur % n n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invd = 1._R_P / mesh_cur % h ** 2 allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) inp_cur => associate_field_FD_1D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n call opr % set ( 1_I_P + i_row_offset , 1_I_P + i_col_offset , invd ) do i = 2 , n - 1 call opr % set ( i + i_row_offset , i + i_col_offset , - 2._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset - 1 , 1._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset + 1 , 1._R_P * invd ) enddo call opr % set ( n + i_row_offset , n + i_col_offset , invd ) end function operate end module openpde_f2m_d2_FD_1D","tags":"","loc":"sourcefile/openpde_f2m_d2_fd_1d.f90.html","title":"openpde_f2m_d2_FD_1D.f90 – openpde"},{"text":"Abstract class of matrix operator of first derivative. This File Depends On sourcefile~~openpde_f2m_d1_abstract.f90~~EfferentGraph sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_f2m_d1_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_d1_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_d1_abstract.f90~~AfferentGraph sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_d1_abstract Source Code openpde_f2m_d1_abstract.f90 Source Code !< Abstract class of matrix operator of first derivative. module openpde_f2m_d1_abstract !< Abstract class of matrix operator of first derivative. use openpde_matrix_abstract use openpde_f2m_abstract implicit none private public :: f2m_d1 type , abstract , extends ( f2m ) :: f2m_d1 !< Abstract class of matrix operator of first derivative. endtype f2m_d1 end module openpde_f2m_d1_abstract","tags":"","loc":"sourcefile/openpde_f2m_d1_abstract.f90.html","title":"openpde_f2m_d1_abstract.f90 – openpde"},{"text":"Concrete class of field to matrix (implicit) second derivative operator for FD 1D This File Depends On sourcefile~~openpde_f2m_d1_fd_1d.f90~~EfferentGraph sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 var pansourcefileopenpde_f2m_d1_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_d1_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_d1_fd_1d.f90~~AfferentGraph sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_d1_FD_1D Source Code openpde_f2m_d1_FD_1D.f90 Source Code !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D module openpde_f2m_d1_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D use openpde_field_abstract use openpde_f2m_d1_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D use openpde_matrix_abstract implicit none private public :: f2m_d1_FD_1D type , extends ( f2m_d1 ) :: f2m_d1_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d1_FD_1D contains function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. real ( R_P ) :: invd !< Temporary 1/D**2 integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp ( i_equ_ )% m ) n = mesh_cur % n n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invd = 1._R_P / ( 2._R_P * mesh_cur % h ) allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) inp_cur => associate_field_FD_1D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n call opr % set ( 1_I_P + i_row_offset , 1_I_P + i_col_offset , invd ) do i = 2 , n - 1 call opr % set ( i + i_row_offset , i + i_col_offset - 1 , - 1._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset + 1 , 1._R_P * invd ) enddo call opr % set ( n + i_row_offset , n + i_col_offset , invd ) end function operate end module openpde_f2m_d1_FD_1D","tags":"","loc":"sourcefile/openpde_f2m_d1_fd_1d.f90.html","title":"openpde_f2m_d1_FD_1D.f90 – openpde"},{"text":"Abstract class of matrix operator of second derivative. This File Depends On sourcefile~~openpde_f2m_d2_abstract.f90~~EfferentGraph sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_f2m_d2_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_d2_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_d2_abstract.f90~~AfferentGraph sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_d2_abstract Source Code openpde_f2m_d2_abstract.f90 Source Code !< Abstract class of matrix operator of second derivative. module openpde_f2m_d2_abstract !< Abstract class of matrix operator of second derivative. use openpde_matrix_abstract use openpde_f2m_abstract implicit none private public :: f2m_d2 type , abstract , extends ( f2m ) :: f2m_d2 !< Abstract class of matrix operator of second derivative. endtype f2m_d2 end module openpde_f2m_d2_abstract","tags":"","loc":"sourcefile/openpde_f2m_d2_abstract.f90.html","title":"openpde_f2m_d2_abstract.f90 – openpde"},{"text":"Concrete class of field to matrix (implicit) second derivative operator for FD 1D This File Depends On sourcefile~~openpde_f2m_d2_fd_2d.f90~~EfferentGraph sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 var pansourcefileopenpde_f2m_d2_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_d2_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_d2_fd_2d.f90~~AfferentGraph sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_d2_FD_2D Source Code openpde_f2m_d2_FD_2D.f90 Source Code !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D module openpde_f2m_d2_FD_2D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D use openpde_field_abstract use openpde_f2m_d2_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D use openpde_matrix_abstract implicit none private public :: f2m_d2_FD_2D type , extends ( f2m_d2 ) :: f2m_d2_FD_2D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d2_FD_2D contains function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i , j !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. real ( R_P ) :: invd !< Temporary 1/D**2 real ( R_P ) :: invdx !< Temporary 1/D**2 real ( R_P ) :: invdy !< Temporary 1/D**2 integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset integer ( I_P ) :: i_dir_offset integer ( I_P ) :: i_vec dir_ = 1 ; if ( present ( dir )) dir_ = dir i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp ( i_equ_ )% m ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invdx = 1._R_P / mesh_cur % hx ** 2 invdy = 1._R_P / mesh_cur % hy ** 2 allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n if ( dir_ == 1 ) then i_dir_offset = 1 invd = invdx endif if ( dir_ == 2 ) then i_dir_offset = nx invd = invdy endif inp_cur => associate_field_FD_2D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) do j = 2 , ny - 1 do i = 2 , nx - 1 i_vec = ( j - 1 ) * nx + i call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset , - 2._R_P * invd ) call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset - i_dir_offset , 1._R_P * invd ) call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset + i_dir_offset , 1._R_P * invd ) enddo enddo end function operate end module openpde_f2m_d2_FD_2D","tags":"","loc":"sourcefile/openpde_f2m_d2_fd_2d.f90.html","title":"openpde_f2m_d2_FD_2D.f90 – openpde"},{"text":"Abstract class of f2m (field to matrix) operator. This File Depends On sourcefile~~openpde_f2m_abstract.f90~~EfferentGraph sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_f2m_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2m_abstract.f90~~AfferentGraph sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 var pansourcefileopenpde_f2m_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_f2m_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2m_abstract Source Code openpde_f2m_abstract.f90 Source Code !< Abstract class of f2m (field to matrix) operator. module openpde_f2m_abstract !< Abstract class of f2m (field to matrix) operator. use openpde_field_abstract use openpde_matrix_abstract use openpde_kinds implicit none private public :: f2m type , abstract :: f2m !< Abstract class of f2m operator. character ( len = :), allocatable :: description !< Operator description. class ( matrix ), allocatable :: mat !< Matrix used only to decide the type contains ! deferred public methods procedure ( abstract_operate ), deferred :: operate !< Operator function. endtype f2m abstract interface !< Operator operation. function abstract_operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator function. import :: I_P , f2m , field , matrix class ( f2m ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), dimension (:), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator as f(u)=A*u integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. integer ( I_P ), intent ( in ), optional :: i_equ !< Direction of operation. integer ( I_P ), intent ( in ), optional :: i_fie !< Direction of operation. end function abstract_operate endinterface end module openpde_f2m_abstract","tags":"","loc":"sourcefile/openpde_f2m_abstract.f90.html","title":"openpde_f2m_abstract.f90 – openpde"},{"text":"Abstract class of integrator. This File Depends On sourcefile~~openpde_integrator_adv_abstract.f90~~EfferentGraph sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 var pansourcefileopenpde_integrator_adv_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_adv_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_adv_abstract.f90~~AfferentGraph sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_adv_abstract Source Code openpde_integrator_adv_abstract.f90 Source Code !< Abstract class of integrator. module openpde_integrator_adv_abstract !< Abstract class of integrator. use openpde_field_abstract use openpde_equation_adv use openpde_kinds implicit none private public :: integrator_adv type , abstract :: integrator_adv !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator_adv abstract interface !< Initialize integrator. subroutine abstract_init ( this , equ , description , filename , error ) !< Initialize integrator. import :: I_P , integrator_adv , equation_adv class ( integrator_adv ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Integrate the field accordingly the equation. function abstract_integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly to the equation. import :: equation_adv , field , integrator_adv , I_P , R_P class ( integrator_adv ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target , dimension (:) :: inp !< Input field. integer ( I_P ) :: error !< Error status. end function abstract_integrate endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator_adv ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_integrator_adv_abstract","tags":"","loc":"sourcefile/openpde_integrator_adv_abstract.f90.html","title":"openpde_integrator_adv_abstract.f90 – openpde"},{"text":"Concrete class of integrator, Euler explicit scheme. This File Depends On sourcefile~~openpde_integrator_adv_euler_implicit.f90~~EfferentGraph sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 var pansourcefileopenpde_integrator_adv_euler_implicitf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_adv_euler_implicitf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_adv_euler_implicit.f90~~AfferentGraph sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_adv_euler_implicit Source Code openpde_integrator_adv_euler_implicit.f90 Source Code !< Concrete class of integrator, Euler explicit scheme. module openpde_integrator_adv_euler_implicit !< Concrete class of integrator, Euler explicit scheme. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_equation_adv use openpde_field_abstract use openpde_matrix_abstract use openpde_vector_abstract use openpde_integrator_adv_abstract use openpde_kinds use openpde_field_FD_1D implicit none private public :: integrator_adv_euler_implicit type , extends ( integrator_adv ) :: integrator_adv_euler_implicit !< Concrete class of integrator, Euler implicit scheme. real ( R_P ) :: alpha class ( matrix ), allocatable :: matA class ( vector ), allocatable :: vecB , vecS class ( matrix ), allocatable :: mat_identity contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_euler_implicit contains ! deferred public methods subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: n integer ( I_P ) :: i n = equ % n_size call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.005_R_P if ( present ( error )) error = 0 endif this % alpha = 0._R_P allocate ( this % matA , mold = equ % solver % mat ) allocate ( this % vecB , mold = equ % solver % vec ) allocate ( this % vecS , mold = equ % solver % sol ) call this % matA % init ( n ) call this % vecB % init ( n ) call this % vecS % init ( n ) allocate ( this % mat_identity , mold = equ % solver % mat ) call this % mat_identity % init ( n ) do i = 1 , this % mat_identity % n call this % mat_identity % set ( i , i , 1._R_P ) enddo !call this%mat_identity%output(\"identity.dat\") end subroutine init function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation definition. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp (:) !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary class ( field_FD_1D ), pointer :: inp_cur (:) !< Field input pointer. class ( field_FD_1D ), pointer :: fields (:,:) !< Fields pointer to MG fields. class ( field_FD_1D ), pointer :: fields0 (:,:) !< Initial fields pointer to MG fields. class ( field_FD_1D ), pointer :: residuals (:,:) !< Residual field pointer to MG fields. class ( field_FD_1D ), pointer :: sources (:,:) !< Sources field pointer to MG fields. class ( field_FD_1D ), pointer :: tau (:,:) !< Field input pointer. integer ( I_P ) :: ie !< Counter. integer ( I_P ) :: iv !< Counter. integer ( I_P ) :: n_levels !< Counter. integer ( I_P ) :: i_mg !< Counter. integer ( I_P ) :: i_up !< Counter. integer ( I_P ) :: i_down !< Counter. if ( equ % enable_explicit ) then !print*,'Explicit solver enabled' ! (1a) Imposes boundary conditions: modify \"inp\" field array call equ % bc_e ( inp = inp , t = t ) ! (1b) Computes the residual term: modify \"equ%resvar_e\" call equ % resid_e ( inp = inp , t = t ) ! (1c) Updates the inp field according to Euler scheme do ie = 1 , size ( inp ) inp ( ie ) = inp ( ie ) + this % dt * equ % resvar_e ( ie ) enddo endif if ( equ % enable_implicit ) then !print*,'Implicit solver enabled' ! (2a) Computes the residual term: modify \"equ%resvar_i\" call equ % resid_i ( inp = inp , t = t ) ! (2b) Compute the linear solver matrix and vector this % matA = this % mat_identity - this % dt * equ % resvar_i !this%matA = this%mat_identity - ((1._R_P-this%alpha)*this%dt) * equ%resvar_i this % vecB = equ % f2v_opr % operate ( inp ) ! (2c) Impose boundary conditions call equ % bc_i ( matA = this % matA , vecB = this % vecB , t = t ) !          call this%matA%output(\"matA.dat\") !          call this%vecB%output(\"vecB.dat\") ! (2d) Assign solver vector and matrix (A and b of A*x=b) call equ % solver % set_vector ( this % vecB ) call equ % solver % set_matrix ( this % matA ) ! (2e) Solve linear system call equ % solver % solve () ! (2f) Assign the solution to the input field this % vecS = equ % solver % sol !          call this%vecS%output(\"vecS.dat\") call equ % v2f_opr % operate ( this % vecS , inp ) endif if ( equ % enable_multigrid ) then n_levels = equ % mg % levels_number inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) tau => associate_field_FD_1D ( field_input = equ % mg % tau , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields => associate_field_FD_1D ( field_input = equ % mg % fields , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields0 => associate_field_FD_1D ( field_input = equ % mg % fields0 , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) residuals => associate_field_FD_1D ( field_input = equ % mg % residuals , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) sources => associate_field_FD_1D ( field_input = equ % mg % sources , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) do ie = 1 , equ % n_equ fields ( ie , 1 ) = inp_cur ( ie ) enddo !  du ! ---- + R(u) = 0 !  dt ! Start multigrid v-cycle v_cycle : do iv = 1 , equ % mg % max_iterations ! Iterations for actual grid (fine grid) - Smoothing iteration i_mg = 1 do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! R(u) evaluation call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Check convergence ! equ%mg%norm = equ%mg%compute_norm(residuals(:,i_mg)) ! TODO implement norm print * , \"iv, Multigrid convergence norm: \" , iv , equ % mg % norm if ( equ % mg % norm <= equ % mg % tolerance ) then print * , \"iv, Convergence reached: \" , iv exit v_cycle endif ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo ! Iterations for nested grids (coarse grids) - downward do i_mg = 2 , n_levels ! Tasks: ! (1) Approximation of coarse grid solution ! (2) Source term evaluation ! Restriction of solution fine => coarse ! fields(:,i_mg) = equ%mg%restriction(fields(:,i_mg-1)) ! TODO implement resistriction ! Save restriction do ie = 1 , equ % n_equ fields0 ( ie , i_mg ) = fields ( ie , i_mg ) enddo ! Collect residuals fine => coarse ! sources(:,i_mg) = equ%mg%collect(residuals(:,i_mg-1)) ! TODO implement collect ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Compute source term for coarse grid do ie = 1 , equ % n_equ sources ( ie , i_mg ) = sources ( ie , i_mg ) - residuals ( ie , i_mg ) enddo ! Tasks: ! (1) Smoothing iteration: new estimate computation !--------------------------------------------------------------------------- do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo do i_mg = n_levels - 1 , 2 , - 1 ! Tasks: ! (1) Correction estimation ! (2) Prolungation ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields is the correction enddo ! Prolongation coarse => fine ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation ! Tasks: ! (1) Smoothing iteration: new estimate computation do i_down = 1 , equ % mg % n_it_down ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo i_mg = 1 ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields correction enddo ! Prolungation to finest grid ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation enddo v_cycle do ie = 1 , size ( inp , dim = 1 ) inp_cur ( ie ) = fields ( ie , 1 ) enddo endif error = 0 end function integrate ! private methods subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json end module openpde_integrator_adv_euler_implicit","tags":"","loc":"sourcefile/openpde_integrator_adv_euler_implicit.f90.html","title":"openpde_integrator_adv_euler_implicit.f90 – openpde"},{"text":"Concrete class of integrator, Euler explicit scheme. This File Depends On sourcefile~~openpde_integrator_adv_euler_explicit.f90~~EfferentGraph sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 var pansourcefileopenpde_integrator_adv_euler_explicitf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_adv_euler_explicitf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_adv_euler_explicit.f90~~AfferentGraph sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_adv_euler_explicit Source Code openpde_integrator_adv_euler_explicit.f90 Source Code !< Concrete class of integrator, Euler explicit scheme. module openpde_integrator_adv_euler_explicit !< Concrete class of integrator, Euler explicit scheme. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_equation_adv use openpde_field_abstract use openpde_integrator_adv_abstract use openpde_kinds implicit none private public :: integrator_adv_euler_explicit type , extends ( integrator_adv ) :: integrator_adv_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_euler_explicit contains ! deferred public methods subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. use openpde_field_FD_1D class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target , dimension (:) :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary integer ( I_P ) :: ie !< Count equation ! Imposes boundary conditions: modify \"inp\" field array call equ % bc_e ( inp = inp , t = t ) !allocate(for(size(inp)), mold=inp(1)) !do ie=1,size(inp) !    call for(ie)%init(field_mesh=inp(1)%m) !enddo ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? !associate(for1 => for(1)) !    select type(for1) !        type is(field_FD_1D) !            print*,\"size of for1: \",size(for1%val) !    end select !endassociate ! Computes the residual term: modify \"equ%resvar_e\" call equ % resid_e ( inp = inp , t = t ) ! Updates the inp field according to Euler scheme do ie = 1 , size ( inp ) inp ( ie ) = inp ( ie ) + this % dt * equ % resvar_e ( ie ) enddo !RIMETTERE for = equ%resid_e(inp=inp, t=t) !RIMETTERE inp = inp + this%dt * for error = 0 end function integrate ! private methods subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json end module openpde_integrator_adv_euler_explicit","tags":"","loc":"sourcefile/openpde_integrator_adv_euler_explicit.f90.html","title":"openpde_integrator_adv_euler_explicit.f90 – openpde"},{"text":"Concrete class of integrator, Euler explicit scheme. This File Depends On sourcefile~~openpde_integrator_adv_rk_implicit.f90~~EfferentGraph sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 var pansourcefileopenpde_integrator_adv_rk_implicitf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_adv_rk_implicitf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_adv_rk_implicit.f90~~AfferentGraph sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_adv_rk_implicit Source Code openpde_integrator_adv_rk_implicit.f90 Source Code !< Concrete class of integrator, Euler explicit scheme. module openpde_integrator_adv_rk_implicit !< Concrete class of integrator, Euler explicit scheme. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_equation_adv use openpde_field_abstract use openpde_matrix_abstract use openpde_vector_abstract use openpde_integrator_adv_abstract use openpde_kinds use openpde_field_FD_1D implicit none private public :: integrator_adv_rk_implicit type , extends ( integrator_adv ) :: integrator_adv_rk_implicit !< Concrete class of integrator, Euler implicit scheme. real ( R_P ) :: alpha class ( matrix ), allocatable :: matA class ( vector ), allocatable :: vecB , vecS class ( matrix ), allocatable :: mat_identity integer ( I_P ) :: n_stages real ( R_P ), allocatable :: rk_alph (:,:) real ( R_P ), allocatable :: rk_beta (:) real ( R_P ), allocatable :: rk_gamm (:) class ( field ), allocatable :: stages (:,:) contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_rk_implicit contains ! deferred public methods subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: n integer ( I_P ) :: i this % n_stages = 5 allocate ( this % rk_alph ( this % n_stages , this % n_stages )) allocate ( this % rk_beta ( this % n_stages )) allocate ( this % rk_gamm ( this % n_stages )) this % rk_alph (:,:) = 0._R_P this % rk_beta (:) = 0._R_P this % rk_gamm (:) = 0._R_P allocate ( this % stages ( this % n_stages , equ % n_equ ), mold = equ % resvar_e ( 1 )) select case ( this % n_stages ) case ( 1 ) ! RK(1,1) Forward-Euler this % rk_beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) this % rk_beta ( 1 ) = 0.5_R_P this % rk_beta ( 2 ) = 0.5_R_P this % rk_alph ( 2 , 1 ) = 1._R_P this % rk_gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) this % rk_beta ( 1 ) = 1._R_P / 6._R_P this % rk_beta ( 2 ) = 1._R_P / 6._R_P this % rk_beta ( 3 ) = 2._R_P / 3._R_P this % rk_alph ( 2 , 1 ) = 1._R_P this % rk_alph ( 3 , 1 ) = 0.25_R_P this % rk_alph ( 3 , 2 ) = 0.25_R_P this % rk_gamm ( 2 ) = 1._R_P this % rk_gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) this % rk_beta ( 1 ) = 0.14681187618661_R_P this % rk_beta ( 2 ) = 0.24848290924556_R_P this % rk_beta ( 3 ) = 0.10425883036650_R_P this % rk_beta ( 4 ) = 0.27443890091960_R_P this % rk_beta ( 5 ) = 0.22600748319395_R_P this % rk_alph ( 2 , 1 ) = 0.39175222700392_R_P this % rk_alph ( 3 , 1 ) = 0.21766909633821_R_P this % rk_alph ( 3 , 2 ) = 0.36841059262959_R_P this % rk_alph ( 4 , 1 ) = 0.08269208670950_R_P this % rk_alph ( 4 , 2 ) = 0.13995850206999_R_P this % rk_alph ( 4 , 3 ) = 0.25189177424738_R_P this % rk_alph ( 5 , 1 ) = 0.06796628370320_R_P this % rk_alph ( 5 , 2 ) = 0.11503469844438_R_P this % rk_alph ( 5 , 3 ) = 0.20703489864929_R_P this % rk_alph ( 5 , 4 ) = 0.54497475021237_R_P this % rk_gamm ( 2 ) = 0.39175222700392_R_P this % rk_gamm ( 3 ) = 0.58607968896780_R_P this % rk_gamm ( 4 ) = 0.47454236302687_R_P this % rk_gamm ( 5 ) = 0.93501063100924_R_P endselect n = equ % n_size call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.0005_R_P if ( present ( error )) error = 0 endif this % alpha = 0._R_P allocate ( this % matA , mold = equ % solver % mat ) allocate ( this % vecB , mold = equ % solver % vec ) allocate ( this % vecS , mold = equ % solver % sol ) call this % matA % init ( n ) call this % vecB % init ( n ) call this % vecS % init ( n ) allocate ( this % mat_identity , mold = equ % solver % mat ) call this % mat_identity % init ( n ) do i = 1 , this % mat_identity % n call this % mat_identity % set ( i , i , 1._R_P ) enddo !call this%mat_identity%output(\"identity.dat\") end subroutine init function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation definition. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp (:) !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary class ( field_FD_1D ), pointer :: inp_cur (:) !< Field input pointer. class ( field_FD_1D ), pointer :: fields (:,:) !< Fields pointer to MG fields. class ( field_FD_1D ), pointer :: fields0 (:,:) !< Initial fields pointer to MG fields. class ( field_FD_1D ), pointer :: residuals (:,:) !< Residual field pointer to MG fields. class ( field_FD_1D ), pointer :: sources (:,:) !< Sources field pointer to MG fields. class ( field_FD_1D ), pointer :: tau (:,:) !< Field input pointer. integer ( I_P ) :: ie !< Counter. integer ( I_P ) :: iv !< Counter. integer ( I_P ) :: n_levels !< Counter. integer ( I_P ) :: i_mg !< Counter. integer ( I_P ) :: i_up !< Counter. integer ( I_P ) :: i_down !< Counter. integer ( I_P ) :: s integer ( I_P ) :: ss if ( equ % enable_explicit ) then do s = 1 , this % n_stages do ie = 1 , size ( inp ) this % stages ( s , ie ) = inp ( ie ) enddo do ie = 1 , size ( inp ) do ss = 1 , s - 1 this % stages ( s , ie ) = this % stages ( s , ie ) + this % stages ( ss , ie ) * ( this % dt * this % rk_alph ( s , ss )) enddo enddo call equ % bc_e ( inp = this % stages ( s ,:), t = t ) call equ % resid_e ( inp = this % stages ( s ,:), t = t ) do ie = 1 , size ( inp ) this % stages ( s , ie ) = equ % resvar_e ( ie ) enddo enddo ! computing new time step do ie = 1 , size ( inp ) do s = 1 , this % n_stages inp ( ie ) = inp ( ie ) + this % stages ( s , ie ) * ( this % dt * this % rk_beta ( s )) enddo enddo endif if ( equ % enable_implicit ) then STOP \"rk implicit to be implemented\" !print*,'Implicit solver enabled' ! (2a) Computes the residual term: modify \"equ%resvar_i\" call equ % resid_i ( inp = inp , t = t ) ! (2b) Compute the linear solver matrix and vector this % matA = this % mat_identity - this % dt * equ % resvar_i !this%matA = this%mat_identity - ((1._R_P-this%alpha)*this%dt) * equ%resvar_i this % vecB = equ % f2v_opr % operate ( inp ) ! (2c) Impose boundary conditions call equ % bc_i ( matA = this % matA , vecB = this % vecB , t = t ) !          call this%matA%output(\"matA.dat\") !          call this%vecB%output(\"vecB.dat\") ! (2d) Assign solver vector and matrix (A and b of A*x=b) call equ % solver % set_vector ( this % vecB ) call equ % solver % set_matrix ( this % matA ) ! (2e) Solve linear system call equ % solver % solve () ! (2f) Assign the solution to the input field this % vecS = equ % solver % sol !          call this%vecS%output(\"vecS.dat\") call equ % v2f_opr % operate ( this % vecS , inp ) endif if ( equ % enable_multigrid ) then STOP \"rk mg to be implemented\" n_levels = equ % mg % levels_number inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) tau => associate_field_FD_1D ( field_input = equ % mg % tau , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields => associate_field_FD_1D ( field_input = equ % mg % fields , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields0 => associate_field_FD_1D ( field_input = equ % mg % fields0 , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) residuals => associate_field_FD_1D ( field_input = equ % mg % residuals , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) sources => associate_field_FD_1D ( field_input = equ % mg % sources , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) do ie = 1 , equ % n_equ fields ( ie , 1 ) = inp_cur ( ie ) enddo !  du ! ---- + R(u) = 0 !  dt ! Start multigrid v-cycle v_cycle : do iv = 1 , equ % mg % max_iterations ! Iterations for actual grid (fine grid) - Smoothing iteration i_mg = 1 do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! R(u) evaluation call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Check convergence ! equ%mg%norm = equ%mg%compute_norm(residuals(:,i_mg)) ! TODO implement norm print * , \"iv, Multigrid convergence norm: \" , iv , equ % mg % norm if ( equ % mg % norm <= equ % mg % tolerance ) then print * , \"iv, Convergence reached: \" , iv exit v_cycle endif ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo ! Iterations for nested grids (coarse grids) - downward do i_mg = 2 , n_levels ! Tasks: ! (1) Approximation of coarse grid solution ! (2) Source term evaluation ! Restriction of solution fine => coarse ! fields(:,i_mg) = equ%mg%restriction(fields(:,i_mg-1)) ! TODO implement resistriction ! Save restriction do ie = 1 , equ % n_equ fields0 ( ie , i_mg ) = fields ( ie , i_mg ) enddo ! Collect residuals fine => coarse ! sources(:,i_mg) = equ%mg%collect(residuals(:,i_mg-1)) ! TODO implement collect ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Compute source term for coarse grid do ie = 1 , equ % n_equ sources ( ie , i_mg ) = sources ( ie , i_mg ) - residuals ( ie , i_mg ) enddo ! Tasks: ! (1) Smoothing iteration: new estimate computation !--------------------------------------------------------------------------- do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo do i_mg = n_levels - 1 , 2 , - 1 ! Tasks: ! (1) Correction estimation ! (2) Prolungation ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields is the correction enddo ! Prolongation coarse => fine ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation ! Tasks: ! (1) Smoothing iteration: new estimate computation do i_down = 1 , equ % mg % n_it_down ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo i_mg = 1 ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields correction enddo ! Prolungation to finest grid ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation enddo v_cycle do ie = 1 , size ( inp , dim = 1 ) inp_cur ( ie ) = fields ( ie , 1 ) enddo endif error = 0 end function integrate ! private methods subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"rk implicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"rk implicit\"!' stop endif endsubroutine load_from_json end module openpde_integrator_adv_rk_implicit","tags":"","loc":"sourcefile/openpde_integrator_adv_rk_implicit.f90.html","title":"openpde_integrator_adv_rk_implicit.f90 – openpde"},{"text":"Concrete class of vector, naive. This File Depends On sourcefile~~openpde_vector_simple.f90~~EfferentGraph sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_vector_simple.f90~~AfferentGraph sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_vector_simple Source Code openpde_vector_simple.f90 Source Code !< Concrete class of vector, naive. module openpde_vector_simple !< Concrete class of vector, naive. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_vector_abstract use openpde_kinds implicit none private public :: associate_vector_simple , vector_simple type , extends ( vector ) :: vector_simple !< Naive vector (not sparse) real ( R_P ), dimension (:), allocatable :: val !< Vector values contains ! deferred public methods procedure :: init procedure :: output procedure :: set procedure :: get ! deferred private methods procedure , private :: assign_vector endtype vector_simple contains ! public, non TBP function associate_vector_simple ( vector_input , emsg ) result ( vector_pointer ) !< Check the type of the vector passed as input and return a vector pointer with type vector_simple class ( vector ), intent ( in ), target :: vector_input !< Input vector. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( vector_simple ), pointer :: vector_pointer !< Simple vector pointer. select type ( vector_input ) type is ( vector_simple ) vector_pointer => vector_input class default write ( stderr , '(A)' ) 'error: cast vector to vector_simple' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_vector_simple subroutine assign_vector ( lhs , rhs ) !< Assignment overloading. class ( vector_simple ), intent ( inout ) :: lhs !< Left hand side. class ( vector ), intent ( in ), target :: rhs !< Right hand side. class ( vector_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_vector_simple ( vector_input = rhs , emsg = 'calling procedure vector_simple%assign_vector' ) lhs % val = rhs_cur % val !TODO automatic lhs%val allocation can occur here, is it ok? end subroutine assign_vector subroutine init ( this , n , description , error ) !< Initialize vector. class ( vector_simple ), intent ( inout ) :: this !< The vector. integer ( I_P ), intent ( in ) :: n !< Vector number of elements. character ( * ), intent ( in ), optional :: description !< Vector description. integer ( I_P ), intent ( out ), optional :: error !< Error status. this % n = n allocate ( this % val ( n )) this % val (:) = 0._R_P !TODO might be avoided here end subroutine init subroutine output ( this , filename , error ) !< Print (naively) vector class ( vector_simple ), intent ( inout ) :: this !< The vector. character ( * ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Loop index open ( unit = 11 , file = filename ) do i = 1 , this % n write ( 11 , \"(G15.8)\" ) this % val ( i ) enddo close ( 11 ) end subroutine output subroutine set ( this , i , val ) !< Set vector value class ( vector_simple ), intent ( inout ) :: this !< The vector. real ( R_P ), intent ( in ) :: val !< Value to assign. integer ( I_P ), intent ( in ) :: i !< Vector index filled. this % val ( i ) = val end subroutine set function get ( this , i ) result ( val ) !< Get vector value class ( vector_simple ), intent ( in ) :: this !< The vector. integer ( I_P ), intent ( in ) :: i !< Vector index filled. real ( R_P ) :: val !< Value to assign. val = this % val ( i ) end function get end module openpde_vector_simple","tags":"","loc":"sourcefile/openpde_vector_simple.f90.html","title":"openpde_vector_simple.f90 – openpde"},{"text":"Abstract class of vector This File Depends On sourcefile~~openpde_vector_abstract.f90~~EfferentGraph sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_vector_abstract.f90~~AfferentGraph sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_vector_simple.f90 openpde_vector_simple.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_vector_simple.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_vector_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_vector_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_vector_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_vector_abstract Source Code openpde_vector_abstract.f90 Source Code !< Abstract class of vector module openpde_vector_abstract !< Abstract class of vector use openpde_kinds implicit none private public :: vector type , abstract :: vector !< Abstract class of vector character ( len = :), allocatable :: description !< Vector description. integer ( I_P ) :: n !< Vector size. contains ! deferred public methods procedure ( abstract_vectorinit ), deferred :: init !< Initilize vector. procedure ( abstract_vectoroutput ) , deferred :: output !< Output vector. procedure ( abstract_vectorset ) , deferred :: set !< Set vector element. procedure ( abstract_vectorget ) , deferred :: get !< Get vector element. ! deferred private methods procedure ( abstract_assign ) , private , deferred :: assign_vector !< Assign vector. ! public operators generic , public :: assignment ( = ) => assign_vector !< Operator `= overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype vector abstract interface !< Initialize vector. subroutine abstract_vectorinit ( this , n , description , error ) !< Initialize vector. import :: I_P , vector class ( vector ), intent ( inout ) :: this !< The vector. integer ( I_P ), intent ( in ) :: n !< Vector number of elements. character ( * ), intent ( in ), optional :: description !< Vector description. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_vectorinit endinterface abstract interface !< Output vector. subroutine abstract_vectoroutput ( this , filename , error ) !< Output vector. import :: I_P , vector class ( vector ), intent ( inout ) :: this !< The vector. character ( * ), intent ( in ) :: filename !< Output filename. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_vectoroutput endinterface abstract interface !< Set vector element. subroutine abstract_vectorset ( this , i , val ) !< Set vector element. import :: R_P , I_P , vector class ( vector ), intent ( inout ) :: this !< The vector. real ( R_P ), intent ( in ) :: val !< Value to be assigned integer ( I_P ), intent ( in ) :: i !< Index to set end subroutine abstract_vectorset endinterface abstract interface !< Get vector element. function abstract_vectorget ( this , i ) result ( val ) !< Set vector element. import :: R_P , I_P , vector class ( vector ), intent ( in ) :: this !< The vector. integer ( I_P ), intent ( in ) :: i !< Index to get real ( R_P ) :: val !< Value to be extracted end function abstract_vectorget endinterface abstract interface !< Assignment overloading. subroutine abstract_assign ( lhs , rhs ) !< Assignment overloading. import :: vector class ( vector ), intent ( inout ) :: lhs !< Left hand side. class ( vector ), intent ( in ), target :: rhs !< Right hand side. end subroutine abstract_assign endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( vector ), intent ( inout ) :: this !< The vector. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_vector_abstract","tags":"","loc":"sourcefile/openpde_vector_abstract.f90.html","title":"openpde_vector_abstract.f90 – openpde"},{"text":"Simil-abstract class of equation advanced. This File Depends On sourcefile~~openpde_equation_adv.f90~~EfferentGraph sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 var pansourcefileopenpde_equation_advf90EfferentGraph = svgPanZoom('#sourcefileopenpde_equation_advf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_equation_adv.f90~~AfferentGraph sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_equation_advf90AfferentGraph = svgPanZoom('#sourcefileopenpde_equation_advf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_equation_adv Source Code openpde_equation_adv.f90 Source Code !< Simil-abstract class of equation advanced. module openpde_equation_adv !< Simil-abstract class of equation advanced. use openpde_field_abstract use openpde_v2f_abstract use openpde_f2v_abstract use openpde_matrix_abstract use openpde_vector_abstract use openpde_mesh_abstract use openpde_multigrid_abstract use openpde_linsolver_abstract use openpde_kinds implicit none private public :: equation_adv type :: equation_adv !< Simil-abstract class of equation_adv. !< !< The really-concrete types are implemented at application level (by the user). character ( len = :), allocatable :: description !< Equation description. integer ( I_P ) :: n_equ = 0_I_P !< Number of equations class ( mesh ), pointer :: m !< Mesh pointer logical :: enable_explicit = . false . !< Activate explicit solver. logical :: enable_implicit = . false . !< Activate implicit solver. logical :: enable_multigrid = . false . !< Activate multigrid solver. ! Explicit section class ( field ), allocatable , dimension (:) :: resvar_e !< Residuals field for explicit solver. ! Implicit section integer ( I_P ) :: n_size !< Number of elements (vector size for linear solvers). class ( matrix ), allocatable :: resvar_i !< Residuals field for implicit solver. class ( linsolver ), allocatable :: solver !< Linear solver. class ( f2v ), allocatable :: f2v_opr !< Field to vector converter. class ( v2f ), allocatable :: v2f_opr !< Vector to Field converter. ! Multigrid section class ( multigrid ), allocatable :: mg !< Multigrid solver. class ( field ), allocatable , dimension (:) :: resvar_mg !< Residuals field for multigrid solver. class ( field ), allocatable , dimension (:) :: source_mg !< Sources field for multigrid solver. contains ! not deferred but to be implemented by concrete procedure :: bc_e !< Equation boundary conditions explicit. procedure :: bc_i !< Equation boundary conditions implicit. procedure :: init !< Initialize the equation. procedure :: jacobian !< Jacobian for multigrid solution procedure :: resid_e !< Residual explicit procedure :: resid_emg !< Residual for multigrid procedure :: resid_i !< Residual implicit ! public methods procedure :: free !< Free dynamic memory. endtype equation_adv contains subroutine init ( this , n_equ , field_mesh , inp , description , filename , error ) !< Initialize equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. integer ( I_P ), intent ( in ) :: n_equ !< Number of equations class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. class ( field ), intent ( inout ), target :: inp (:) !< Input field. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. STOP 'init to be implemented by your equation and depending on your integrator' end subroutine init subroutine bc_e ( this , inp , t ) !< Equation boundary condition. class ( equation_adv ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'bc_e to be implemented by your equation and depending on your integrator' end subroutine bc_e subroutine bc_i ( this , matA , vecB , t ) !< Equation boundary condition. class ( equation_adv ), intent ( in ) :: this !< The equation. class ( matrix ), intent ( inout ), target :: matA !< Input field. class ( vector ), intent ( inout ), target :: vecB !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'bc_i to be implemented by your equation and depending on your integrator' end subroutine bc_i subroutine resid_e ( this , inp , t ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_e to be implemented by your equation and depending on your integrator' end subroutine resid_e subroutine resid_emg ( this , inp , t , output ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. class ( field ), intent ( out ), target :: output (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_emg to be implemented by your equation and depending on your integrator' end subroutine resid_emg subroutine resid_i ( this , inp , t ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_i to be implemented by your equation and depending on your integrator' end subroutine resid_i function jacobian ( this , inp , t ) result ( opr ) !< Return the jacobian, useful for multigrid class ( equation_adv ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( matrix ), allocatable :: opr !< Field computed. STOP 'jacobian to be implemented by your equation and depending on your integrator' end function jacobian elemental subroutine free ( this ) !< Free dynamic memory. !< !< To be completed. class ( equation_adv ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_equation_adv","tags":"","loc":"sourcefile/openpde_equation_adv.f90.html","title":"openpde_equation_adv.f90 – openpde"},{"text":"Concrete class of spatial operator of second derivative for Finite Difference 2D methods. This File Depends On sourcefile~~openpde_spatial_operator_d2_fd_2d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 var pansourcefileopenpde_spatial_operator_d2_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d2_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d2_fd_2d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d2_FD_2D Source Code openpde_spatial_operator_d2_FD_2D.f90 Source Code !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. module openpde_spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. use openpde_field_abstract use openpde_spatial_operator_d2_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: spatial_operator_d2_FD_2D type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_2D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) inp_cur => associate_field_FD_2D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - 2._R_P * inp_cur % val ( i , :) + inp_cur % val ( i - 1 , :)) / ( mesh_cur % hx ** 2 ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - 2._R_P * inp_cur % val (:, j ) + inp_cur % val (:, j - 1 )) / ( mesh_cur % hy ** 2 ) enddo endif end function operate end module openpde_spatial_operator_d2_FD_2D","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_fd_2d.f90.html","title":"openpde_spatial_operator_d2_FD_2D.f90 – openpde"},{"text":"Abstract class of spatial operator of second derivative. This File Depends On sourcefile~~openpde_spatial_operator_d2_abstract.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_spatial_operator_d2_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d2_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d2_abstract.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d2_abstract Source Code openpde_spatial_operator_d2_abstract.f90 Source Code !< Abstract class of spatial operator of second derivative. module openpde_spatial_operator_d2_abstract !< Abstract class of spatial operator of second derivative. use openpde_spatial_operator_abstract implicit none private public :: spatial_operator_d2 type , abstract , extends ( spatial_operator ) :: spatial_operator_d2 !< Abstract class of spatial operator of second derivative. endtype spatial_operator_d2 end module openpde_spatial_operator_d2_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_abstract.f90.html","title":"openpde_spatial_operator_d2_abstract.f90 – openpde"},{"text":"Concrete class of spatial operator of first derivative for Finite Difference 2D methods. This File Depends On sourcefile~~openpde_spatial_operator_d1_fd_2d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 var pansourcefileopenpde_spatial_operator_d1_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d1_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d1_fd_2d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d1_FD_2D Source Code openpde_spatial_operator_d1_FD_2D.f90 Source Code !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. module openpde_spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. use openpde_field_abstract use openpde_spatial_operator_d1_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D implicit none private public :: spatial_operator_d1_FD_2D type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_2D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) inp_cur => associate_field_FD_2D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - inp_cur % val ( i , :)) / ( mesh_cur % hx ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - inp_cur % val (:, j )) / ( mesh_cur % hy ) enddo endif end function operate end module openpde_spatial_operator_d1_FD_2D","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_fd_2d.f90.html","title":"openpde_spatial_operator_d1_FD_2D.f90 – openpde"},{"text":"Concrete class of spatial operator of first derivative for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_spatial_operator_d1_fv_1d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 var pansourcefileopenpde_spatial_operator_d1_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d1_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d1_fv_1d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d1_FV_1D Source Code openpde_spatial_operator_d1_FV_1D.f90 Source Code !< Concrete class of spatial operator of first derivative for Finite Volume 1D methods. module openpde_spatial_operator_d1_FV_1D !< Concrete class of spatial operator of first derivative for Finite Volume 1D methods. use openpde_field_abstract use openpde_spatial_operator_d1_abstract use openpde_field_FV_1D use openpde_kinds use openpde_mesh_FV_1D implicit none private public :: spatial_operator_d1_FV_1D type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FV_1D !< Concrete class of spatial operator of first derivative for Finite Volume 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FV_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FV_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FV_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. integer ( I_P ) :: i !< Counter. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) inp_cur => associate_field_FV_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do b = 1 , mesh_cur % nb do i = 1 , mesh_cur % blocks ( b )% n opr_cur % blocks ( b )% val ( i ) = ( inp_cur % blocks ( b )% val ( i + 1 ) - inp_cur % blocks ( b )% val ( i )) / ( mesh_cur % blocks ( b )% h ) enddo enddo end function operate end module openpde_spatial_operator_d1_FV_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_fv_1d.f90.html","title":"openpde_spatial_operator_d1_FV_1D.f90 – openpde"},{"text":"Abstract class of spatial operator of first derivative. This File Depends On sourcefile~~openpde_spatial_operator_d1_abstract.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_spatial_operator_d1_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d1_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d1_abstract.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d1_abstract Source Code openpde_spatial_operator_d1_abstract.f90 Source Code !< Abstract class of spatial operator of first derivative. module openpde_spatial_operator_d1_abstract !< Abstract class of spatial operator of first derivative. use openpde_spatial_operator_abstract implicit none private public :: spatial_operator_d1 type , abstract , extends ( spatial_operator ) :: spatial_operator_d1 !< Abstract class of spatial operator of first derivative. endtype spatial_operator_d1 end module openpde_spatial_operator_d1_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_abstract.f90.html","title":"openpde_spatial_operator_d1_abstract.f90 – openpde"},{"text":"Abstract class of spatial operator. This File Depends On sourcefile~~openpde_spatial_operator_abstract.f90~~EfferentGraph sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_spatial_operator_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_abstract.f90~~AfferentGraph sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 var pansourcefileopenpde_spatial_operator_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_abstract Source Code openpde_spatial_operator_abstract.f90 Source Code !< Abstract class of spatial operator. module openpde_spatial_operator_abstract !< Abstract class of spatial operator. use openpde_field_abstract use openpde_kinds implicit none private public :: spatial_operator type , abstract :: spatial_operator !< Abstract class of spatial operator. character ( len = :), allocatable :: description !< Operator description. contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype spatial_operator abstract interface !< Operator operation. function abstract_operate ( this , inp , dir ) result ( opr ) !< Operator function. import :: spatial_operator , field , I_P class ( spatial_operator ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. end function abstract_operate endinterface end module openpde_spatial_operator_abstract","tags":"","loc":"sourcefile/openpde_spatial_operator_abstract.f90.html","title":"openpde_spatial_operator_abstract.f90 – openpde"},{"text":"Concrete class of spatial operator of second derivative for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_spatial_operator_d2_fv_1d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 var pansourcefileopenpde_spatial_operator_d2_fv_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d2_fv_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d2_fv_1d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d2_FV_1D Source Code openpde_spatial_operator_d2_FV_1D.f90 Source Code !< Concrete class of spatial operator of second derivative for Finite Volume 1D methods. module openpde_spatial_operator_d2_FV_1D !< Concrete class of spatial operator of second derivative for Finite Volume 1D methods. use openpde_field_abstract use openpde_spatial_operator_d2_abstract use openpde_field_FV_1D use openpde_kinds use openpde_mesh_FV_1D implicit none private public :: spatial_operator_d2_FV_1D type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FV_1D !< Concrete class of spatial operator of second derivative for Finite Volume 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FV_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FV_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FV_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. integer ( I_P ) :: i !< Counter. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) inp_cur => associate_field_FV_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do b = 1 , mesh_cur % nb do i = 1 , mesh_cur % blocks ( b )% n opr_cur % blocks ( b )% val ( i ) = ( inp_cur % blocks ( b )% val ( i + 1 ) - & 2._R_P * inp_cur % blocks ( b )% val ( i ) + & inp_cur % blocks ( b )% val ( i - 1 )) / ( mesh_cur % blocks ( b )% h ** 2 ) enddo enddo end function operate end module openpde_spatial_operator_d2_FV_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_fv_1d.f90.html","title":"openpde_spatial_operator_d2_FV_1D.f90 – openpde"},{"text":"Concrete class of spatial operator of first derivative for Finite Difference 1D methods. This File Depends On sourcefile~~openpde_spatial_operator_d1_fd_1d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 var pansourcefileopenpde_spatial_operator_d1_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d1_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d1_fd_1d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d1_FD_1D Source Code openpde_spatial_operator_d1_FD_1D.f90 Source Code !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. module openpde_spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. use openpde_field_abstract use openpde_spatial_operator_d1_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D implicit none private public :: spatial_operator_d1_FD_1D type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( mesh_cur % h ) enddo end function operate end module openpde_spatial_operator_d1_FD_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d1_fd_1d.f90.html","title":"openpde_spatial_operator_d1_FD_1D.f90 – openpde"},{"text":"Concrete class of spatial operator of second derivative for Finite Difference 1D methods. This File Depends On sourcefile~~openpde_spatial_operator_d2_fd_1d.f90~~EfferentGraph sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 var pansourcefileopenpde_spatial_operator_d2_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_spatial_operator_d2_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_spatial_operator_d2_fd_1d.f90~~AfferentGraph sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_spatial_operator_d2_FD_1D Source Code openpde_spatial_operator_d2_FD_1D.f90 Source Code !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. module openpde_spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. use openpde_field_abstract use openpde_spatial_operator_d2_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D implicit none private public :: spatial_operator_d2_FD_1D type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_1D contains function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - 2._R_P * inp_cur % val ( i ) + inp_cur % val ( i - 1 )) / ( mesh_cur % h ** 2 ) enddo end function operate end module openpde_spatial_operator_d2_FD_1D","tags":"","loc":"sourcefile/openpde_spatial_operator_d2_fd_1d.f90.html","title":"openpde_spatial_operator_d2_FD_1D.f90 – openpde"},{"text":"Concrete class of f2v (field to vector) for FD 1D This File Depends On sourcefile~~openpde_f2v_fd_1d.f90~~EfferentGraph sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 var pansourcefileopenpde_f2v_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2v_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2v_fd_1d.f90~~AfferentGraph sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2v_FD_1D Source Code openpde_f2v_FD_1D.f90 Source Code !< Concrete class of f2v (field to vector) for FD 1D module openpde_f2v_FD_1D !< Concrete class of f2v (field to vector) for FD 1D use openpde_field_abstract use openpde_f2v_abstract use openpde_field_FD_1D use openpde_kinds use openpde_mesh_FD_1D use openpde_vector_abstract implicit none private public :: f2v_FD_1D type , extends ( f2v ) :: f2v_FD_1D !< Concrete class of f2v (field to vector) for FD 1D contains procedure :: operate !< Operator operation. endtype f2v_FD_1D contains function operate ( this , fie ) result ( vec ) !< Operator operation. class ( f2v_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), dimension (:), target :: fie !< Input field. class ( vector ), allocatable :: vec !< Returned vector. class ( field_FD_1D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = size ( fie ) mesh_cur => associate_mesh_FD_1D ( mesh_input = fie ( 1 )% m , emsg = 'mesh' ) n = mesh_cur % n allocate ( vec , mold = this % vec ) call vec % init ( n * n_equ ) do i_equ = 1 , n_equ fie_cur => associate_field_FD_1D ( field_input = fie ( i_equ ), emsg = 'casting error' ) ! No concrete features of vector are used so dynamic casting is not needed do i = 1 , n i_vec = n * ( i_equ - 1 ) + i !    print*,\"i, fie_cur%val(i) :\",i, fie_cur%val(i) call vec % set ( i_vec , fie_cur % val ( i )) enddo enddo end function operate end module openpde_f2v_FD_1D","tags":"","loc":"sourcefile/openpde_f2v_fd_1d.f90.html","title":"openpde_f2v_FD_1D.f90 – openpde"},{"text":"Concrete class of f2v (field to vector) for FD 1D This File Depends On sourcefile~~openpde_f2v_fd_2d.f90~~EfferentGraph sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 var pansourcefileopenpde_f2v_fd_2df90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2v_fd_2df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2v_fd_2d.f90~~AfferentGraph sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2v_FD_2D Source Code openpde_f2v_FD_2D.f90 Source Code !< Concrete class of f2v (field to vector) for FD 1D module openpde_f2v_FD_2D !< Concrete class of f2v (field to vector) for FD 1D use openpde_field_abstract use openpde_f2v_abstract use openpde_field_FD_2D use openpde_kinds use openpde_mesh_FD_2D use openpde_vector_abstract implicit none private public :: f2v_FD_2D type , extends ( f2v ) :: f2v_FD_2D !< Concrete class of f2v (field to vector) for FD 1D contains procedure :: operate !< Operator operation. endtype f2v_FD_2D contains function operate ( this , fie ) result ( vec ) !< Operator operation. class ( f2v_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), dimension (:), target :: fie !< Input field. class ( vector ), allocatable :: vec !< Returned vector. class ( field_FD_2D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i , j !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = size ( fie ) mesh_cur => associate_mesh_FD_2D ( mesh_input = fie ( 1 )% m , emsg = 'mesh' ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny allocate ( vec , mold = this % vec ) call vec % init ( n * n_equ ) do i_equ = 1 , n_equ fie_cur => associate_field_FD_2D ( field_input = fie ( i_equ ), emsg = 'casting error' ) ! No concrete features of vector are used so dynamic casting is not needed do j = 1 , ny do i = 1 , nx i_vec = n * ( n_equ - 1 ) + ( j - 1 ) * nx + i !    print*,\"i, fie_cur%val(i) :\",i, fie_cur%val(i) call vec % set ( i_vec , fie_cur % val ( i , j )) enddo enddo enddo end function operate end module openpde_f2v_FD_2D","tags":"","loc":"sourcefile/openpde_f2v_fd_2d.f90.html","title":"openpde_f2v_FD_2D.f90 – openpde"},{"text":"Abstract class of f2v (field to vector). This File Depends On sourcefile~~openpde_f2v_abstract.f90~~EfferentGraph sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_vector_abstract.f90 openpde_vector_abstract.f90 sourcefile~openpde_vector_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_vector_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_f2v_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_f2v_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_f2v_abstract.f90~~AfferentGraph sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_f2v_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_f2v_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_f2v_abstract Source Code openpde_f2v_abstract.f90 Source Code !< Abstract class of f2v (field to vector). module openpde_f2v_abstract !< Abstract class of f2v (field to vector). use openpde_field_abstract use openpde_vector_abstract use openpde_kinds implicit none private public :: f2v type , abstract :: f2v !< Abstract class of f2v. class ( vector ), allocatable :: vec !< Vector used only to decide the type contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype f2v abstract interface !< Operator operation. function abstract_operate ( this , fie ) result ( vec ) !< Operator function. import :: I_P , f2v , field , vector class ( f2v ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target , dimension (:) :: fie !< Input field. class ( vector ), allocatable :: vec !< Resulting vector. end function abstract_operate endinterface end module openpde_f2v_abstract","tags":"","loc":"sourcefile/openpde_f2v_abstract.f90.html","title":"openpde_f2v_abstract.f90 – openpde"},{"text":"Concrete class of integrator, Euler explicit scheme. This File Depends On sourcefile~~openpde_integrator_euler_explicit.f90~~EfferentGraph sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_integrator_euler_explicitf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_euler_explicitf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_euler_explicit.f90~~AfferentGraph sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_euler_explicit Source Code openpde_integrator_euler_explicit.f90 Source Code !< Concrete class of integrator, Euler explicit scheme. module openpde_integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_equation_abstract use openpde_field_abstract use openpde_integrator_abstract use openpde_kinds implicit none private public :: integrator_euler_explicit type , extends ( integrator ) :: integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_euler_explicit contains ! deferred public methods subroutine init ( this , description , filename , error ) !< Initialize integrator. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. class ( integrator_euler_explicit ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary call equ % bc ( inp = inp , t = t ) allocate ( for , mold = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate ! private methods subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json end module openpde_integrator_euler_explicit","tags":"","loc":"sourcefile/openpde_integrator_euler_explicit.f90.html","title":"openpde_integrator_euler_explicit.f90 – openpde"},{"text":"Abstract class of integrator. This File Depends On sourcefile~~openpde_integrator_asbtract.f90~~EfferentGraph sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_integrator_asbtractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_integrator_asbtractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_integrator_asbtract.f90~~AfferentGraph sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_integrator_abstract Source Code openpde_integrator_asbtract.f90 Source Code !< Abstract class of integrator. module openpde_integrator_abstract !< Abstract class of integrator. use openpde_field_abstract use openpde_equation_abstract use openpde_kinds implicit none private public :: integrator type , abstract :: integrator !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator abstract interface !< Initialize integrator. subroutine abstract_init ( this , description , filename , error ) !< Initialize integrator. import :: I_P , integrator class ( integrator ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Integrate the field accordingly the equation. function abstract_integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly to the equation. import :: equation , field , integrator , I_P , R_P class ( integrator ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. end function abstract_integrate endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_integrator_abstract","tags":"","loc":"sourcefile/openpde_integrator_asbtract.f90.html","title":"openpde_integrator_asbtract.f90 – openpde"},{"text":"Concrete class of linsolver using LAPACK with general matrix. This File Depends On sourcefile~~openpde_multigrid_fd_1d.f90~~EfferentGraph sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 var pansourcefileopenpde_multigrid_fd_1df90EfferentGraph = svgPanZoom('#sourcefileopenpde_multigrid_fd_1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_multigrid_fd_1d.f90~~AfferentGraph sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_multigrid_FD_1D Source Code openpde_multigrid_FD_1D.f90 Source Code !< Concrete class of linsolver using LAPACK with general matrix. module openpde_multigrid_FD_1D !< Concrete class of linsolver using LAPACK with general matrix. use openpde_multigrid_abstract use openpde_field_abstract use openpde_mesh_FD_1D use openpde_kinds implicit none private public :: multigrid_FD_1D type , extends ( multigrid ) :: multigrid_FD_1D contains ! deferred public methods procedure :: create_subgrids_field !< Create subgrid-levels field. procedure :: init !< Init multigrid solver. endtype multigrid_FD_1D contains subroutine create_subgrids_field ( this , inp , subgrids ) !< Create subgrid-levels field. class ( multigrid_FD_1D ), intent ( in ), target :: this !< The solver. class ( field ), intent ( in ) :: inp (:) !< Input field on finest mesh. class ( field ), intent ( inout ) :: subgrids (:,:) !< Subgrid-levels field. integer ( I_P ) :: e !< Counter. integer ( I_P ) :: l !< Counter. do l = 1 , this % levels_number do e = 1 , size ( subgrids , dim = 1 ) subgrids ( e , l )% m => this % meshes ( l ) enddo enddo end subroutine create_subgrids_field subroutine init ( this , inp , levels_number ) !< Init multigrid solver. class ( multigrid_FD_1D ), intent ( inout ) :: this !< The solver. class ( field ), intent ( in ), target :: inp !< Input field on finest mesh. integer ( I_P ), intent ( in ) :: levels_number !< Number of MG levels. class ( mesh_FD_1D ), pointer :: mesh_finest !< Pointer to finest mesh. class ( mesh_FD_1D ), pointer :: mesh_mg (:) !< Pointer to MG meshes. integer ( I_P ) :: l !< Counter. integer ( I_P ) :: n_mg !< Counter. allocate ( this % meshes ( this % levels_number ), mold = inp % m ) mesh_finest => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure multigrid_FD_1D%init' ) mesh_mg => associate_mesh_FD_1D ( mesh_input = this % meshes , emsg = 'calling procedure multigrid_FD_1D%init' ) mesh_mg ( 1 ) = mesh_finest do l = 2 , this % levels_number n_mg = mesh_mg ( l - 1 )% n / 2 + 1 mesh_mg ( l )% n = n_mg mesh_mg ( l )% ng = mesh_mg ( l - 1 )% ng enddo end subroutine init end module openpde_multigrid_FD_1D","tags":"","loc":"sourcefile/openpde_multigrid_fd_1d.f90.html","title":"openpde_multigrid_FD_1D.f90 – openpde"},{"text":"Abstract class of multigrid solver. This File Depends On sourcefile~~openpde_multigrid_abstract.f90~~EfferentGraph sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_multigrid_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_multigrid_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_multigrid_abstract.f90~~AfferentGraph sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_multigrid_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_multigrid_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_multigrid_abstract Source Code openpde_multigrid_abstract.f90 Source Code !< Abstract class of multigrid solver. module openpde_multigrid_abstract !< Abstract class of multigrid solver. use openpde_field_abstract use openpde_mesh_abstract use openpde_kinds implicit none private public :: multigrid type , abstract :: multigrid !< Abstract class of multigrid solver. character ( len = :), allocatable :: description !< Description. class ( field ), allocatable :: fields (:,:) !< Field on each MG level. class ( mesh ), allocatable :: meshes (:) !< Meshes on each MG level. class ( field ), allocatable :: fields0 (:,:) !< Initial field on each MG level. class ( field ), allocatable :: residuals (:,:) !< Residual field on each MG level. class ( field ), allocatable :: sources (:,:) !< Source field on each MG level. integer ( I_P ) :: levels_number !< MG levels number. integer ( I_P ) :: max_iterations !< Maximum number of iterations. integer ( I_P ), allocatable :: n_it_up (:) !< Number of iteration in \"up\" cycle for each MG level. integer ( I_P ), allocatable :: n_it_down (:) !< Number of iteration in \"up\" cycle for each MG level. real ( R_P ), allocatable :: stability (:) !< Stability coefficient for each MG level. class ( field ), allocatable :: tau (:,:) !< Local pseudo-dt for each MG level. real ( R_P ) :: tolerance !< Tolerance on iterative convergence. real ( R_P ) :: norm !< Norm of residuals. contains ! deferred public methods procedure ( create_subgrids_field_interface ), deferred :: create_subgrids_field !< Create subgrid-levels field. procedure ( init_interface ), deferred :: init !< Init multigrid solver. ! procedure(abstract_prolungation), deferred :: prolongation ! procedure(abstract_restriction), deferred :: restriction ! procedure(abstract_collect), deferred :: collect ! procedure(abstract_smoother), deferred :: smoother endtype multigrid ! deferred public methods interfaces abstract interface !< Create subgrid-levels field. subroutine create_subgrids_field_interface ( this , inp , subgrids ) !< Create subgrid-levels field. import :: I_P , multigrid , field class ( multigrid ), intent ( in ), target :: this !< The solver. class ( field ), intent ( in ) :: inp (:) !< Input field on finest mesh. class ( field ), intent ( inout ) :: subgrids (:,:) !< Subgrid-levels field. end subroutine create_subgrids_field_interface endinterface abstract interface !< Init multigrid solver. subroutine init_interface ( this , inp , levels_number ) !< Init multigrid solver. import :: I_P , multigrid , field class ( multigrid ), intent ( inout ) :: this !< The solver. class ( field ), intent ( in ), target :: inp !< Input field on finest mesh. integer ( I_P ), intent ( in ) :: levels_number !< Levels number. end subroutine init_interface endinterface contains ! public methods elemental subroutine free ( this ) !< Free dynamic memory. class ( multigrid ), intent ( inout ) :: this !< The linsolver. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % fields )) deallocate ( this % fields ) if ( allocated ( this % meshes )) deallocate ( this % meshes ) if ( allocated ( this % fields0 )) deallocate ( this % fields0 ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) if ( allocated ( this % sources )) deallocate ( this % sources ) if ( allocated ( this % n_it_up )) deallocate ( this % n_it_up ) if ( allocated ( this % n_it_down )) deallocate ( this % n_it_down ) if ( allocated ( this % stability )) deallocate ( this % stability ) if ( allocated ( this % tau )) deallocate ( this % tau ) end subroutine free end module openpde_multigrid_abstract","tags":"","loc":"sourcefile/openpde_multigrid_abstract.f90.html","title":"openpde_multigrid_abstract.f90 – openpde"},{"text":"Abstract class of matrix. This File Depends On sourcefile~~openpde_matrix_abstract.f90~~EfferentGraph sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_matrix_abstract.f90~~AfferentGraph sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_linsolver_abstract.f90 openpde_linsolver_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_linsolver_abstract.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_matrix_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_matrix_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_matrix_abstract Source Code openpde_matrix_abstract.f90 Source Code !< Abstract class of matrix. module openpde_matrix_abstract !< Abstract class of matrix. use openpde_kinds implicit none private public :: matrix type , abstract :: matrix !< Abstract class of matrix. character ( len = :), allocatable :: description !< Matrix description. integer ( I_P ) :: n contains ! deferred public methods procedure ( abstract_matrixinit ), deferred :: init !< Initilize matrix. procedure ( abstract_matrixoutput ) , deferred :: output !< Output matrix. procedure ( abstract_matrixset ) , deferred :: set !< Set matrix value. ! deferred private methods procedure ( abstract_simmetric_operator ) , private , deferred :: add !< Add matrix. procedure ( abstract_simmetric_operator ) , private , deferred :: sub !< Sub matrix. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Real*matrix. procedure ( abstract_assign ) , private , deferred :: assign_matrix !< Assign matrix. ! public operators generic , public :: assignment ( = ) => assign_matrix !< Operator `=` overloading. generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( - ) => sub !< Operator `- overloading. generic , public :: operator ( * ) => realmul !< Operator `*` overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype matrix abstract interface !< Assignment overloading. function abstract_simmetric_operator ( lhs , rhs ) result ( opr ) !< Assignment overloading. import :: matrix class ( matrix ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Result end function abstract_simmetric_operator endinterface abstract interface function abstract_real_op_field ( lhs , rhs ) result ( opr ) !< Non symmetric operator real.op.field. import :: matrix , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ) :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. end function abstract_real_op_field endinterface abstract interface !< Assignment overloading. subroutine abstract_assign ( lhs , rhs ) !< Assignment overloading. import :: matrix class ( matrix ), intent ( inout ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. end subroutine abstract_assign endinterface abstract interface !< Initialize mesh. subroutine abstract_matrixinit ( this , n , description , error ) !< Initialize mesh. import :: I_P , matrix class ( matrix ), intent ( inout ) :: this !< The matrix. integer ( I_P ) :: n !< Initialization file name. character ( * ), intent ( in ), optional :: description !< Mesh description. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_matrixinit endinterface abstract interface !< Initialize mesh. subroutine abstract_matrixoutput ( this , filename , error ) !< Initialize mesh. import :: I_P , matrix class ( matrix ), intent ( inout ) :: this !< The matrix. character ( * ), intent ( in ) :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_matrixoutput endinterface abstract interface !< Initialize mesh. subroutine abstract_matrixset ( this , i , j , val ) !< Initialize mesh. import :: R_P , I_P , matrix class ( matrix ), intent ( inout ) :: this real ( R_P ), intent ( in ) :: val integer ( I_P ), intent ( in ) :: i , j end subroutine abstract_matrixset endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( matrix ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_matrix_abstract","tags":"","loc":"sourcefile/openpde_matrix_abstract.f90.html","title":"openpde_matrix_abstract.f90 – openpde"},{"text":"Concrete class of (square) matrix, naive. This File Depends On sourcefile~~openpde_matrix_simple.f90~~EfferentGraph sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde_matrix_abstract.f90 openpde_matrix_abstract.f90 sourcefile~openpde_matrix_abstract.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_simple.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_matrix_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_matrix_simple.f90~~AfferentGraph sourcefile~openpde_matrix_simple.f90 openpde_matrix_simple.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde.f90 sourcefile~openpde_linsolver_gmlapack.f90 openpde_linsolver_gmlapack.f90 sourcefile~openpde_matrix_simple.f90->sourcefile~openpde_linsolver_gmlapack.f90 sourcefile~openpde_linsolver_gmlapack.f90->sourcefile~openpde.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_matrix_simple Source Code openpde_matrix_simple.f90 Source Code !< Concrete class of (square) matrix, naive. module openpde_matrix_simple !< Concrete class of (square) matrix, naive. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_matrix_abstract use openpde_kinds implicit none private public :: associate_matrix_simple , matrix_simple type , extends ( matrix ) :: matrix_simple !< Naive matrix (not sparse) real ( R_P ), dimension (:,:), allocatable :: val !< values contains ! deferred public methods procedure :: init procedure :: output procedure :: set ! deferred private methods procedure , private :: assign_matrix procedure , private :: add procedure , private :: sub procedure , pass ( rhs ) :: realmul endtype matrix_simple contains ! public, non TBP function associate_matrix_simple ( matrix_input , emsg ) result ( matrix_pointer ) !< Check the type of the matrix passed as input and return a matrix pointer with type matrix_simple class ( matrix ), intent ( in ), target :: matrix_input !< Input matrix. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( matrix_simple ), pointer :: matrix_pointer !< Simple matrix pointer. select type ( matrix_input ) type is ( matrix_simple ) matrix_pointer => matrix_input class default write ( stderr , '(A)' ) 'error: cast matrix to matrix_simple' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_matrix_simple function add ( lhs , rhs ) result ( opr ) !< Add matrix. class ( matrix_simple ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%add' ) allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%add' ) call opr_cur % init ( lhs % n ) opr_cur % val = lhs % val + rhs_cur % val end function add function sub ( lhs , rhs ) result ( opr ) !< Subtract matrix. class ( matrix_simple ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%sub' ) allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%sub' ) call opr_cur % init ( lhs % n ) opr_cur % val = lhs % val - rhs_cur % val end function sub function realmul ( lhs , rhs ) result ( opr ) !< Real matrix multiply. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( matrix_simple ), intent ( in ) :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%realmul' ) call opr_cur % init ( rhs % n ) opr_cur % val = lhs * rhs % val end function realmul subroutine assign_matrix ( lhs , rhs ) !< Assignment overloading. class ( matrix_simple ), intent ( inout ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%assign' ) lhs % n = rhs_cur % n lhs % val = rhs_cur % val end subroutine assign_matrix subroutine init ( this , n , description , error ) !< Initialize matrix class ( matrix_simple ), intent ( inout ) :: this !< The matrix. integer ( I_P ) :: n !< Matrix size. character ( * ), intent ( in ), optional :: description !< Matrix description. integer ( I_P ), intent ( out ), optional :: error !< Error status. this % n = n allocate ( this % val ( n , n )) !TODO maybe allocation and zeroification should be separed this % val (:,:) = 0._R_P end subroutine init subroutine output ( this , filename , error ) !< Print matrix class ( matrix_simple ), intent ( inout ) :: this !< The matrix. character ( * ), intent ( in ) :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Loop index i integer ( I_P ) :: j !< Loop index j open ( unit = 11 , file = filename ) do i = 1 , this % n do j = 1 , this % n write ( 11 , \"(G15.8)\" , advance = \"no\" ) this % val ( i , j ) enddo write ( 11 , * ) enddo close ( 11 ) end subroutine output subroutine set ( this , i , j , val ) !< Set matrix value class ( matrix_simple ), intent ( inout ) :: this !< The matrix. real ( R_P ), intent ( in ) :: val !< Value to be inserted integer ( I_P ), intent ( in ) :: i !< Index i where set matrix. integer ( I_P ), intent ( in ) :: j !< Index i where set matrix. this % val ( i , j ) = val end subroutine set end module openpde_matrix_simple","tags":"","loc":"sourcefile/openpde_matrix_simple.f90.html","title":"openpde_matrix_simple.f90 – openpde"},{"text":"Abstract class of equation. This File Depends On sourcefile~~openpde_equation_abstract.f90~~EfferentGraph sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 var pansourcefileopenpde_equation_abstractf90EfferentGraph = svgPanZoom('#sourcefileopenpde_equation_abstractf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_equation_abstract.f90~~AfferentGraph sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 var pansourcefileopenpde_equation_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_equation_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_equation_abstract Source Code openpde_equation_abstract.f90 Source Code !< Abstract class of equation. module openpde_equation_abstract !< Abstract class of equation. use openpde_field_abstract use openpde_kinds implicit none private public :: equation type , abstract :: equation !< Abstract class of equation. !< !< The concrete types are implemented at application level (by the user) predefined examples might be provided as well. character ( len = :), allocatable :: description !< Equation description. contains ! deferred public methods procedure ( abstract_bc ), pass ( this ), deferred :: bc !< Equation boundary conditions. procedure ( abstract_forcing ), pass ( this ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initialize the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype equation abstract interface !< Equation boundary conditions. subroutine abstract_bc ( this , inp , t ) !< Equation boundary condition. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. end subroutine abstract_bc endinterface abstract interface !< Initialize equation. subroutine abstract_init ( this , description , filename , error ) !< Initialize equation. import :: equation , I_P class ( equation ), intent ( inout ) :: this !< The equation. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_init endinterface abstract interface !< Return the field after forcing the equation. function abstract_forcing ( this , inp , t ) result ( opr ) !< Return the field after forcing the equation. import :: equation , field , R_P class ( equation ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), allocatable :: opr !< Field computed. end function abstract_forcing endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_equation_abstract","tags":"","loc":"sourcefile/openpde_equation_abstract.f90.html","title":"openpde_equation_abstract.f90 – openpde"},{"text":"Concrete class of mesh for Finite Difference 2D methods. This File Depends On sourcefile~~openpde_mesh_fd_2d.f90~~EfferentGraph sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_mesh_fd_2d.f90~~AfferentGraph sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 var pansourcefileopenpde_mesh_fd_2df90AfferentGraph = svgPanZoom('#sourcefileopenpde_mesh_fd_2df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_mesh_FD_2D Source Code openpde_mesh_FD_2D.f90 Source Code !< Concrete class of mesh for Finite Difference 2D methods. module openpde_mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use openpde_mesh_abstract use openpde_kinds use vtk_fortran implicit none private public :: associate_mesh_FD_2D , mesh_FD_2D type , extends ( mesh ) :: mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. integer ( I_P ) :: nx = 0 !< Number of X points. integer ( I_P ) :: ny = 0 !< Number of Y points. integer ( I_P ) :: ngx = 0 !< Number of X ghost points. integer ( I_P ) :: ngy = 0 !< Number of Y ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: hx = 0._R_P !< Cell X size. real ( R_P ) :: hy = 0._R_P !< Cell Y size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods procedure , pass ( this ) :: set !< Set mesh. endtype mesh_FD_2D contains ! public, non TBP function associate_mesh_FD_2D ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_2D ), pointer :: mesh_pointer !< Finite Difference 2D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_2D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_2D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_2D ! deferred public methods pure subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % nx = 50 this % ny = 40 this % ngx = 2 this % ngy = 2 this % s = 1 this % hx = 0.05_R8P this % hy = 0.07_R8P if ( present ( error )) error = 0 end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_2D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"nx: \" , this % nx print * , \"ny: \" , this % ny print * , \"ngx: \" , this % ngx print * , \"ngy: \" , this % ngy print * , \"s: \" , this % s print * , \"hx: \" , this % hx print * , \"hy: \" , this % hy if ( present ( error )) error = 0 end subroutine output ! public methods pure subroutine set ( this , description , nx , ny , ngx , ngy , s , hx , hy , error ) !< Set mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nx !< Number of X points. integer ( I_P ), intent ( in ), optional :: ny !< Number of Y points. integer ( I_P ), intent ( in ), optional :: ngx !< Number of X ghost points. integer ( I_P ), intent ( in ), optional :: ngy !< Number of Y ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: hx !< Cell X size. real ( R_P ), intent ( in ), optional :: hy !< Cell Y size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( nx )) this % nx = nx if ( present ( ny )) this % ny = ny if ( present ( ngx )) this % ngx = ngx if ( present ( ngy )) this % ngy = ngy if ( present ( s )) this % s = s if ( present ( hx )) this % hx = hx if ( present ( hy )) this % hy = hy if ( present ( error )) error = 0 end subroutine set end module openpde_mesh_FD_2D","tags":"","loc":"sourcefile/openpde_mesh_fd_2d.f90.html","title":"openpde_mesh_FD_2D.f90 – openpde"},{"text":"Concrete class of mesh block for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_mesh_block_fv_1d.f90~~EfferentGraph sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_mesh_block_fv_1d.f90~~AfferentGraph sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 var pansourcefileopenpde_mesh_block_fv_1df90AfferentGraph = svgPanZoom('#sourcefileopenpde_mesh_block_fv_1df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_mesh_block_FV_1D Source Code openpde_mesh_block_FV_1D.f90 Source Code !< Concrete class of mesh block for Finite Volume 1D methods. module openpde_mesh_block_FV_1D !< Concrete class of mesh block for Finite Volume 1D methods. !< !< This mesh block is based on a uniform, Cartesian cell-centered discretization of the domain. !< The nodes-cell numeration adopts the following convention: !< !< ``` !<                  0     1     2          n    n+1 !< +-----+-----+... +-----+-----+-----+... +-----+-----+... +-----+ !< |     |     |    |     |     |     |    |     +     +    +     + !< |-ng  |-ng+1|    |  0  |  1  |  2  |    |  n  + n+1 +    + n+ng+ !< |     |     |    |     |     |     |    |     +     +    +     + !< +-----+-----+... +-----+-----+-----+... +-----+-----+... +-----+ !< !< ``` !< where !< !<+`n` is the **number of cells** !<+`ng` is the **number of ghost cells** !< !< The cell size is **uniform** and equals to `h`. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_kinds implicit none private public :: mesh_block_FV_1D type :: mesh_block_FV_1D !< Concrete class of mesh block for Finite Volume 1D methods. integer ( I_P ) :: n = 0 !< Number of nodes. integer ( I_P ) :: ng = 0 !< Number of ghost cells. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! public methods procedure , pass ( this ) :: output !< Output data. generic :: load => load_from_json !< Load block definition from file. procedure , pass ( this ) :: set !< Set block. ! private methods procedure , pass ( this ), private :: load_from_json !< Load block definition from jSON file. endtype mesh_block_FV_1D contains ! public methods subroutine output ( this , error ) !< Output block. class ( mesh_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( out ), optional :: error !< Error status. print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output pure subroutine set ( this , n , ng , h , error ) !< Set block. class ( mesh_block_FV_1D ), intent ( inout ) :: this !< The block. integer ( I_P ), intent ( in ), optional :: n !< Number of cells. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost cells. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set ! private methods subroutine load_from_json ( this , json , block_number , error ) !< Load block definition from JSON file. class ( mesh_block_FV_1D ), intent ( inout ) :: this !< The block. type ( json_file ), intent ( inout ) :: json !< JSON file handler. character ( * ), intent ( in ) :: block_number !< Block number ID, e.g. 'block5', 'block33'. integer ( I_P ), intent ( out ), optional :: error !< Error status. logical :: found !< Flag inquiring the result json parsing. call json % get ( 'mesh.' // block_number // '.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // '.n\" missing' stop endif call json % get ( 'mesh.' // block_number // '.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // 'ng\" missing' stop endif call json % get ( 'mesh.' // block_number // '.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // 'h\" missing' stop endif if ( present ( error )) error = 0 endsubroutine load_from_json end module openpde_mesh_block_FV_1D","tags":"","loc":"sourcefile/openpde_mesh_block_fv_1d.f90.html","title":"openpde_mesh_block_FV_1D.f90 – openpde"},{"text":"Abstract class of mesh. This File Depends On sourcefile~~openpde_mesh_abstract.f90~~EfferentGraph sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_mesh_abstract.f90~~AfferentGraph sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_abstract.f90 openpde_field_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_abstract.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90 openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_mesh_fd_2d.f90 openpde_mesh_FD_2D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90 openpde_v2f_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_equation_adv.f90 openpde_equation_adv.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_fd_2d.f90 openpde_field_FD_2D.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2m_d2_fd_2d.f90 openpde_f2m_d2_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_integrator_euler_explicit.f90 openpde_integrator_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90 openpde_equation_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_equation_abstract.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90 openpde_f2v_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_abstract.f90 sourcefile~openpde_integrator_adv_abstract.f90 openpde_integrator_adv_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_asbtract.f90 openpde_integrator_asbtract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_spatial_operator_abstract.f90 openpde_spatial_operator_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90 openpde_spatial_operator_d2_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_surface_abstract.f90 openpde_field_surface_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_field_surface_abstract.f90 sourcefile~openpde_v2f_fd_2d.f90 openpde_v2f_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_f2v_fd_2d.f90 openpde_f2v_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90 openpde_spatial_operator_d1_FD_2D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_f2m_abstract.f90 openpde_f2m_abstract.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_abstract.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_field_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_multigrid_abstract.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_field_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_mesh_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_v2f_abstract.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_abstract.f90 sourcefile~openpde_equation_adv.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_v2f_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_field_fd_2d.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_equation_abstract.f90->sourcefile~openpde_integrator_asbtract.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_equation_adv.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_f2v_abstract.f90->sourcefile~openpde_f2v_fd_2d.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_integrator_adv_abstract.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_asbtract.f90->sourcefile~openpde_integrator_euler_explicit.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90 openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d1_abstract.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90 openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_abstract.f90->sourcefile~openpde_spatial_operator_d2_abstract.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_abstract.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_v2f_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_2d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90 openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d1_abstract.f90 sourcefile~openpde_f2m_d2_abstract.f90 openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_abstract.f90->sourcefile~openpde_f2m_d2_abstract.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_abstract.f90->sourcefile~openpde_spatial_operator_d1_fd_2d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_abstract.f90->sourcefile~openpde_spatial_operator_d2_fd_2d.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_abstract.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_2d.f90 sourcefile~openpde_f2m_d2_abstract.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 var pansourcefileopenpde_mesh_abstractf90AfferentGraph = svgPanZoom('#sourcefileopenpde_mesh_abstractf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_mesh_abstract Source Code openpde_mesh_abstract.f90 Source Code !< Abstract class of mesh. module openpde_mesh_abstract !< Abstract class of mesh. use openpde_kinds implicit none private public :: mesh type , abstract :: mesh !< Abstract class of mesh. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred public methods procedure ( abstract_meshinit ), pass ( this ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , pass ( this ), deferred :: output !< Output mesh. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype mesh abstract interface !< Initialize mesh. subroutine abstract_meshinit ( this , description , filename , error ) !< Initialize mesh. import :: I_P , mesh class ( mesh ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshinit endinterface abstract interface !< Output mesh. subroutine abstract_meshoutput ( this , error ) !< Output mesh. import :: I_P , mesh class ( mesh ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. end subroutine abstract_meshoutput endinterface contains elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free end module openpde_mesh_abstract","tags":"","loc":"sourcefile/openpde_mesh_abstract.f90.html","title":"openpde_mesh_abstract.f90 – openpde"},{"text":"Concrete class of mesh for Finite Difference 1D methods. This File Depends On sourcefile~~openpde_mesh_fd_1d.f90~~EfferentGraph sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fd_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_mesh_fd_1d.f90~~AfferentGraph sourcefile~openpde_mesh_fd_1d.f90 openpde_mesh_FD_1D.f90 sourcefile~openpde_field_fd_1d.f90 openpde_field_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_field_fd_1d.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2v_fd_1d.f90 openpde_f2v_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90 openpde_spatial_operator_d2_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_v2f_fd_1d.f90 openpde_v2f_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_f2m_d2_fd_1d.f90 openpde_f2m_d2_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_multigrid_fd_1d.f90 openpde_multigrid_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_multigrid_fd_1d.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90 openpde_spatial_operator_d1_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_f2m_d1_fd_1d.f90 openpde_f2m_d1_FD_1D.f90 sourcefile~openpde_mesh_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2v_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_v2f_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d2_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_spatial_operator_d1_fd_1d.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_f2m_d1_fd_1d.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90 openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_explicit.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90 openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_euler_implicit.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90 openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_field_fd_1d.f90->sourcefile~openpde_integrator_adv_rk_implicit.f90 sourcefile~openpde_f2v_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_v2f_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d2_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_multigrid_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_f2m_d1_fd_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_explicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_euler_implicit.f90->sourcefile~openpde.f90 sourcefile~openpde_integrator_adv_rk_implicit.f90->sourcefile~openpde.f90 var pansourcefileopenpde_mesh_fd_1df90AfferentGraph = svgPanZoom('#sourcefileopenpde_mesh_fd_1df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_mesh_FD_1D Source Code openpde_mesh_FD_1D.f90 Source Code !< Concrete class of mesh for Finite Difference 1D methods. module openpde_mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_mesh_abstract use openpde_kinds use vtk_fortran implicit none private public :: associate_mesh_FD_1D , mesh_FD_1D type , extends ( mesh ) :: mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. integer ( I_P ) :: n = 0 !< Number of points. integer ( I_P ) :: ng = 0 !< Number of ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! operators generic :: assignment ( = ) => assign_mesh_FD_1D !< Overloading `=` operator. ! private methods procedure , pass ( lhs ), private :: assign_mesh_FD_1D !< Implementation of `=` operator. procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FD_1D interface associate_mesh_FD_1D module procedure associate_mesh_FD_1D_scalar ,& associate_mesh_FD_1D_rank1 endinterface associate_mesh_FD_1D contains ! public, non TBP function associate_mesh_FD_1D_scalar ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_1D ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_1D_scalar function associate_mesh_FD_1D_rank1 ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input (:) !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_1D ), pointer :: mesh_pointer (:) !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_1D_rank1 ! deferred public methods subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % n = 128 this % ng = 2 this % s = 1 this % h = 1 2._R_P / 128 !0.05_R8P if ( present ( error )) error = 0 endif end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output ! public methods pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set ! private methods elemental subroutine assign_mesh_FD_1D ( lhs , rhs ) !< Implementation of `=` operator. !< !< @note This implementation is not polymorphic: in future this must become a deferred procudere of the !< abstract [[mesh]] class, thus must become actually polymorphic (maybe a `select type` construct will be necessary). class ( mesh_FD_1D ), intent ( inout ) :: lhs !< Left hand side. type ( mesh_FD_1D ), intent ( in ) :: rhs !< Right hand side. lhs % n = rhs % n lhs % ng = rhs % ng lhs % s = rhs % s lhs % h = rhs % h end subroutine assign_mesh_FD_1D subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then call json % get ( 'mesh.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif call json % get ( 'mesh.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"ng\" missing' stop endif call json % get ( 'mesh.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"h\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif if ( present ( error )) error = 0 endsubroutine load_from_json end module openpde_mesh_FD_1D","tags":"","loc":"sourcefile/openpde_mesh_fd_1d.f90.html","title":"openpde_mesh_FD_1D.f90 – openpde"},{"text":"Concrete class of mesh for Finite Volume 1D methods. This File Depends On sourcefile~~openpde_mesh_fv_1d.f90~~EfferentGraph sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90 openpde_mesh_block_FV_1D.f90 sourcefile~openpde_mesh_block_fv_1d.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90 openpde_kinds.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_fv_1d.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_block_fv_1d.f90 sourcefile~openpde_mesh_abstract.f90 openpde_mesh_abstract.f90 sourcefile~openpde_kinds.f90->sourcefile~openpde_mesh_abstract.f90 sourcefile~openpde_mesh_abstract.f90->sourcefile~openpde_mesh_fv_1d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~openpde_mesh_fv_1d.f90~~AfferentGraph sourcefile~openpde_mesh_fv_1d.f90 openpde_mesh_FV_1D.f90 sourcefile~openpde.f90 openpde.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_surface_fv_1d.f90 openpde_field_surface_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90 openpde_spatial_operator_d1_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90 openpde_field_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90 openpde_spatial_operator_d2_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90 openpde_field_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90 openpde_field_surface_block_FV_1D.f90 sourcefile~openpde_mesh_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_field_surface_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_spatial_operator_d1_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_fv_1d.f90 sourcefile~openpde_field_block_fv_1d.f90->sourcefile~openpde_field_surface_block_fv_1d.f90 sourcefile~openpde_spatial_operator_d2_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d1_fv_1d.f90 sourcefile~openpde_field_fv_1d.f90->sourcefile~openpde_spatial_operator_d2_fv_1d.f90 sourcefile~openpde_field_surface_block_fv_1d.f90->sourcefile~openpde_field_surface_fv_1d.f90 var pansourcefileopenpde_mesh_fv_1df90AfferentGraph = svgPanZoom('#sourcefileopenpde_mesh_fv_1df90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules openpde_mesh_FV_1D Source Code openpde_mesh_FV_1D.f90 Source Code !< Concrete class of mesh for Finite Volume 1D methods. module openpde_mesh_FV_1D !< Concrete class of mesh for Finite Volume 1D methods. !< !< This mesh is based on a uniform, Cartesian cell-centered discretization of the domain, !< that is a multiblock mesh. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use json_module use openpde_kinds use openpde_mesh_abstract use openpde_mesh_block_FV_1D use stringifor use vtk_fortran implicit none private public :: associate_mesh_FV_1D , mesh_FV_1D type , extends ( mesh ) :: mesh_FV_1D !< Concrete class of mesh for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( mesh_block_FV_1D ), allocatable :: blocks (:) !< The blocks. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! private methods procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FV_1D contains ! public, non TBP function associate_mesh_FV_1D ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FV_1D ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FV_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FV_1D ! deferred public methods subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % nb = 1 allocate ( this % blocks ( 1 )) call this % blocks ( 1 )% set ( n = 50 , ng = 2 , h = 0.05_R_P , error = error ) endif call this % output ( error = error ) end subroutine init subroutine output ( this , error ) !< Output mesh. class ( mesh_FV_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: b !< Counter. if ( allocated ( this % description )) print \"(A)\" , this % description if ( allocated ( this % blocks )) then print * , 'nb: ' , this % nb do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) print * , 'block ' , b call this % blocks ( b )% output ( error = error ) end do end if end subroutine output ! public methods pure subroutine set ( this , description , nb , n , ng , h , error ) !< Set mesh. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nb !< Number of blocks. integer ( I_P ), intent ( in ), optional :: n ( 1 :) !< Number of points for each block. integer ( I_P ), intent ( in ), optional :: ng ( 1 :) !< Number of ghost points for each block. real ( R_P ), intent ( in ), optional :: h ( 1 :) !< Cell size for each block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: b !< Counter. if ( present ( description )) this % description = description if ( present ( nb )) then this % nb = nb if ( allocated ( this % blocks )) then if ( nb /= size ( this % blocks , dim = 1 )) then deallocate ( this % blocks ) allocate ( this % blocks ( 1 : nb )) endif endif endif if ( allocated ( this % blocks )) then do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) call this % blocks ( b )% set ( n = n ( b ), ng = ng ( b ), h = h ( b ), error = error ) end do end if end subroutine set ! private methods subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( string ) :: block_number !< Block number ID, e.g. 'block5', 'block33'. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. integer ( I_P ) :: b !< Counter. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite volume 1D\" ) then call json % get ( 'mesh.nb' , this % nb , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) block_number = b block_number = block_number % replace ( old = '+' , new = '' ) call this % blocks ( b )% load ( json = json , block_number = 'block' // block_number , error = error ) end do else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite volume 1D\"!' stop endif endsubroutine load_from_json ! overridden public methods elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free end module openpde_mesh_FV_1D","tags":"","loc":"sourcefile/openpde_mesh_fv_1d.f90.html","title":"openpde_mesh_FV_1D.f90 – openpde"},{"text":"type, public, extends( field ) :: field_FD_2D type~~field_fd_2d~~InheritsGraph type~field_fd_2d field_FD_2D type~mesh mesh type~mesh->type~field_fd_2d m type~field field type~mesh->type~field m type~field->type~field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field for Finite Difference 2D methods. Variables description m val Type-Bound Procedures operator(+) operator(*) operator(-) operator(/) assignment(=) free associate_mesh init output add assign_field mul mulreal realmul sub div set Source Code field_FD_2D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. real(kind=R_P), public, allocatable, dimension(:,:) :: val Field value. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Initialize finite difference 2D field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output field data. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: div Subtract fields. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, public, pass(this) :: set Set field. private subroutine set (this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( field ) :: field_FD_2D !< Concrete class of field for Finite Difference 2D methods. real ( R_P ), allocatable , dimension (:,:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. endtype field_FD_2D","tags":"","loc":"type/field_fd_2d.html","title":"field_FD_2D – openpde "},{"text":"type, public, abstract :: field type~~field~~InheritsGraph type~field field type~mesh mesh type~mesh->type~field m Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of field. Inherited By type~~field~~InheritedByGraph type~field field type~multigrid multigrid type~field->type~multigrid fields, fields0, residuals, sources, tau type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~field->type~integrator_adv_rk_implicit stages type~multigrid_fd_1d multigrid_FD_1D type~field->type~multigrid_fd_1d fields, fields0, residuals, sources, tau type~equation_adv equation_adv type~field->type~equation_adv resvar_e, resvar_mg, source_mg type~field_fv_1d field_FV_1D type~field->type~field_fv_1d type~field_fd_2d field_FD_2D type~field->type~field_fd_2d type~field_surface field_surface type~field->type~field_surface type~field_fd_1d field_FD_1D type~field->type~field_fd_1d type~multigrid->type~multigrid_fd_1d type~multigrid->type~equation_adv mg type~field_surface_fv_1d field_surface_FV_1D type~field_surface->type~field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description m Type-Bound Procedures associate_mesh init output add assign_field mul mulreal realmul sub div operator(+) operator(*) operator(-) operator(/) assignment(=) free Source Code field Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure( abstract_associate_mesh ), public, deferred, pass(this) :: associate_mesh Associate mesh. subroutine abstract_associate_mesh (this, field_mesh, error) Prototype Associate a mesh to field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_init ), public, deferred, pass(this) :: init Initilize field. subroutine abstract_init (this, field_mesh, description, error) Prototype Initialize the field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_output ), public, deferred, pass(this) :: output Output field data. subroutine abstract_output (this, filename, error) Prototype Output the field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: add Add fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. procedure( abstract_assign ), private, deferred, pass(lhs) :: assign_field Assign fields. subroutine abstract_assign (lhs, rhs) Prototype Assignment overloading. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: mul Multiply fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. procedure( abstract_field_op_real ), private, deferred, pass(lhs) :: mulreal Multiply field for real. function abstract_field_op_real (lhs, rhs) result(opr) Prototype Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. procedure( abstract_real_op_field ), private, deferred, pass(rhs) :: realmul Multiply real for field. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: sub Subtract fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. procedure( abstract_simmetric_operator ), private, deferred, pass(lhs) :: div Divide fields. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. Source Code type , abstract :: field !< Abstract class of field. character ( len = :), allocatable :: description !< Field description. class ( mesh ), pointer :: m => null () !< Pointer to the mesh of the field. contains ! deferred public methods procedure ( abstract_associate_mesh ), pass ( this ), deferred :: associate_mesh !< Associate mesh. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize field. procedure ( abstract_output ), pass ( this ), deferred :: output !< Output field data. ! deferred private methods procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: add !< Add fields. procedure ( abstract_assign ), pass ( lhs ), private , deferred :: assign_field !< Assign fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: mul !< Multiply fields. procedure ( abstract_field_op_real ), pass ( lhs ), private , deferred :: mulreal !< Multiply field for real. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Multiply real for field. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: sub !< Subtract fields. procedure ( abstract_simmetric_operator ), pass ( lhs ), private , deferred :: div !< Divide fields. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_field !< Assignment overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype field","tags":"","loc":"type/field.html","title":"field – openpde "},{"text":"type, public :: field_surface_block_FV_1D Concrete class of field surface block for Finite Volume 1D methods. Variables val Type-Bound Procedures alloc compute_fluxes free init output operator(+) operator(*) operator(-) operator(/) assignment(=) add assign_block mul mulreal realmul sub div Source Code field_surface_block_FV_1D Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Block value. Type-Bound Procedures procedure, public, pass(this) :: alloc Allocate block. private subroutine alloc (this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: compute_fluxes Compute fluxes of field through surfaces. private subroutine compute_fluxes (this, field_cell, mesh_block, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(field_block_FV_1D), intent(in) :: field_cell Field at cells center. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The field. procedure, public, pass(this) :: init Initilize block. private subroutine init (this, mesh_block, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output block data. private subroutine output (this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: operator(+) => add Operator + overloading. private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. generic, public :: operator(-) => sub Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. generic, public :: operator(/) => div Operator / overloading. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. generic, public :: assignment(=) => assign_block Assignment overloading. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. procedure, private, pass(lhs) :: add Add blocks. private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: assign_block Assign blocks. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. procedure, private, pass(lhs) :: mul Multiply blocks. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: mulreal Multiply block for real. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. procedure, private, pass(rhs) :: realmul Multiply real for block. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: sub Divide blocks. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: div Divide blocks. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code type :: field_surface_block_FV_1D !< Concrete class of field surface block for Finite Volume 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Block value. contains ! public methods procedure , pass ( this ) :: alloc !< Allocate block. procedure , pass ( this ) :: compute_fluxes !< Compute fluxes of field through surfaces. procedure , pass ( this ) :: free !< Free dynamic memory. procedure , pass ( this ) :: init !< Initilize block. procedure , pass ( this ) :: output !< Output block data. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `/` overloading. generic , public :: assignment ( = ) => assign_block !< Assignment overloading. ! private methods procedure , pass ( lhs ), private :: add !< Add blocks. procedure , pass ( lhs ), private :: assign_block !< Assign blocks. procedure , pass ( lhs ), private :: mul !< Multiply blocks. procedure , pass ( lhs ), private :: mulreal !< Multiply block for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for block. procedure , pass ( lhs ), private :: sub !< Divide blocks. procedure , pass ( lhs ), private :: div !< Divide blocks. endtype field_surface_block_FV_1D","tags":"","loc":"type/field_surface_block_fv_1d.html","title":"field_surface_block_FV_1D – openpde "},{"text":"type, public, extends( field ) :: field_FD_1D type~~field_fd_1d~~InheritsGraph type~field_fd_1d field_FD_1D type~mesh mesh type~mesh->type~field_fd_1d m type~field field type~mesh->type~field m type~field->type~field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field for Finite Difference 1D methods. Variables description m val Type-Bound Procedures operator(+) operator(*) operator(-) operator(/) assignment(=) free associate_mesh init output add assign_field mul mulreal realmul sub div set Source Code field_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output field data. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: div Subtract fields. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, public, pass(this) :: set Set field. private subroutine set (this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( field ) :: field_FD_1D !< Concrete class of field for Finite Difference 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Field value. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. ! public methods procedure , pass ( this ) :: set !< Set field. !procedure, pass(rhs) :: newrealmul !public :: operator(**) => newrealmul endtype field_FD_1D","tags":"","loc":"type/field_fd_1d.html","title":"field_FD_1D – openpde "},{"text":"type, public, abstract, extends( field ) :: field_surface type~~field_surface~~InheritsGraph type~field_surface field_surface type~mesh mesh type~mesh->type~field_surface m type~field field type~mesh->type~field m type~field->type~field_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of field surface. Inherited By type~~field_surface~~InheritedByGraph type~field_surface field_surface type~field_surface_fv_1d field_surface_FV_1D type~field_surface->type~field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description m Type-Bound Procedures associate_mesh init output operator(+) operator(*) operator(-) operator(/) assignment(=) free compute_fluxes Source Code field_surface Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure( abstract_associate_mesh ), public, deferred, pass(this) :: associate_mesh Associate mesh. subroutine abstract_associate_mesh (this, field_mesh, error) Prototype Associate a mesh to field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_init ), public, deferred, pass(this) :: init Initilize field. subroutine abstract_init (this, field_mesh, description, error) Prototype Initialize the field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_output ), public, deferred, pass(this) :: output Output field data. subroutine abstract_output (this, filename, error) Prototype Output the field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. procedure( abstract_compute_fluxes ), public, deferred, pass(this) :: compute_fluxes Compute fluxes of field through surfaces. subroutine abstract_compute_fluxes (this, field_cell, error) Prototype Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , abstract , extends ( field ) :: field_surface !< Abstract class of field surface. contains ! deferred public methods procedure ( abstract_compute_fluxes ), pass ( this ), deferred :: compute_fluxes !< Compute fluxes of field through surfaces. endtype field_surface","tags":"","loc":"type/field_surface.html","title":"field_surface – openpde "},{"text":"type, public, extends( field_surface ) :: field_surface_FV_1D type~~field_surface_fv_1d~~InheritsGraph type~field_surface_fv_1d field_surface_FV_1D type~mesh mesh type~mesh->type~field_surface_fv_1d m type~field_surface field_surface type~mesh->type~field_surface m type~field field type~mesh->type~field m field_surface_block_FV_1D field_surface_block_FV_1D field_surface_block_FV_1D->type~field_surface_fv_1d blocks type~field_surface->type~field_surface_fv_1d type~field->type~field_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field surface for Finite Volume 1D methods. Variables description m nb blocks Type-Bound Procedures operator(+) operator(*) operator(-) operator(/) assignment(=) free associate_mesh init output compute_fluxes add assign_field mul mulreal realmul sub div Source Code field_surface_FV_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. integer(kind=I_P), public :: nb Number of blocks. type(field_surface_block_FV_1D), public, allocatable, dimension(:) :: blocks The blocks. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Initialize field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output field. private subroutine output (this, filename, error) Output field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: compute_fluxes Compute fluxes of field through surfaces. private subroutine compute_fluxes (this, field_cell, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: div Subtract fields. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Source Code type , extends ( field_surface ) :: field_surface_FV_1D !< Concrete class of field surface for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( field_surface_block_FV_1D ), allocatable , dimension (:) :: blocks !< The blocks. contains ! deferred public methods of field abstract procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field. ! deferred public methods of field_surface abstract procedure , pass ( this ) :: compute_fluxes !< Compute fluxes of field through surfaces. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. endtype field_surface_FV_1D","tags":"","loc":"type/field_surface_fv_1d.html","title":"field_surface_FV_1D – openpde "},{"text":"type, public :: field_block_FV_1D Concrete class of field block for Finite Volume 1D methods. Variables val Type-Bound Procedures alloc free init output operator(+) operator(*) operator(-) operator(/) assignment(=) add assign_block mul mulreal realmul sub div Source Code field_block_FV_1D Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Block value. Type-Bound Procedures procedure, public, pass(this) :: alloc Allocate block. private subroutine alloc (this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The field. procedure, public, pass(this) :: init Initilize block. private subroutine init (this, mesh_field, b, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_FV_1D), intent(in) :: mesh_field Mesh of the whole field. integer(kind=I_P), intent(in) :: b Block index. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output block data. private subroutine output (this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: operator(+) => add Operator + overloading. private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. generic, public :: operator(-) => sub Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. generic, public :: operator(/) => div Operator - overloading. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. generic, public :: assignment(=) => assign_block Assignment overloading. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. procedure, private, pass(lhs) :: add Add blocks. private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: assign_block Assign blocks. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. procedure, private, pass(lhs) :: mul Multiply blocks. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: mulreal Multiply block for real. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. procedure, private, pass(rhs) :: realmul Multiply real for block. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: sub Subtract blocks. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. procedure, private, pass(lhs) :: div Subtract blocks. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code type :: field_block_FV_1D !< Concrete class of field block for Finite Volume 1D methods. real ( R_P ), allocatable , dimension (:) :: val !< Block value. contains ! public methods procedure , pass ( this ) :: alloc !< Allocate block. procedure , pass ( this ) :: free !< Free dynamic memory. procedure , pass ( this ) :: init !< Initilize block. procedure , pass ( this ) :: output !< Output block data. ! public operators generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( * ) => mul , realmul , mulreal !< Operator `*` overloading. generic , public :: operator ( - ) => sub !< Operator `-` overloading. generic , public :: operator ( / ) => div !< Operator `-` overloading. generic , public :: assignment ( = ) => assign_block !< Assignment overloading. ! private methods procedure , pass ( lhs ), private :: add !< Add blocks. procedure , pass ( lhs ), private :: assign_block !< Assign blocks. procedure , pass ( lhs ), private :: mul !< Multiply blocks. procedure , pass ( lhs ), private :: mulreal !< Multiply block for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for block. procedure , pass ( lhs ), private :: sub !< Subtract blocks. procedure , pass ( lhs ), private :: div !< Subtract blocks. endtype field_block_FV_1D","tags":"","loc":"type/field_block_fv_1d.html","title":"field_block_FV_1D – openpde "},{"text":"type, public, extends( field ) :: field_FV_1D type~~field_fv_1d~~InheritsGraph type~field_fv_1d field_FV_1D type~mesh mesh type~mesh->type~field_fv_1d m type~field field type~mesh->type~field m field_block_FV_1D field_block_FV_1D field_block_FV_1D->type~field_fv_1d blocks type~field->type~field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field for Finite Volume 1D methods. Variables description m nb blocks Type-Bound Procedures operator(+) operator(*) operator(-) operator(/) assignment(=) free associate_mesh init output add assign_field mul mulreal realmul sub div Source Code field_FV_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. integer(kind=I_P), public :: nb Number of blocks. type(field_block_FV_1D), public, allocatable, dimension(:) :: blocks The blocks. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(*) => mul , realmul , mulreal Operator * overloading. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator - overloading. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: operator(/) => div Operator - overloading. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. generic, public :: assignment(=) => assign_field Assignment overloading. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: init Initilize field. private subroutine init (this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output field data. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(lhs) :: add Add fields. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: assign_field Assign fields. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. procedure, private, pass(lhs) :: mul Multiply fields. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: mulreal Multiply field for real. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(rhs) :: realmul Multiply real for field. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: sub Subtract fields. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. procedure, private, pass(lhs) :: div Subtract fields. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Source Code type , extends ( field ) :: field_FV_1D !< Concrete class of field for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( field_block_FV_1D ), allocatable , dimension (:) :: blocks !< The blocks. contains ! deferred public methods procedure , pass ( this ) :: associate_mesh !< Associate field to a mesh. procedure , pass ( this ) :: init !< Initilize field. procedure , pass ( this ) :: output !< Output field data. ! deferred private methods procedure , pass ( lhs ), private :: add !< Add fields. procedure , pass ( lhs ), private :: assign_field !< Assign fields. procedure , pass ( lhs ), private :: mul !< Multiply fields. procedure , pass ( lhs ), private :: mulreal !< Multiply field for real. procedure , pass ( rhs ), private :: realmul !< Multiply real for field. procedure , pass ( lhs ), private :: sub !< Subtract fields. procedure , pass ( lhs ), private :: div !< Subtract fields. endtype field_FV_1D","tags":"","loc":"type/field_fv_1d.html","title":"field_FV_1D – openpde "},{"text":"type, public, extends( v2f ) :: v2f_FD_2D type~~v2f_fd_2d~~InheritsGraph type~v2f_fd_2d v2f_FD_2D type~mesh mesh type~mesh->type~v2f_fd_2d mesh type~v2f v2f type~mesh->type~v2f mesh type~v2f->type~v2f_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of v2f (vector to field) for FD 1D Variables mesh n_equ Type-Bound Procedures operate Source Code v2f_FD_2D Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure, public :: operate Operator operation. private subroutine operate (this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_2D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field. Source Code type , extends ( v2f ) :: v2f_FD_2D !< Concrete class of v2f (vector to field) for FD 1D contains procedure :: operate !< Operator operation. endtype v2f_FD_2D","tags":"","loc":"type/v2f_fd_2d.html","title":"v2f_FD_2D – openpde "},{"text":"type, public, extends( v2f ) :: v2f_FD_1D type~~v2f_fd_1d~~InheritsGraph type~v2f_fd_1d v2f_FD_1D type~mesh mesh type~mesh->type~v2f_fd_1d mesh type~v2f v2f type~mesh->type~v2f mesh type~v2f->type~v2f_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of v2f (vector to field) for FD 1D Variables mesh n_equ Type-Bound Procedures operate Source Code v2f_FD_1D Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure, public :: operate Operator operation. private subroutine operate (this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_1D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field. Source Code type , extends ( v2f ) :: v2f_FD_1D !< Concrete class of v2f (vector to field) for FD 1D contains procedure :: operate !< Operator operation. endtype v2f_FD_1D","tags":"","loc":"type/v2f_fd_1d.html","title":"v2f_FD_1D – openpde "},{"text":"type, public, abstract :: v2f type~~v2f~~InheritsGraph type~v2f v2f type~mesh mesh type~mesh->type~v2f mesh Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of v2f. Inherited By type~~v2f~~InheritedByGraph type~v2f v2f type~equation_adv equation_adv type~v2f->type~equation_adv v2f_opr type~v2f_fd_2d v2f_FD_2D type~v2f->type~v2f_fd_2d type~v2f_fd_1d v2f_FD_1D type~v2f->type~v2f_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables mesh n_equ Type-Bound Procedures operate Source Code v2f Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. subroutine abstract_operate (this, vec, fie) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( v2f ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Resulting field. Source Code type , abstract :: v2f !< Abstract class of v2f. class ( mesh ), pointer :: mesh integer ( I_P ) :: n_equ contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype v2f","tags":"","loc":"type/v2f.html","title":"v2f – openpde "},{"text":"type, public, abstract :: linsolver type~~linsolver~~InheritsGraph type~linsolver linsolver type~matrix matrix type~matrix->type~linsolver mat type~vector vector type~vector->type~linsolver vec, sol Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of linsolver. Inherited By type~~linsolver~~InheritedByGraph type~linsolver linsolver type~equation_adv equation_adv type~linsolver->type~equation_adv solver type~linsolver_gmlapack linsolver_gmlapack type~linsolver->type~linsolver_gmlapack Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description mat vec sol Type-Bound Procedures init set_matrix set_vector solve Source Code linsolver Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( matrix ), public, allocatable :: mat Matrix A class( vector ), public, allocatable :: vec Vector b class( vector ), public, allocatable :: sol Solution x Type-Bound Procedures procedure( abstract_init ), public, deferred :: init Initilize field. subroutine abstract_init (this, n) Prototype Init linsolver. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this integer(kind=I_P) :: n procedure( abstract_set_matrix ), public, deferred :: set_matrix Associate matrix subroutine abstract_set_matrix (this, mat) Prototype Set matrix. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( matrix ), intent(in), target :: mat The mesh. procedure( abstract_set_vector ), public, deferred :: set_vector Associate vector subroutine abstract_set_vector (this, vec) Prototype Set vector. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( vector ), intent(in), target :: vec The mesh. procedure( abstract_solve ), public, deferred :: solve Solve system. subroutine abstract_solve (this) Prototype Solve system. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout), target :: this The field. Source Code type , abstract :: linsolver !< Abstract class of linsolver. character ( len = :), allocatable :: description !< Description. class ( matrix ), allocatable :: mat !< Matrix A class ( vector ), allocatable :: vec !< Vector b class ( vector ), allocatable :: sol !< Solution x contains ! deferred public methods procedure ( abstract_init ), deferred :: init !< Initilize field. procedure ( abstract_set_matrix ), deferred :: set_matrix !< Associate matrix procedure ( abstract_set_vector ), deferred :: set_vector !< Associate vector procedure ( abstract_solve ) , deferred :: solve !< Solve system. endtype linsolver","tags":"","loc":"type/linsolver.html","title":"linsolver – openpde "},{"text":"type, public, extends( linsolver ) :: linsolver_gmlapack type~~linsolver_gmlapack~~InheritsGraph type~linsolver_gmlapack linsolver_gmlapack type~matrix matrix type~matrix->type~linsolver_gmlapack mat type~linsolver linsolver type~matrix->type~linsolver mat type~vector vector type~vector->type~linsolver_gmlapack vec, sol type~vector->type~linsolver vec, sol type~linsolver->type~linsolver_gmlapack Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of linsolver using LAPACK with general matrix. Variables description mat vec sol ipiv info lda Type-Bound Procedures init set_matrix set_vector solve Source Code linsolver_gmlapack Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( matrix ), public, allocatable :: mat Matrix A class( vector ), public, allocatable :: vec Vector b class( vector ), public, allocatable :: sol Solution x integer(kind=I_P), public, allocatable :: ipiv (:) integer(kind=I_P), public :: info integer(kind=I_P), public :: lda Type-Bound Procedures procedure, public :: init private subroutine init (this, n) Init linsolver Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this integer(kind=I_P) :: n procedure, public :: set_matrix private subroutine set_matrix (this, mat) Set the solver matrix A. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( matrix ), intent(in), target :: mat procedure, public :: set_vector private subroutine set_vector (this, vec) Set the solver vector b. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( vector ), intent(in), target :: vec procedure, public :: solve private subroutine solve (this) Solve the linear system. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout), target :: this Source Code type , extends ( linsolver ) :: linsolver_gmlapack !< Concrete class of linsolver using LAPACK with general matrix. integer ( I_P ), allocatable :: ipiv (:) integer ( I_P ) :: info integer ( I_P ) :: lda contains ! deferred public methods procedure :: init procedure :: set_matrix procedure :: set_vector procedure :: solve endtype linsolver_gmlapack","tags":"","loc":"type/linsolver_gmlapack.html","title":"linsolver_gmlapack – openpde "},{"text":"type, public, extends( f2m_d2 ) :: f2m_d2_FD_1D type~~f2m_d2_fd_1d~~InheritsGraph type~f2m_d2_fd_1d f2m_d2_FD_1D type~matrix matrix type~matrix->type~f2m_d2_fd_1d mat type~f2m_d2 f2m_d2 type~matrix->type~f2m_d2 mat type~f2m f2m type~matrix->type~f2m mat type~f2m_d2->type~f2m_d2_fd_1d type~f2m->type~f2m_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field to matrix (implicit) second derivative operator for FD 1D Variables description mat Type-Bound Procedures operate Source Code f2m_d2_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application. Source Code type , extends ( f2m_d2 ) :: f2m_d2_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d2_FD_1D","tags":"","loc":"type/f2m_d2_fd_1d.html","title":"f2m_d2_FD_1D – openpde "},{"text":"type, public, abstract, extends( f2m ) :: f2m_d1 type~~f2m_d1~~InheritsGraph type~f2m_d1 f2m_d1 type~matrix matrix type~matrix->type~f2m_d1 mat type~f2m f2m type~matrix->type~f2m mat type~f2m->type~f2m_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of matrix operator of first derivative. Inherited By type~~f2m_d1~~InheritedByGraph type~f2m_d1 f2m_d1 type~f2m_d1_fd_1d f2m_d1_FD_1D type~f2m_d1->type~f2m_d1_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description mat Type-Bound Procedures operate Source Code f2m_d1 Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure( abstract_operate ), public, deferred :: operate Operator function. function abstract_operate (this, inp, i_equ, i_fie, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( f2m ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Direction of operation. integer(kind=I_P), intent(in), optional :: i_fie Direction of operation. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator as f(u)=A*u Source Code type , abstract , extends ( f2m ) :: f2m_d1 !< Abstract class of matrix operator of first derivative. endtype f2m_d1","tags":"","loc":"type/f2m_d1.html","title":"f2m_d1 – openpde "},{"text":"type, public, extends( f2m_d1 ) :: f2m_d1_FD_1D type~~f2m_d1_fd_1d~~InheritsGraph type~f2m_d1_fd_1d f2m_d1_FD_1D type~matrix matrix type~matrix->type~f2m_d1_fd_1d mat type~f2m_d1 f2m_d1 type~matrix->type~f2m_d1 mat type~f2m f2m type~matrix->type~f2m mat type~f2m_d1->type~f2m_d1_fd_1d type~f2m->type~f2m_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field to matrix (implicit) second derivative operator for FD 1D Variables description mat Type-Bound Procedures operate Source Code f2m_d1_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application. Source Code type , extends ( f2m_d1 ) :: f2m_d1_FD_1D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d1_FD_1D","tags":"","loc":"type/f2m_d1_fd_1d.html","title":"f2m_d1_FD_1D – openpde "},{"text":"type, public, abstract, extends( f2m ) :: f2m_d2 type~~f2m_d2~~InheritsGraph type~f2m_d2 f2m_d2 type~matrix matrix type~matrix->type~f2m_d2 mat type~f2m f2m type~matrix->type~f2m mat type~f2m->type~f2m_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of matrix operator of second derivative. Inherited By type~~f2m_d2~~InheritedByGraph type~f2m_d2 f2m_d2 type~f2m_d2_fd_1d f2m_d2_FD_1D type~f2m_d2->type~f2m_d2_fd_1d type~f2m_d2_fd_2d f2m_d2_FD_2D type~f2m_d2->type~f2m_d2_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description mat Type-Bound Procedures operate Source Code f2m_d2 Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure( abstract_operate ), public, deferred :: operate Operator function. function abstract_operate (this, inp, i_equ, i_fie, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( f2m ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Direction of operation. integer(kind=I_P), intent(in), optional :: i_fie Direction of operation. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator as f(u)=A*u Source Code type , abstract , extends ( f2m ) :: f2m_d2 !< Abstract class of matrix operator of second derivative. endtype f2m_d2","tags":"","loc":"type/f2m_d2.html","title":"f2m_d2 – openpde "},{"text":"type, public, extends( f2m_d2 ) :: f2m_d2_FD_2D type~~f2m_d2_fd_2d~~InheritsGraph type~f2m_d2_fd_2d f2m_d2_FD_2D type~matrix matrix type~matrix->type~f2m_d2_fd_2d mat type~f2m_d2 f2m_d2 type~matrix->type~f2m_d2 mat type~f2m f2m type~matrix->type~f2m mat type~f2m_d2->type~f2m_d2_fd_2d type~f2m->type~f2m_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of field to matrix (implicit) second derivative operator for FD 1D Variables description mat Type-Bound Procedures operate Source Code f2m_d2_FD_2D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application. Source Code type , extends ( f2m_d2 ) :: f2m_d2_FD_2D !< Concrete class of field to matrix (implicit) second derivative operator for FD 1D contains procedure :: operate !< Operator operation. endtype f2m_d2_FD_2D","tags":"","loc":"type/f2m_d2_fd_2d.html","title":"f2m_d2_FD_2D – openpde "},{"text":"type, public, abstract :: f2m type~~f2m~~InheritsGraph type~f2m f2m type~matrix matrix type~matrix->type~f2m mat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of f2m operator. Inherited By type~~f2m~~InheritedByGraph type~f2m f2m type~f2m_d1 f2m_d1 type~f2m->type~f2m_d1 type~f2m_d2 f2m_d2 type~f2m->type~f2m_d2 type~f2m_d1_fd_1d f2m_d1_FD_1D type~f2m_d1->type~f2m_d1_fd_1d type~f2m_d2_fd_1d f2m_d2_FD_1D type~f2m_d2->type~f2m_d2_fd_1d type~f2m_d2_fd_2d f2m_d2_FD_2D type~f2m_d2->type~f2m_d2_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description mat Type-Bound Procedures operate Source Code f2m Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure( abstract_operate ), public, deferred :: operate Operator function. function abstract_operate (this, inp, i_equ, i_fie, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( f2m ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Direction of operation. integer(kind=I_P), intent(in), optional :: i_fie Direction of operation. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator as f(u)=A*u Source Code type , abstract :: f2m !< Abstract class of f2m operator. character ( len = :), allocatable :: description !< Operator description. class ( matrix ), allocatable :: mat !< Matrix used only to decide the type contains ! deferred public methods procedure ( abstract_operate ), deferred :: operate !< Operator function. endtype f2m","tags":"","loc":"type/f2m.html","title":"f2m – openpde "},{"text":"type, public, abstract :: integrator_adv Abstract class of integrator. Inherited By type~~integrator_adv~~InheritedByGraph type~integrator_adv integrator_adv type~integrator_adv_euler_implicit integrator_adv_euler_implicit type~integrator_adv->type~integrator_adv_euler_implicit type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~integrator_adv->type~integrator_adv_rk_implicit type~integrator_adv_euler_explicit integrator_adv_euler_explicit type~integrator_adv->type~integrator_adv_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description dt Type-Bound Procedures init integrate free Source Code integrator_adv Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure( abstract_init ), public, deferred, pass(this) :: init Initilize integrator. subroutine abstract_init (this, equ, description, filename, error) Prototype Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_integrate ), public, deferred, pass(this) :: integrate Integrate the field accordingly to the equation. function abstract_integrate (this, equ, t, inp) result(error) Prototype Integrate the field accordingly to the equation. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. Source Code type , abstract :: integrator_adv !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator_adv","tags":"","loc":"type/integrator_adv.html","title":"integrator_adv – openpde "},{"text":"type, public, extends( integrator_adv ) :: integrator_adv_euler_implicit type~~integrator_adv_euler_implicit~~InheritsGraph type~integrator_adv_euler_implicit integrator_adv_euler_implicit type~matrix matrix type~matrix->type~integrator_adv_euler_implicit matA, mat_identity type~vector vector type~vector->type~integrator_adv_euler_implicit vecB, vecS type~integrator_adv integrator_adv type~integrator_adv->type~integrator_adv_euler_implicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of integrator, Euler implicit scheme. Variables description dt alpha matA vecB vecS mat_identity Type-Bound Procedures free init integrate load load_from_json Source Code integrator_adv_euler_implicit Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. real(kind=R_P), public :: alpha class( matrix ), public, allocatable :: matA class( vector ), public, allocatable :: vecB class( vector ), public, allocatable :: vecS class( matrix ), public, allocatable :: mat_identity Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. procedure, public, pass(this) :: init Initilize integrator. private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. generic, public :: load => load_from_json Load integrator definition from file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( integrator_adv ) :: integrator_adv_euler_implicit !< Concrete class of integrator, Euler implicit scheme. real ( R_P ) :: alpha class ( matrix ), allocatable :: matA class ( vector ), allocatable :: vecB , vecS class ( matrix ), allocatable :: mat_identity contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_euler_implicit","tags":"","loc":"type/integrator_adv_euler_implicit.html","title":"integrator_adv_euler_implicit – openpde "},{"text":"type, public, extends( integrator_adv ) :: integrator_adv_euler_explicit type~~integrator_adv_euler_explicit~~InheritsGraph type~integrator_adv_euler_explicit integrator_adv_euler_explicit type~integrator_adv integrator_adv type~integrator_adv->type~integrator_adv_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of integrator, Euler explicit scheme. Variables description dt Type-Bound Procedures free init integrate load load_from_json Source Code integrator_adv_euler_explicit Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. procedure, public, pass(this) :: init Initilize integrator. private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. generic, public :: load => load_from_json Load integrator definition from file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( integrator_adv ) :: integrator_adv_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_euler_explicit","tags":"","loc":"type/integrator_adv_euler_explicit.html","title":"integrator_adv_euler_explicit – openpde "},{"text":"type, public, extends( integrator_adv ) :: integrator_adv_rk_implicit type~~integrator_adv_rk_implicit~~InheritsGraph type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~matrix matrix type~matrix->type~integrator_adv_rk_implicit matA, mat_identity type~vector vector type~vector->type~integrator_adv_rk_implicit vecB, vecS type~field field type~field->type~integrator_adv_rk_implicit stages type~mesh mesh type~mesh->type~field m type~integrator_adv integrator_adv type~integrator_adv->type~integrator_adv_rk_implicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of integrator, Euler implicit scheme. Variables description dt alpha matA vecB vecS mat_identity n_stages rk_alph rk_beta rk_gamm stages Type-Bound Procedures free init integrate load load_from_json Source Code integrator_adv_rk_implicit Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. real(kind=R_P), public :: alpha class( matrix ), public, allocatable :: matA class( vector ), public, allocatable :: vecB class( vector ), public, allocatable :: vecS class( matrix ), public, allocatable :: mat_identity integer(kind=I_P), public :: n_stages real(kind=R_P), public, allocatable :: rk_alph (:,:) real(kind=R_P), public, allocatable :: rk_beta (:) real(kind=R_P), public, allocatable :: rk_gamm (:) class( field ), public, allocatable :: stages (:,:) Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. procedure, public, pass(this) :: init Initilize integrator. private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. generic, public :: load => load_from_json Load integrator definition from file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( integrator_adv ) :: integrator_adv_rk_implicit !< Concrete class of integrator, Euler implicit scheme. real ( R_P ) :: alpha class ( matrix ), allocatable :: matA class ( vector ), allocatable :: vecB , vecS class ( matrix ), allocatable :: mat_identity integer ( I_P ) :: n_stages real ( R_P ), allocatable :: rk_alph (:,:) real ( R_P ), allocatable :: rk_beta (:) real ( R_P ), allocatable :: rk_gamm (:) class ( field ), allocatable :: stages (:,:) contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_adv_rk_implicit","tags":"","loc":"type/integrator_adv_rk_implicit.html","title":"integrator_adv_rk_implicit – openpde "},{"text":"type, public, extends( vector ) :: vector_simple type~~vector_simple~~InheritsGraph type~vector_simple vector_simple type~vector vector type~vector->type~vector_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Naive vector (not sparse) Variables description n val Type-Bound Procedures assignment(=) free init output set get assign_vector Source Code vector_simple Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Vector description. integer(kind=I_P), public :: n Vector size. real(kind=R_P), public, dimension(:), allocatable :: val Vector values Type-Bound Procedures generic, public :: assignment(=) => assign_vector Operator `= overloading. private subroutine assign_vector (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. procedure, public :: init private subroutine init (this, n, description, error) Initialize vector. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public :: output private subroutine output (this, filename, error) Print (naively) vector Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public :: set private subroutine set (this, i, val) Set vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. real(kind=R_P), intent(in) :: val Value to assign. procedure, public :: get private function get (this, i) result(val) Get vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. Return Value real(kind=R_P) Value to assign. procedure, private :: assign_vector private subroutine assign_vector (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. Source Code type , extends ( vector ) :: vector_simple !< Naive vector (not sparse) real ( R_P ), dimension (:), allocatable :: val !< Vector values contains ! deferred public methods procedure :: init procedure :: output procedure :: set procedure :: get ! deferred private methods procedure , private :: assign_vector endtype vector_simple","tags":"","loc":"type/vector_simple.html","title":"vector_simple – openpde "},{"text":"type, public, abstract :: vector Abstract class of vector Inherited By type~~vector~~InheritedByGraph type~vector vector type~linsolver_gmlapack linsolver_gmlapack type~vector->type~linsolver_gmlapack vec, sol type~integrator_adv_euler_implicit integrator_adv_euler_implicit type~vector->type~integrator_adv_euler_implicit vecB, vecS type~f2v_fd_2d f2v_FD_2D type~vector->type~f2v_fd_2d vec type~f2v f2v type~vector->type~f2v vec type~f2v_fd_1d f2v_FD_1D type~vector->type~f2v_fd_1d vec type~linsolver linsolver type~vector->type~linsolver vec, sol type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~vector->type~integrator_adv_rk_implicit vecB, vecS type~vector_simple vector_simple type~vector->type~vector_simple type~f2v->type~f2v_fd_2d type~f2v->type~f2v_fd_1d type~equation_adv equation_adv type~f2v->type~equation_adv f2v_opr type~linsolver->type~linsolver_gmlapack type~linsolver->type~equation_adv solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description n Type-Bound Procedures init output set get assign_vector assignment(=) free Source Code vector Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Vector description. integer(kind=I_P), public :: n Vector size. Type-Bound Procedures procedure( abstract_vectorinit ), public, deferred :: init Initilize vector. subroutine abstract_vectorinit (this, n, description, error) Prototype Initialize vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_vectoroutput ), public, deferred :: output Output vector. subroutine abstract_vectoroutput (this, filename, error) Prototype Output vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output filename. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_vectorset ), public, deferred :: set Set vector element. subroutine abstract_vectorset (this, i, val) Prototype Set vector element. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Index to set real(kind=R_P), intent(in) :: val Value to be assigned procedure( abstract_vectorget ), public, deferred :: get Get vector element. function abstract_vectorget (this, i) result(val) Prototype Set vector element. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Index to get Return Value real(kind=R_P) Value to be extracted procedure( abstract_assign ), private, deferred :: assign_vector Assign vector. subroutine abstract_assign (lhs, rhs) Prototype Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. generic, public :: assignment(=) => assign_vector Operator `= overloading. private subroutine assign_vector (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. Source Code type , abstract :: vector !< Abstract class of vector character ( len = :), allocatable :: description !< Vector description. integer ( I_P ) :: n !< Vector size. contains ! deferred public methods procedure ( abstract_vectorinit ), deferred :: init !< Initilize vector. procedure ( abstract_vectoroutput ) , deferred :: output !< Output vector. procedure ( abstract_vectorset ) , deferred :: set !< Set vector element. procedure ( abstract_vectorget ) , deferred :: get !< Get vector element. ! deferred private methods procedure ( abstract_assign ) , private , deferred :: assign_vector !< Assign vector. ! public operators generic , public :: assignment ( = ) => assign_vector !< Operator `= overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype vector","tags":"","loc":"type/vector.html","title":"vector – openpde "},{"text":"type, public :: equation_adv type~~equation_adv~~InheritsGraph type~equation_adv equation_adv type~mesh mesh type~mesh->type~equation_adv m type~multigrid multigrid type~mesh->type~multigrid meshes type~v2f v2f type~mesh->type~v2f mesh type~field field type~mesh->type~field m type~multigrid->type~equation_adv mg type~v2f->type~equation_adv v2f_opr type~matrix matrix type~matrix->type~equation_adv resvar_i type~linsolver linsolver type~matrix->type~linsolver mat type~f2v f2v type~f2v->type~equation_adv f2v_opr type~linsolver->type~equation_adv solver type~field->type~equation_adv resvar_e, resvar_mg, source_mg type~field->type~multigrid fields, fields0, residuals, sources, tau type~vector vector type~vector->type~f2v vec type~vector->type~linsolver vec, sol var pantypeequation_advInheritsGraph = svgPanZoom('#typeequation_advInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Simil-abstract class of equation_adv. The really-concrete types are implemented at application level (by the user). Variables description n_equ m enable_explicit enable_implicit enable_multigrid resvar_e n_size resvar_i solver f2v_opr v2f_opr mg resvar_mg source_mg Type-Bound Procedures bc_e bc_i init jacobian resid_e resid_emg resid_i free Source Code equation_adv Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. integer(kind=I_P), public :: n_equ = 0_I_P Number of equations class( mesh ), public, pointer :: m Mesh pointer logical, public :: enable_explicit = .false. Activate explicit solver. logical, public :: enable_implicit = .false. Activate implicit solver. logical, public :: enable_multigrid = .false. Activate multigrid solver. class( field ), public, allocatable, dimension(:) :: resvar_e Residuals field for explicit solver. integer(kind=I_P), public :: n_size Number of elements (vector size for linear solvers). class( matrix ), public, allocatable :: resvar_i Residuals field for implicit solver. class( linsolver ), public, allocatable :: solver Linear solver. class( f2v ), public, allocatable :: f2v_opr Field to vector converter. class( v2f ), public, allocatable :: v2f_opr Vector to Field converter. class( multigrid ), public, allocatable :: mg Multigrid solver. class( field ), public, allocatable, dimension(:) :: resvar_mg Residuals field for multigrid solver. class( field ), public, allocatable, dimension(:) :: source_mg Sources field for multigrid solver. Type-Bound Procedures procedure, public :: bc_e Equation boundary conditions explicit. private subroutine bc_e (this, inp, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. procedure, public :: bc_i Equation boundary conditions implicit. private subroutine bc_i (this, matA, vecB, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( matrix ), intent(inout), target :: matA Input field. class( vector ), intent(inout), target :: vecB Input field. real(kind=R_P), intent(in) :: t Time. procedure, public :: init Initialize the equation. private subroutine init (this, n_equ, field_mesh, inp, description, filename, error) Initialize equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. integer(kind=I_P), intent(in) :: n_equ Number of equations class( mesh ), intent(in), target :: field_mesh Mesh of the field. class( field ), intent(inout), target :: inp (:) Input field. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public :: jacobian Jacobian for multigrid solution private function jacobian (this, inp, t) result(opr) Return the jacobian, useful for multigrid Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( matrix ),\n  allocatable Field computed. procedure, public :: resid_e Residual explicit private subroutine resid_e (this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. procedure, public :: resid_emg Residual for multigrid private subroutine resid_emg (this, inp, t, output) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. class( field ), intent(out), target :: output (:) Input field. procedure, public :: resid_i Residual implicit private subroutine resid_i (this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. procedure, public :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. Source Code type :: equation_adv !< Simil-abstract class of equation_adv. !< !< The really-concrete types are implemented at application level (by the user). character ( len = :), allocatable :: description !< Equation description. integer ( I_P ) :: n_equ = 0_I_P !< Number of equations class ( mesh ), pointer :: m !< Mesh pointer logical :: enable_explicit = . false . !< Activate explicit solver. logical :: enable_implicit = . false . !< Activate implicit solver. logical :: enable_multigrid = . false . !< Activate multigrid solver. ! Explicit section class ( field ), allocatable , dimension (:) :: resvar_e !< Residuals field for explicit solver. ! Implicit section integer ( I_P ) :: n_size !< Number of elements (vector size for linear solvers). class ( matrix ), allocatable :: resvar_i !< Residuals field for implicit solver. class ( linsolver ), allocatable :: solver !< Linear solver. class ( f2v ), allocatable :: f2v_opr !< Field to vector converter. class ( v2f ), allocatable :: v2f_opr !< Vector to Field converter. ! Multigrid section class ( multigrid ), allocatable :: mg !< Multigrid solver. class ( field ), allocatable , dimension (:) :: resvar_mg !< Residuals field for multigrid solver. class ( field ), allocatable , dimension (:) :: source_mg !< Sources field for multigrid solver. contains ! not deferred but to be implemented by concrete procedure :: bc_e !< Equation boundary conditions explicit. procedure :: bc_i !< Equation boundary conditions implicit. procedure :: init !< Initialize the equation. procedure :: jacobian !< Jacobian for multigrid solution procedure :: resid_e !< Residual explicit procedure :: resid_emg !< Residual for multigrid procedure :: resid_i !< Residual implicit ! public methods procedure :: free !< Free dynamic memory. endtype equation_adv","tags":"","loc":"type/equation_adv.html","title":"equation_adv – openpde "},{"text":"type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D type~~spatial_operator_d2_fd_2d~~InheritsGraph type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d2_FD_2D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D !< Concrete class of spatial operator of second derivative for Finite Difference 2D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_2D","tags":"","loc":"type/spatial_operator_d2_fd_2d.html","title":"spatial_operator_d2_FD_2D – openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_d2 type~~spatial_operator_d2~~InheritsGraph type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of spatial operator of second derivative. Inherited By type~~spatial_operator_d2~~InheritedByGraph type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2->type~spatial_operator_d2_fd_1d type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator_d2_fv_1d spatial_operator_d2_FV_1D type~spatial_operator_d2->type~spatial_operator_d2_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description Type-Bound Procedures operate Source Code spatial_operator_d2 Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. function abstract_operate (this, inp, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_d2 !< Abstract class of spatial operator of second derivative. endtype spatial_operator_d2","tags":"","loc":"type/spatial_operator_d2.html","title":"spatial_operator_d2 – openpde "},{"text":"type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D type~~spatial_operator_d1_fd_2d~~InheritsGraph type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d1_FD_2D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D !< Concrete class of spatial operator of first derivative for Finite Difference 2D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_2D","tags":"","loc":"type/spatial_operator_d1_fd_2d.html","title":"spatial_operator_d1_FD_2D – openpde "},{"text":"type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FV_1D type~~spatial_operator_d1_fv_1d~~InheritsGraph type~spatial_operator_d1_fv_1d spatial_operator_d1_FV_1D type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~spatial_operator_d1_fv_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of first derivative for Finite Volume 1D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d1_FV_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FV_1D !< Concrete class of spatial operator of first derivative for Finite Volume 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FV_1D","tags":"","loc":"type/spatial_operator_d1_fv_1d.html","title":"spatial_operator_d1_FV_1D – openpde "},{"text":"type, public, abstract, extends( spatial_operator ) :: spatial_operator_d1 type~~spatial_operator_d1~~InheritsGraph type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of spatial operator of first derivative. Inherited By type~~spatial_operator_d1~~InheritedByGraph type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1_fv_1d spatial_operator_d1_FV_1D type~spatial_operator_d1->type~spatial_operator_d1_fv_1d type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1->type~spatial_operator_d1_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description Type-Bound Procedures operate Source Code spatial_operator_d1 Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. function abstract_operate (this, inp, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , abstract , extends ( spatial_operator ) :: spatial_operator_d1 !< Abstract class of spatial operator of first derivative. endtype spatial_operator_d1","tags":"","loc":"type/spatial_operator_d1.html","title":"spatial_operator_d1 – openpde "},{"text":"type, public, abstract :: spatial_operator Abstract class of spatial operator. Inherited By type~~spatial_operator~~InheritedByGraph type~spatial_operator spatial_operator type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator->type~spatial_operator_d1 type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator->type~spatial_operator_d2 type~spatial_operator_d1_fv_1d spatial_operator_d1_FV_1D type~spatial_operator_d1->type~spatial_operator_d1_fv_1d type~spatial_operator_d1_fd_2d spatial_operator_d1_FD_2D type~spatial_operator_d1->type~spatial_operator_d1_fd_2d type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1->type~spatial_operator_d1_fd_1d type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2->type~spatial_operator_d2_fd_1d type~spatial_operator_d2_fd_2d spatial_operator_d2_FD_2D type~spatial_operator_d2->type~spatial_operator_d2_fd_2d type~spatial_operator_d2_fv_1d spatial_operator_d2_FV_1D type~spatial_operator_d2->type~spatial_operator_d2_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description Type-Bound Procedures operate Source Code spatial_operator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. function abstract_operate (this, inp, dir) result(opr) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , abstract :: spatial_operator !< Abstract class of spatial operator. character ( len = :), allocatable :: description !< Operator description. contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype spatial_operator","tags":"","loc":"type/spatial_operator.html","title":"spatial_operator – openpde "},{"text":"type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FV_1D type~~spatial_operator_d2_fv_1d~~InheritsGraph type~spatial_operator_d2_fv_1d spatial_operator_d2_FV_1D type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~spatial_operator_d2_fv_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of second derivative for Finite Volume 1D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d2_FV_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FV_1D !< Concrete class of spatial operator of second derivative for Finite Volume 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FV_1D","tags":"","loc":"type/spatial_operator_d2_fv_1d.html","title":"spatial_operator_d2_FV_1D – openpde "},{"text":"type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D type~~spatial_operator_d1_fd_1d~~InheritsGraph type~spatial_operator_d1_fd_1d spatial_operator_d1_FD_1D type~spatial_operator_d1 spatial_operator_d1 type~spatial_operator_d1->type~spatial_operator_d1_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d1_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D !< Concrete class of spatial operator of first derivative for Finite Difference 1D methods. contains ! deferred public methods procedure :: operate !< Operator operation. endtype spatial_operator_d1_FD_1D","tags":"","loc":"type/spatial_operator_d1_fd_1d.html","title":"spatial_operator_d1_FD_1D – openpde "},{"text":"type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D type~~spatial_operator_d2_fd_1d~~InheritsGraph type~spatial_operator_d2_fd_1d spatial_operator_d2_FD_1D type~spatial_operator_d2 spatial_operator_d2 type~spatial_operator_d2->type~spatial_operator_d2_fd_1d type~spatial_operator spatial_operator type~spatial_operator->type~spatial_operator_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Variables description Type-Bound Procedures operate Source Code spatial_operator_d2_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Source Code type , extends ( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D !< Concrete class of spatial operator of second derivative for Finite Difference 1D methods. contains procedure :: operate !< Operator operation. endtype spatial_operator_d2_FD_1D","tags":"","loc":"type/spatial_operator_d2_fd_1d.html","title":"spatial_operator_d2_FD_1D – openpde "},{"text":"type, public, extends( f2v ) :: f2v_FD_1D type~~f2v_fd_1d~~InheritsGraph type~f2v_fd_1d f2v_FD_1D type~vector vector type~vector->type~f2v_fd_1d vec type~f2v f2v type~vector->type~f2v vec type~f2v->type~f2v_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of f2v (field to vector) for FD 1D Variables vec Type-Bound Procedures operate Source Code f2v_FD_1D Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector. Source Code type , extends ( f2v ) :: f2v_FD_1D !< Concrete class of f2v (field to vector) for FD 1D contains procedure :: operate !< Operator operation. endtype f2v_FD_1D","tags":"","loc":"type/f2v_fd_1d.html","title":"f2v_FD_1D – openpde "},{"text":"type, public, extends( f2v ) :: f2v_FD_2D type~~f2v_fd_2d~~InheritsGraph type~f2v_fd_2d f2v_FD_2D type~vector vector type~vector->type~f2v_fd_2d vec type~f2v f2v type~vector->type~f2v vec type~f2v->type~f2v_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of f2v (field to vector) for FD 1D Variables vec Type-Bound Procedures operate Source Code f2v_FD_2D Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. private function operate (this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector. Source Code type , extends ( f2v ) :: f2v_FD_2D !< Concrete class of f2v (field to vector) for FD 1D contains procedure :: operate !< Operator operation. endtype f2v_FD_2D","tags":"","loc":"type/f2v_fd_2d.html","title":"f2v_FD_2D – openpde "},{"text":"type, public, abstract :: f2v type~~f2v~~InheritsGraph type~f2v f2v type~vector vector type~vector->type~f2v vec Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of f2v. Inherited By type~~f2v~~InheritedByGraph type~f2v f2v type~equation_adv equation_adv type~f2v->type~equation_adv f2v_opr type~f2v_fd_1d f2v_FD_1D type~f2v->type~f2v_fd_1d type~f2v_fd_2d f2v_FD_2D type~f2v->type~f2v_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables vec Type-Bound Procedures operate Source Code f2v Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure( abstract_operate ), public, deferred, pass(this) :: operate Operator function. function abstract_operate (this, fie) result(vec) Prototype Operator function. Arguments Type Intent Optional Attributes Name class( f2v ), intent(in) :: this The operator. class( field ), intent(in), target, dimension(:) :: fie Input field. Return Value class( vector ),\n  allocatable Resulting vector. Source Code type , abstract :: f2v !< Abstract class of f2v. class ( vector ), allocatable :: vec !< Vector used only to decide the type contains ! deferred public methods procedure ( abstract_operate ), pass ( this ), deferred :: operate !< Operator function. endtype f2v","tags":"","loc":"type/f2v.html","title":"f2v – openpde "},{"text":"type, public, extends( integrator ) :: integrator_euler_explicit type~~integrator_euler_explicit~~InheritsGraph type~integrator_euler_explicit integrator_euler_explicit type~integrator integrator type~integrator->type~integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of integrator, Euler explicit scheme. Variables description dt Type-Bound Procedures free init integrate load load_from_json Source Code integrator_euler_explicit Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. procedure, public, pass(this) :: init Initilize integrator. private subroutine init (this, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. generic, public :: load => load_from_json Load integrator definition from file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( integrator ) :: integrator_euler_explicit !< Concrete class of integrator, Euler explicit scheme. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize integrator. procedure , pass ( this ) :: integrate !< Integrate the field accordingly to the equation. ! public methods generic :: load => load_from_json !< Load integrator definition from file. ! private methods procedure , pass ( this ), private :: load_from_json !< Load integrator definition from jSON file. endtype integrator_euler_explicit","tags":"","loc":"type/integrator_euler_explicit.html","title":"integrator_euler_explicit – openpde "},{"text":"type, public, abstract :: integrator Abstract class of integrator. Inherited By type~~integrator~~InheritedByGraph type~integrator integrator type~integrator_euler_explicit integrator_euler_explicit type~integrator->type~integrator_euler_explicit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description dt Type-Bound Procedures init integrate free Source Code integrator Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure( abstract_init ), public, deferred, pass(this) :: init Initilize integrator. subroutine abstract_init (this, description, filename, error) Prototype Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_integrate ), public, deferred, pass(this) :: integrate Integrate the field accordingly to the equation. function abstract_integrate (this, equ, t, inp) result(error) Prototype Integrate the field accordingly to the equation. Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Source Code type , abstract :: integrator !< Abstract class of integrator. character ( len = :), allocatable :: description !< Integrator description. real ( R_P ) :: dt = 0._R_P !< Time step. contains ! deferred public methods procedure ( abstract_init ), pass ( this ), deferred :: init !< Initilize integrator. procedure ( abstract_integrate ), pass ( this ), deferred :: integrate !< Integrate the field accordingly to the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype integrator","tags":"","loc":"type/integrator.html","title":"integrator – openpde "},{"text":"type, public, extends( multigrid ) :: multigrid_FD_1D type~~multigrid_fd_1d~~InheritsGraph type~multigrid_fd_1d multigrid_FD_1D type~mesh mesh type~mesh->type~multigrid_fd_1d meshes type~field field type~mesh->type~field m type~multigrid multigrid type~mesh->type~multigrid meshes type~field->type~multigrid_fd_1d fields, fields0, residuals, sources, tau type~field->type~multigrid fields, fields0, residuals, sources, tau type~multigrid->type~multigrid_fd_1d var pantypemultigrid_fd_1dInheritsGraph = svgPanZoom('#typemultigrid_fd_1dInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description fields meshes fields0 residuals sources levels_number max_iterations n_it_up n_it_down stability tau tolerance norm Type-Bound Procedures create_subgrids_field init Source Code multigrid_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( field ), public, allocatable :: fields (:,:) Field on each MG level. class( mesh ), public, allocatable :: meshes (:) Meshes on each MG level. class( field ), public, allocatable :: fields0 (:,:) Initial field on each MG level. class( field ), public, allocatable :: residuals (:,:) Residual field on each MG level. class( field ), public, allocatable :: sources (:,:) Source field on each MG level. integer(kind=I_P), public :: levels_number MG levels number. integer(kind=I_P), public :: max_iterations Maximum number of iterations. integer(kind=I_P), public, allocatable :: n_it_up (:) Number of iteration in \"up\" cycle for each MG level. integer(kind=I_P), public, allocatable :: n_it_down (:) Number of iteration in \"up\" cycle for each MG level. real(kind=R_P), public, allocatable :: stability (:) Stability coefficient for each MG level. class( field ), public, allocatable :: tau (:,:) Local pseudo-dt for each MG level. real(kind=R_P), public :: tolerance Tolerance on iterative convergence. real(kind=R_P), public :: norm Norm of residuals. Type-Bound Procedures procedure, public :: create_subgrids_field Create subgrid-levels field. private subroutine create_subgrids_field (this, inp, subgrids) Create subgrid-levels field. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. procedure, public :: init Init multigrid solver. private subroutine init (this, inp, levels_number) Init multigrid solver. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Number of MG levels. Source Code type , extends ( multigrid ) :: multigrid_FD_1D contains ! deferred public methods procedure :: create_subgrids_field !< Create subgrid-levels field. procedure :: init !< Init multigrid solver. endtype multigrid_FD_1D","tags":"","loc":"type/multigrid_fd_1d.html","title":"multigrid_FD_1D – openpde "},{"text":"type, public, abstract :: multigrid type~~multigrid~~InheritsGraph type~multigrid multigrid type~mesh mesh type~mesh->type~multigrid meshes type~field field type~mesh->type~field m type~field->type~multigrid fields, fields0, residuals, sources, tau Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract class of multigrid solver. Inherited By type~~multigrid~~InheritedByGraph type~multigrid multigrid type~equation_adv equation_adv type~multigrid->type~equation_adv mg type~multigrid_fd_1d multigrid_FD_1D type~multigrid->type~multigrid_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description fields meshes fields0 residuals sources levels_number max_iterations n_it_up n_it_down stability tau tolerance norm Type-Bound Procedures create_subgrids_field init Source Code multigrid Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( field ), public, allocatable :: fields (:,:) Field on each MG level. class( mesh ), public, allocatable :: meshes (:) Meshes on each MG level. class( field ), public, allocatable :: fields0 (:,:) Initial field on each MG level. class( field ), public, allocatable :: residuals (:,:) Residual field on each MG level. class( field ), public, allocatable :: sources (:,:) Source field on each MG level. integer(kind=I_P), public :: levels_number MG levels number. integer(kind=I_P), public :: max_iterations Maximum number of iterations. integer(kind=I_P), public, allocatable :: n_it_up (:) Number of iteration in \"up\" cycle for each MG level. integer(kind=I_P), public, allocatable :: n_it_down (:) Number of iteration in \"up\" cycle for each MG level. real(kind=R_P), public, allocatable :: stability (:) Stability coefficient for each MG level. class( field ), public, allocatable :: tau (:,:) Local pseudo-dt for each MG level. real(kind=R_P), public :: tolerance Tolerance on iterative convergence. real(kind=R_P), public :: norm Norm of residuals. Type-Bound Procedures procedure( create_subgrids_field_interface ), public, deferred :: create_subgrids_field Create subgrid-levels field. subroutine create_subgrids_field_interface (this, inp, subgrids) Prototype Create subgrid-levels field. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. procedure( init_interface ), public, deferred :: init Init multigrid solver. subroutine init_interface (this, inp, levels_number) Prototype Init multigrid solver. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Levels number. Source Code type , abstract :: multigrid !< Abstract class of multigrid solver. character ( len = :), allocatable :: description !< Description. class ( field ), allocatable :: fields (:,:) !< Field on each MG level. class ( mesh ), allocatable :: meshes (:) !< Meshes on each MG level. class ( field ), allocatable :: fields0 (:,:) !< Initial field on each MG level. class ( field ), allocatable :: residuals (:,:) !< Residual field on each MG level. class ( field ), allocatable :: sources (:,:) !< Source field on each MG level. integer ( I_P ) :: levels_number !< MG levels number. integer ( I_P ) :: max_iterations !< Maximum number of iterations. integer ( I_P ), allocatable :: n_it_up (:) !< Number of iteration in \"up\" cycle for each MG level. integer ( I_P ), allocatable :: n_it_down (:) !< Number of iteration in \"up\" cycle for each MG level. real ( R_P ), allocatable :: stability (:) !< Stability coefficient for each MG level. class ( field ), allocatable :: tau (:,:) !< Local pseudo-dt for each MG level. real ( R_P ) :: tolerance !< Tolerance on iterative convergence. real ( R_P ) :: norm !< Norm of residuals. contains ! deferred public methods procedure ( create_subgrids_field_interface ), deferred :: create_subgrids_field !< Create subgrid-levels field. procedure ( init_interface ), deferred :: init !< Init multigrid solver. ! procedure(abstract_prolungation), deferred :: prolongation ! procedure(abstract_restriction), deferred :: restriction ! procedure(abstract_collect), deferred :: collect ! procedure(abstract_smoother), deferred :: smoother endtype multigrid","tags":"","loc":"type/multigrid.html","title":"multigrid – openpde "},{"text":"type, public, abstract :: matrix Abstract class of matrix. Inherited By type~~matrix~~InheritedByGraph type~matrix matrix type~linsolver_gmlapack linsolver_gmlapack type~matrix->type~linsolver_gmlapack mat type~f2m_d2_fd_2d f2m_d2_FD_2D type~matrix->type~f2m_d2_fd_2d mat type~f2m_d1_fd_1d f2m_d1_FD_1D type~matrix->type~f2m_d1_fd_1d mat type~integrator_adv_euler_implicit integrator_adv_euler_implicit type~matrix->type~integrator_adv_euler_implicit matA, mat_identity type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~matrix->type~integrator_adv_rk_implicit matA, mat_identity type~f2m_d1 f2m_d1 type~matrix->type~f2m_d1 mat type~equation_adv equation_adv type~matrix->type~equation_adv resvar_i type~f2m_d2 f2m_d2 type~matrix->type~f2m_d2 mat type~f2m_d2_fd_1d f2m_d2_FD_1D type~matrix->type~f2m_d2_fd_1d mat type~linsolver linsolver type~matrix->type~linsolver mat type~f2m f2m type~matrix->type~f2m mat type~matrix_simple matrix_simple type~matrix->type~matrix_simple type~f2m_d1->type~f2m_d1_fd_1d type~f2m_d2->type~f2m_d2_fd_2d type~f2m_d2->type~f2m_d2_fd_1d type~linsolver->type~linsolver_gmlapack type~linsolver->type~equation_adv solver type~f2m->type~f2m_d1 type~f2m->type~f2m_d2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description n Type-Bound Procedures init output set add sub realmul assign_matrix assignment(=) operator(+) operator(-) operator(*) free Source Code matrix Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Matrix description. integer(kind=I_P), public :: n Type-Bound Procedures procedure( abstract_matrixinit ), public, deferred :: init Initilize matrix. subroutine abstract_matrixinit (this, n, description, error) Prototype Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Initialization file name. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_matrixoutput ), public, deferred :: output Output matrix. subroutine abstract_matrixoutput (this, filename, error) Prototype Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_matrixset ), public, deferred :: set Set matrix value. subroutine abstract_matrixset (this, i, j, val) Prototype Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this integer(kind=I_P), intent(in) :: i integer(kind=I_P), intent(in) :: j real(kind=R_P), intent(in) :: val procedure( abstract_simmetric_operator ), private, deferred :: add Add matrix. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Result procedure( abstract_simmetric_operator ), private, deferred :: sub Sub matrix. function abstract_simmetric_operator (lhs, rhs) result(opr) Prototype Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Result procedure( abstract_real_op_field ), private, deferred, pass(rhs) :: realmul Real*matrix. function abstract_real_op_field (lhs, rhs) result(opr) Prototype Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. procedure( abstract_assign ), private, deferred :: assign_matrix Assign matrix. subroutine abstract_assign (lhs, rhs) Prototype Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. generic, public :: assignment(=) => assign_matrix Operator = overloading. private subroutine assign_matrix (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator `- overloading. private function sub (lhs, rhs) result(opr) Subtract matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. generic, public :: operator(*) => realmul Operator * overloading. private function realmul (lhs, rhs) result(opr) Real matrix multiply. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix_simple ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The integrator. Source Code type , abstract :: matrix !< Abstract class of matrix. character ( len = :), allocatable :: description !< Matrix description. integer ( I_P ) :: n contains ! deferred public methods procedure ( abstract_matrixinit ), deferred :: init !< Initilize matrix. procedure ( abstract_matrixoutput ) , deferred :: output !< Output matrix. procedure ( abstract_matrixset ) , deferred :: set !< Set matrix value. ! deferred private methods procedure ( abstract_simmetric_operator ) , private , deferred :: add !< Add matrix. procedure ( abstract_simmetric_operator ) , private , deferred :: sub !< Sub matrix. procedure ( abstract_real_op_field ), pass ( rhs ), private , deferred :: realmul !< Real*matrix. procedure ( abstract_assign ) , private , deferred :: assign_matrix !< Assign matrix. ! public operators generic , public :: assignment ( = ) => assign_matrix !< Operator `=` overloading. generic , public :: operator ( + ) => add !< Operator `+` overloading. generic , public :: operator ( - ) => sub !< Operator `- overloading. generic , public :: operator ( * ) => realmul !< Operator `*` overloading. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype matrix","tags":"","loc":"type/matrix.html","title":"matrix – openpde "},{"text":"type, public, extends( matrix ) :: matrix_simple type~~matrix_simple~~InheritsGraph type~matrix_simple matrix_simple type~matrix matrix type~matrix->type~matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Naive matrix (not sparse) Variables description n val Type-Bound Procedures assignment(=) operator(+) operator(-) operator(*) free init output set assign_matrix add sub realmul Source Code matrix_simple Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Matrix description. integer(kind=I_P), public :: n real(kind=R_P), public, dimension(:,:), allocatable :: val values Type-Bound Procedures generic, public :: assignment(=) => assign_matrix Operator = overloading. private subroutine assign_matrix (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. generic, public :: operator(+) => add Operator + overloading. private function add (lhs, rhs) result(opr) Add matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. generic, public :: operator(-) => sub Operator `- overloading. private function sub (lhs, rhs) result(opr) Subtract matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. generic, public :: operator(*) => realmul Operator * overloading. private function realmul (lhs, rhs) result(opr) Real matrix multiply. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix_simple ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The integrator. procedure, public :: init private subroutine init (this, n, description, error) Initialize matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Matrix size. character(len=*), intent(in), optional :: description Matrix description. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public :: output private subroutine output (this, filename, error) Print matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public :: set private subroutine set (this, i, j, val) Set matrix value Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P), intent(in) :: i Index i where set matrix. integer(kind=I_P), intent(in) :: j Index i where set matrix. real(kind=R_P), intent(in) :: val Value to be inserted procedure, private :: assign_matrix private subroutine assign_matrix (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. procedure, private :: add private function add (lhs, rhs) result(opr) Add matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. procedure, private :: sub private function sub (lhs, rhs) result(opr) Subtract matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. procedure, public, pass(rhs) :: realmul private function realmul (lhs, rhs) result(opr) Real matrix multiply. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix_simple ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. Source Code type , extends ( matrix ) :: matrix_simple !< Naive matrix (not sparse) real ( R_P ), dimension (:,:), allocatable :: val !< values contains ! deferred public methods procedure :: init procedure :: output procedure :: set ! deferred private methods procedure , private :: assign_matrix procedure , private :: add procedure , private :: sub procedure , pass ( rhs ) :: realmul endtype matrix_simple","tags":"","loc":"type/matrix_simple.html","title":"matrix_simple – openpde "},{"text":"type, public, abstract :: equation Abstract class of equation. The concrete types are implemented at application level (by the user) predefined examples might be provided as well. Variables description Type-Bound Procedures bc forcing init free Source Code equation Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. Type-Bound Procedures procedure( abstract_bc ), public, deferred, pass(this) :: bc Equation boundary conditions. subroutine abstract_bc (this, inp, t) Prototype Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. procedure( abstract_forcing ), public, deferred, pass(this) :: forcing Forcing equation. function abstract_forcing (this, inp, t) result(opr) Prototype Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. procedure( abstract_init ), public, deferred, pass(this) :: init Initialize the equation. subroutine abstract_init (this, description, filename, error) Prototype Initialize equation. Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Source Code type , abstract :: equation !< Abstract class of equation. !< !< The concrete types are implemented at application level (by the user) predefined examples might be provided as well. character ( len = :), allocatable :: description !< Equation description. contains ! deferred public methods procedure ( abstract_bc ), pass ( this ), deferred :: bc !< Equation boundary conditions. procedure ( abstract_forcing ), pass ( this ), deferred :: forcing !< Forcing equation. procedure ( abstract_init ), pass ( this ), deferred :: init !< Initialize the equation. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype equation","tags":"","loc":"type/equation.html","title":"equation – openpde "},{"text":"type, public, extends( mesh ) :: mesh_FD_2D type~~mesh_fd_2d~~InheritsGraph type~mesh_fd_2d mesh_FD_2D type~mesh mesh type~mesh->type~mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of mesh for Finite Difference 2D methods. Variables description nx ny ngx ngy s hx hy Type-Bound Procedures free init output set Source Code mesh_FD_2D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: nx = 0 Number of X points. integer(kind=I_P), public :: ny = 0 Number of Y points. integer(kind=I_P), public :: ngx = 0 Number of X ghost points. integer(kind=I_P), public :: ngy = 0 Number of Y ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: hx = 0._R_P Cell X size. real(kind=R_P), public :: hy = 0._R_P Cell Y size. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. procedure, public, pass(this) :: init Initilize mesh. private pure subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: set Set mesh. private pure subroutine set (this, description, nx, ny, ngx, ngy, s, hx, hy, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( mesh ) :: mesh_FD_2D !< Concrete class of mesh for Finite Difference 2D methods. integer ( I_P ) :: nx = 0 !< Number of X points. integer ( I_P ) :: ny = 0 !< Number of Y points. integer ( I_P ) :: ngx = 0 !< Number of X ghost points. integer ( I_P ) :: ngy = 0 !< Number of Y ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: hx = 0._R_P !< Cell X size. real ( R_P ) :: hy = 0._R_P !< Cell Y size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods procedure , pass ( this ) :: set !< Set mesh. endtype mesh_FD_2D","tags":"","loc":"type/mesh_fd_2d.html","title":"mesh_FD_2D – openpde "},{"text":"type, public :: mesh_block_FV_1D Concrete class of mesh block for Finite Volume 1D methods. Variables n ng h Type-Bound Procedures output load set load_from_json Source Code mesh_block_FV_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n = 0 Number of nodes. integer(kind=I_P), public :: ng = 0 Number of ghost cells. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Output block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: load => load_from_json Load block definition from file. private subroutine load_from_json (this, json, block_number, error) Load block definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. type(json_file), intent(inout) :: json JSON file handler. character(len=*), intent(in) :: block_number Block number ID, e.g. 'block5', 'block33'. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: set Set block. private pure subroutine set (this, n, ng, h, error) Set block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. integer(kind=I_P), intent(in), optional :: n Number of cells. integer(kind=I_P), intent(in), optional :: ng Number of ghost cells. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load block definition from jSON file. private subroutine load_from_json (this, json, block_number, error) Load block definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. type(json_file), intent(inout) :: json JSON file handler. character(len=*), intent(in) :: block_number Block number ID, e.g. 'block5', 'block33'. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type :: mesh_block_FV_1D !< Concrete class of mesh block for Finite Volume 1D methods. integer ( I_P ) :: n = 0 !< Number of nodes. integer ( I_P ) :: ng = 0 !< Number of ghost cells. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! public methods procedure , pass ( this ) :: output !< Output data. generic :: load => load_from_json !< Load block definition from file. procedure , pass ( this ) :: set !< Set block. ! private methods procedure , pass ( this ), private :: load_from_json !< Load block definition from jSON file. endtype mesh_block_FV_1D","tags":"","loc":"type/mesh_block_fv_1d.html","title":"mesh_block_FV_1D – openpde "},{"text":"type, public, abstract :: mesh Abstract class of mesh. Inherited By type~~mesh~~InheritedByGraph type~mesh mesh type~v2f_fd_1d v2f_FD_1D type~mesh->type~v2f_fd_1d mesh type~field_surface field_surface type~mesh->type~field_surface m type~field_fd_1d field_FD_1D type~mesh->type~field_fd_1d m type~v2f v2f type~mesh->type~v2f mesh type~field_surface_fv_1d field_surface_FV_1D type~mesh->type~field_surface_fv_1d m type~multigrid_fd_1d multigrid_FD_1D type~mesh->type~multigrid_fd_1d meshes type~multigrid multigrid type~mesh->type~multigrid meshes type~field field type~mesh->type~field m type~field_fv_1d field_FV_1D type~mesh->type~field_fv_1d m type~field_fd_2d field_FD_2D type~mesh->type~field_fd_2d m type~v2f_fd_2d v2f_FD_2D type~mesh->type~v2f_fd_2d mesh type~equation_adv equation_adv type~mesh->type~equation_adv m type~mesh_fd_2d mesh_FD_2D type~mesh->type~mesh_fd_2d type~mesh_fd_1d mesh_FD_1D type~mesh->type~mesh_fd_1d type~mesh_fv_1d mesh_FV_1D type~mesh->type~mesh_fv_1d type~field_surface->type~field_surface_fv_1d type~v2f->type~v2f_fd_1d type~v2f->type~v2f_fd_2d type~v2f->type~equation_adv v2f_opr type~multigrid->type~multigrid_fd_1d type~multigrid->type~equation_adv mg type~field->type~field_surface type~field->type~field_fd_1d type~field->type~multigrid_fd_1d fields, fields0, residuals, sources, tau type~field->type~multigrid fields, fields0, residuals, sources, tau type~field->type~field_fv_1d type~field->type~field_fd_2d type~field->type~equation_adv resvar_e, resvar_mg, source_mg type~integrator_adv_rk_implicit integrator_adv_rk_implicit type~field->type~integrator_adv_rk_implicit stages var pantypemeshInheritedByGraph = svgPanZoom('#typemeshInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description Type-Bound Procedures init output free Source Code mesh Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure( abstract_meshinit ), public, deferred, pass(this) :: init Initilize mesh. subroutine abstract_meshinit (this, description, filename, error) Prototype Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure( abstract_meshoutput ), public, deferred, pass(this) :: output Output mesh. subroutine abstract_meshoutput (this, error) Prototype Output mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Source Code type , abstract :: mesh !< Abstract class of mesh. character ( len = :), allocatable :: description !< Mesh description. contains ! deferred public methods procedure ( abstract_meshinit ), pass ( this ), deferred :: init !< Initilize mesh. procedure ( abstract_meshoutput ) , pass ( this ), deferred :: output !< Output mesh. ! public methods procedure , pass ( this ) :: free !< Free dynamic memory. endtype mesh","tags":"","loc":"type/mesh.html","title":"mesh – openpde "},{"text":"type, public, extends( mesh ) :: mesh_FD_1D type~~mesh_fd_1d~~InheritsGraph type~mesh_fd_1d mesh_FD_1D type~mesh mesh type~mesh->type~mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of mesh for Finite Difference 1D methods. Variables description n ng s h Type-Bound Procedures free init output load set assignment(=) assign_mesh_FD_1D load_from_json Source Code mesh_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: n = 0 Number of points. integer(kind=I_P), public :: ng = 0 Number of ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. procedure, public, pass(this) :: init Initilize mesh. private subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: load => load_from_json Load mesh definition from file. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: set Set mesh. private pure subroutine set (this, description, n, ng, s, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: assignment(=) => assign_mesh_FD_1D Overloading = operator. private elemental subroutine assign_mesh_FD_1D (lhs, rhs) Implementation of = operator. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: lhs Left hand side. type( mesh_FD_1D ), intent(in) :: rhs Right hand side. procedure, private, pass(lhs) :: assign_mesh_FD_1D Implementation of = operator. private elemental subroutine assign_mesh_FD_1D (lhs, rhs) Implementation of = operator. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: lhs Left hand side. type( mesh_FD_1D ), intent(in) :: rhs Right hand side. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( mesh ) :: mesh_FD_1D !< Concrete class of mesh for Finite Difference 1D methods. integer ( I_P ) :: n = 0 !< Number of points. integer ( I_P ) :: ng = 0 !< Number of ghost points. integer ( I_P ) :: s = 0 !< Number of replicas for steps/stages. real ( R_P ) :: h = 0._R_P !< Cell size. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! operators generic :: assignment ( = ) => assign_mesh_FD_1D !< Overloading `=` operator. ! private methods procedure , pass ( lhs ), private :: assign_mesh_FD_1D !< Implementation of `=` operator. procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FD_1D","tags":"","loc":"type/mesh_fd_1d.html","title":"mesh_FD_1D – openpde "},{"text":"type, public, extends( mesh ) :: mesh_FV_1D type~~mesh_fv_1d~~InheritsGraph type~mesh_fv_1d mesh_FV_1D mesh_block_FV_1D mesh_block_FV_1D mesh_block_FV_1D->type~mesh_fv_1d blocks type~mesh mesh type~mesh->type~mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Concrete class of mesh for Finite Volume 1D methods. Variables description nb blocks Type-Bound Procedures free init output load set load_from_json Source Code mesh_FV_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: nb Number of blocks. type(mesh_block_FV_1D), public, allocatable :: blocks (:) The blocks. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. procedure, public, pass(this) :: init Initilize mesh. private subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: output Output data. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. generic, public :: load => load_from_json Load mesh definition from file. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. procedure, public, pass(this) :: set Set mesh. private pure subroutine set (this, description, nb, n, ng, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nb Number of blocks. integer(kind=I_P), intent(in), optional :: n (1:) Number of points for each block. integer(kind=I_P), intent(in), optional :: ng (1:) Number of ghost points for each block. real(kind=R_P), intent(in), optional :: h (1:) Cell size for each block. integer(kind=I_P), intent(out), optional :: error Error status. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code type , extends ( mesh ) :: mesh_FV_1D !< Concrete class of mesh for Finite Volume 1D methods. integer ( I_P ) :: nb !< Number of blocks. type ( mesh_block_FV_1D ), allocatable :: blocks (:) !< The blocks. contains ! deferred public methods procedure , pass ( this ) :: init !< Initilize mesh. procedure , pass ( this ) :: output !< Output data. ! public methods generic :: load => load_from_json !< Load mesh definition from file. procedure , pass ( this ) :: set !< Set mesh. ! private methods procedure , pass ( this ), private :: load_from_json !< Load mesh definition from jSON file. endtype mesh_FV_1D","tags":"","loc":"type/mesh_fv_1d.html","title":"mesh_FV_1D – openpde "},{"text":"abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh(this, field_mesh, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Associate a mesh to field.","tags":"","loc":"interface/abstract_associate_mesh.html","title":"abstract_associate_mesh – openpde"},{"text":"abstract interface Initialize the field. private subroutine abstract_init(this, field_mesh, description, error) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize the field.","tags":"","loc":"interface/abstract_init.html","title":"abstract_init – openpde"},{"text":"abstract interface Output the field. private subroutine abstract_output(this, filename, error) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. Description Output the field.","tags":"","loc":"interface/abstract_output.html","title":"abstract_output – openpde"},{"text":"abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Symmetric operator field.op.field.","tags":"","loc":"interface/abstract_simmetric_operator.html","title":"abstract_simmetric_operator – openpde"},{"text":"abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator field.op.real.","tags":"","loc":"interface/abstract_field_op_real.html","title":"abstract_field_op_real – openpde"},{"text":"abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. Description Non symmetric operator real.op.field.","tags":"","loc":"interface/abstract_real_op_field.html","title":"abstract_real_op_field – openpde"},{"text":"abstract interface Assignment overloading. private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Description Assignment overloading.","tags":"","loc":"interface/abstract_assign.html","title":"abstract_assign – openpde"},{"text":"abstract interface Compute fluxes of field through surfaces. private subroutine abstract_compute_fluxes(this, field_cell, error) Arguments Type Intent Optional Attributes Name class( field_surface ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. Description Compute fluxes of field through surfaces.","tags":"","loc":"interface/abstract_compute_fluxes.html","title":"abstract_compute_fluxes – openpde"},{"text":"abstract interface Operator operation. private subroutine abstract_operate(this, vec, fie) Arguments Type Intent Optional Attributes Name class( v2f ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Resulting field. Description Operator function.","tags":"","loc":"interface/abstract_operate.html","title":"abstract_operate – openpde"},{"text":"abstract interface private subroutine abstract_init(this, n) Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this integer(kind=I_P) :: n Description Init linsolver.","tags":"","loc":"interface/abstract_init~2.html","title":"abstract_init – openpde"},{"text":"abstract interface private subroutine abstract_set_matrix(this, mat) Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( matrix ), intent(in), target :: mat The mesh. Description Set matrix.","tags":"","loc":"interface/abstract_set_matrix.html","title":"abstract_set_matrix – openpde"},{"text":"abstract interface private subroutine abstract_set_vector(this, vec) Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( vector ), intent(in), target :: vec The mesh. Description Set vector.","tags":"","loc":"interface/abstract_set_vector.html","title":"abstract_set_vector – openpde"},{"text":"abstract interface Initialize the field. private subroutine abstract_solve(this) Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout), target :: this The field. Description Solve system.","tags":"","loc":"interface/abstract_solve.html","title":"abstract_solve – openpde"},{"text":"abstract interface Operator operation. private function abstract_operate(this, inp, i_equ, i_fie, dir) result(opr) Arguments Type Intent Optional Attributes Name class( f2m ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Direction of operation. integer(kind=I_P), intent(in), optional :: i_fie Direction of operation. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable,target Matrix representing the operator as f(u)=A*u Description Operator function.","tags":"","loc":"interface/abstract_operate~2.html","title":"abstract_operate – openpde"},{"text":"abstract interface Initialize integrator. private subroutine abstract_init(this, equ, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator.","tags":"","loc":"interface/abstract_init~3.html","title":"abstract_init – openpde"},{"text":"abstract interface Integrate the field accordingly the equation. private function abstract_integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly to the equation.","tags":"","loc":"interface/abstract_integrate.html","title":"abstract_integrate – openpde"},{"text":"abstract interface Initialize vector. private subroutine abstract_vectorinit(this, n, description, error) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize vector.","tags":"","loc":"interface/abstract_vectorinit.html","title":"abstract_vectorinit – openpde"},{"text":"abstract interface Output vector. private subroutine abstract_vectoroutput(this, filename, error) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output filename. integer(kind=I_P), intent(out), optional :: error Error status. Description Output vector.","tags":"","loc":"interface/abstract_vectoroutput.html","title":"abstract_vectoroutput – openpde"},{"text":"abstract interface Set vector element. private subroutine abstract_vectorset(this, i, val) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Index to set real(kind=R_P), intent(in) :: val Value to be assigned Description Set vector element.","tags":"","loc":"interface/abstract_vectorset.html","title":"abstract_vectorset – openpde"},{"text":"abstract interface Get vector element. private function abstract_vectorget(this, i) result(val) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Index to get Return Value real(kind=R_P) Value to be extracted Description Set vector element.","tags":"","loc":"interface/abstract_vectorget.html","title":"abstract_vectorget – openpde"},{"text":"abstract interface Assignment overloading. private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. Description Assignment overloading.","tags":"","loc":"interface/abstract_assign~2.html","title":"abstract_assign – openpde"},{"text":"abstract interface Operator operation. private function abstract_operate(this, inp, dir) result(opr) Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Description Operator function.","tags":"","loc":"interface/abstract_operate~3.html","title":"abstract_operate – openpde"},{"text":"abstract interface Operator operation. private function abstract_operate(this, fie) result(vec) Arguments Type Intent Optional Attributes Name class( f2v ), intent(in) :: this The operator. class( field ), intent(in), target, dimension(:) :: fie Input field. Return Value class( vector ),\n  allocatable Resulting vector. Description Operator function.","tags":"","loc":"interface/abstract_operate~4.html","title":"abstract_operate – openpde"},{"text":"abstract interface Initialize integrator. private subroutine abstract_init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize integrator.","tags":"","loc":"interface/abstract_init~4.html","title":"abstract_init – openpde"},{"text":"abstract interface Integrate the field accordingly the equation. private function abstract_integrate(this, equ, t, inp) result(error) Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Description Integrate the field accordingly to the equation.","tags":"","loc":"interface/abstract_integrate~2.html","title":"abstract_integrate – openpde"},{"text":"abstract interface Create subgrid-levels field. private subroutine create_subgrids_field_interface(this, inp, subgrids) Arguments Type Intent Optional Attributes Name class( multigrid ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. Description Create subgrid-levels field.","tags":"","loc":"interface/create_subgrids_field_interface.html","title":"create_subgrids_field_interface – openpde"},{"text":"abstract interface Init multigrid solver. private subroutine init_interface(this, inp, levels_number) Arguments Type Intent Optional Attributes Name class( multigrid ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Levels number. Description Init multigrid solver.","tags":"","loc":"interface/init_interface.html","title":"init_interface – openpde"},{"text":"abstract interface Assignment overloading. private function abstract_simmetric_operator(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable,target Result Description Assignment overloading.","tags":"","loc":"interface/abstract_simmetric_operator~2.html","title":"abstract_simmetric_operator – openpde"},{"text":"abstract interface private function abstract_real_op_field(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable,target Operator result. Description Non symmetric operator real.op.field.","tags":"","loc":"interface/abstract_real_op_field~2.html","title":"abstract_real_op_field – openpde"},{"text":"abstract interface Assignment overloading. private subroutine abstract_assign(lhs, rhs) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Description Assignment overloading.","tags":"","loc":"interface/abstract_assign~3.html","title":"abstract_assign – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_matrixinit(this, n, description, error) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Initialization file name. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh.","tags":"","loc":"interface/abstract_matrixinit.html","title":"abstract_matrixinit – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_matrixoutput(this, filename, error) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh.","tags":"","loc":"interface/abstract_matrixoutput.html","title":"abstract_matrixoutput – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_matrixset(this, i, j, val) Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this integer(kind=I_P), intent(in) :: i integer(kind=I_P), intent(in) :: j real(kind=R_P), intent(in) :: val Description Initialize mesh.","tags":"","loc":"interface/abstract_matrixset.html","title":"abstract_matrixset – openpde"},{"text":"abstract interface Equation boundary conditions. private subroutine abstract_bc(this, inp, t) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Description Equation boundary condition.","tags":"","loc":"interface/abstract_bc.html","title":"abstract_bc – openpde"},{"text":"abstract interface Initialize equation. private subroutine abstract_init(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize equation.","tags":"","loc":"interface/abstract_init~5.html","title":"abstract_init – openpde"},{"text":"abstract interface Return the field after forcing the equation. private function abstract_forcing(this, inp, t) result(opr) Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Description Return the field after forcing the equation.","tags":"","loc":"interface/abstract_forcing.html","title":"abstract_forcing – openpde"},{"text":"abstract interface Initialize mesh. private subroutine abstract_meshinit(this, description, filename, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Description Initialize mesh.","tags":"","loc":"interface/abstract_meshinit.html","title":"abstract_meshinit – openpde"},{"text":"abstract interface Output mesh. private subroutine abstract_meshoutput(this, error) Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Description Output mesh.","tags":"","loc":"interface/abstract_meshoutput.html","title":"abstract_meshoutput – openpde"},{"text":"public function associate_field_FD_2D(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_2D ),\n  pointer Finite Difference 2D field pointer. Called By proc~~associate_field_fd_2d~~CalledByGraph proc~associate_field_fd_2d associate_field_FD_2D proc~assign_field assign_field proc~assign_field->proc~associate_field_fd_2d proc~div div proc~div->proc~associate_field_fd_2d proc~operate~7 operate proc~operate~7->proc~associate_field_fd_2d proc~operate operate proc~operate->proc~associate_field_fd_2d proc~add add proc~add->proc~associate_field_fd_2d proc~mul mul proc~mul->proc~associate_field_fd_2d proc~operate~6 operate proc~operate~6->proc~associate_field_fd_2d proc~realmul realmul proc~realmul->proc~associate_field_fd_2d proc~operate~13 operate proc~operate~13->proc~associate_field_fd_2d proc~mulreal mulreal proc~mulreal->proc~associate_field_fd_2d proc~operate~5 operate proc~operate~5->proc~associate_field_fd_2d proc~sub sub proc~sub->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_FD_2D Source Code function associate_field_FD_2D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_2D ), pointer :: field_pointer !< Finite Difference 2D field pointer. select type ( field_input ) type is ( field_FD_2D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_2D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_2D","tags":"","loc":"proc/associate_field_fd_2d.html","title":"associate_field_FD_2D – openpde"},{"text":"private function add(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~add~~CallsGraph proc~add add proc~associate_field_fd_2d associate_field_FD_2D proc~add->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%add' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mul~~CallsGraph proc~mul mul proc~associate_field_fd_2d associate_field_FD_2D proc~mul->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mul Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%mul' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mulreal~~CallsGraph proc~mulreal mulreal proc~associate_field_fd_2d associate_field_FD_2D proc~mulreal->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mulreal Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~realmul~~CallsGraph proc~realmul realmul proc~associate_field_fd_2d associate_field_FD_2D proc~realmul->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code realmul Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_2D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~sub~~CallsGraph proc~sub sub proc~associate_field_fd_2d associate_field_FD_2D proc~sub->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%sub' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub.html","title":"sub – openpde"},{"text":"private function div(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~div~~CallsGraph proc~div div proc~associate_field_fd_2d associate_field_FD_2D proc~div->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code div Source Code function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_2D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%sub' ) allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure field_FD_2D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val / rhs_cur % val end function div","tags":"","loc":"proc/div.html","title":"div – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~associate_mesh~~CallsGraph proc~associate_mesh associate_mesh proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~associate_mesh->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. mesh_cur => associate_mesh_FD_2D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_2D%associate_mesh' ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) allocate ( this % val ( 1 - mesh_cur % ngx : mesh_cur % nx + mesh_cur % ngx , 1 - mesh_cur % ngy : mesh_cur % ny + mesh_cur % ngy )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Initialize finite difference 2D field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~init~~CallsGraph proc~init init proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~init->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 2D field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FD_2D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_2D%init' ) do j = 1 - mesh_cur % ngy , mesh_cur % ny + mesh_cur % ngy do i = 1 - mesh_cur % ngx , mesh_cur % nx + mesh_cur % ngx this % val ( i , j ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % nx ) * sin ( j * 2._R_P * acos ( - 1._R_P ) / mesh_cur % ny ) enddo enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_2D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: jmin !< Lower extent. integer ( I_P ) :: jmax !< Upper extent. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) jmin = lbound ( this % val , dim = 2 ) jmax = ubound ( this % val , dim = 2 ) open ( unit = 11 , file = filename ) do j = jmin , jmax do i = imin , imax write ( 11 , * ) i , j , this % val ( i , j ) enddo write ( 11 , * ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output.html","title":"output – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Calls proc~~assign_field~~CallsGraph proc~assign_field assign_field proc~associate_field_fd_2d associate_field_FD_2D proc~assign_field->proc~associate_field_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_field Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_2D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_2D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FD_2D ( field_input = rhs , emsg = 'calling procedure field_FD_2D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field.html","title":"assign_field – openpde"},{"text":"private subroutine set(this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_2D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :, 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :, 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_2D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Todo Discuss about the free of mesh pointer. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. !< !< @todo Discuss about the *free* of mesh pointer. class ( field ), intent ( inout ) :: this !< The field. if ( allocated ( this % description )) deallocate ( this % description ) ! if (associated(this%m)) then !   call this%m%free !   deallocate(this%m) ! endif ! this%m => null() end subroutine free","tags":"","loc":"proc/free~2.html","title":"free – openpde"},{"text":"private elemental function add(lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Add blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val + rhs % val end function add","tags":"","loc":"proc/add~2.html","title":"add – openpde"},{"text":"private elemental function mul(lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs % val end function mul","tags":"","loc":"proc/mul~2.html","title":"mul – openpde"},{"text":"private elemental function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code mulreal Source Code elemental function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal~2.html","title":"mulreal – openpde"},{"text":"private elemental function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code realmul Source Code elemental function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Right hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul~2.html","title":"realmul – openpde"},{"text":"private elemental function sub(lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val - rhs % val end function sub","tags":"","loc":"proc/sub~2.html","title":"sub – openpde"},{"text":"private elemental function div(lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_surface_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_surface_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val / rhs % val end function div","tags":"","loc":"proc/div~2.html","title":"div – openpde"},{"text":"private subroutine alloc(this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code alloc Source Code subroutine alloc ( this , mesh_block , error ) !< Allocate block. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free allocate ( this % val ( 0 : mesh_block % n )) if ( present ( error )) error = 0 end subroutine alloc","tags":"","loc":"proc/alloc.html","title":"alloc – openpde"},{"text":"private subroutine compute_fluxes(this, field_cell, mesh_block, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(field_block_FV_1D), intent(in) :: field_cell Field at cells center. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code compute_fluxes Source Code subroutine compute_fluxes ( this , field_cell , mesh_block , error ) !< Compute fluxes of field through surfaces. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( field_block_FV_1D ), intent ( in ) :: field_cell !< Field at cells center. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 0 , mesh_block % n this % val ( i ) = field_cell % val ( i ) enddo end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The field. if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free~3.html","title":"free – openpde"},{"text":"private subroutine init(this, mesh_block, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , mesh_block , error ) !< Initialize block. class ( field_surface_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % alloc ( mesh_block = mesh_block , error = error ) this % val = 0._R_P if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~2.html","title":"init – openpde"},{"text":"private subroutine output(this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , unit , mesh_block , error ) !< Output block data. class ( field_surface_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( in ) :: unit !< Unit file. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 0 , mesh_block % n write ( unit , * ) this % val ( i ) enddo if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~2.html","title":"output – openpde"},{"text":"private elemental subroutine assign_block(lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Source Code assign_block Source Code elemental subroutine assign_block ( lhs , rhs ) !< Assign blocks. class ( field_surface_block_FV_1D ), intent ( inout ) :: lhs !< Left hand side. type ( field_surface_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. lhs % val = rhs % val end subroutine assign_block","tags":"","loc":"proc/assign_block.html","title":"assign_block – openpde"},{"text":"private function associate_field_FD_1D_scalar(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer Finite Difference 1D field pointer. Called By proc~~associate_field_fd_1d_scalar~~CalledByGraph proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d associate_field_FD_1D interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~realmul~3 realmul proc~realmul~3->interface~associate_field_fd_1d proc~integrate~3 integrate proc~integrate~3->interface~associate_field_fd_1d proc~mulreal~3 mulreal proc~mulreal~3->interface~associate_field_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_field_fd_1d proc~sub~3 sub proc~sub~3->interface~associate_field_fd_1d proc~add~3 add proc~add~3->interface~associate_field_fd_1d proc~assign_field~2 assign_field proc~assign_field~2->interface~associate_field_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_field_fd_1d proc~integrate integrate proc~integrate->interface~associate_field_fd_1d proc~operate~10 operate proc~operate~10->interface~associate_field_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_field_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_field_fd_1d proc~operate~2 operate proc~operate~2->interface~associate_field_fd_1d proc~mul~3 mul proc~mul~3->interface~associate_field_fd_1d proc~newrealmul newrealmul proc~newrealmul->interface~associate_field_fd_1d proc~div~3 div proc~div~3->interface~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_FD_1D_scalar Source Code function associate_field_FD_1D_scalar ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_scalar","tags":"","loc":"proc/associate_field_fd_1d_scalar.html","title":"associate_field_FD_1D_scalar – openpde"},{"text":"private function associate_field_FD_1D_rank1(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer,(:) Finite Difference 1D field pointer. Called By proc~~associate_field_fd_1d_rank1~~CalledByGraph proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d associate_field_FD_1D interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 proc~realmul~3 realmul proc~realmul~3->interface~associate_field_fd_1d proc~integrate~3 integrate proc~integrate~3->interface~associate_field_fd_1d proc~mulreal~3 mulreal proc~mulreal~3->interface~associate_field_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_field_fd_1d proc~sub~3 sub proc~sub~3->interface~associate_field_fd_1d proc~add~3 add proc~add~3->interface~associate_field_fd_1d proc~assign_field~2 assign_field proc~assign_field~2->interface~associate_field_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_field_fd_1d proc~integrate integrate proc~integrate->interface~associate_field_fd_1d proc~operate~10 operate proc~operate~10->interface~associate_field_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_field_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_field_fd_1d proc~operate~2 operate proc~operate~2->interface~associate_field_fd_1d proc~mul~3 mul proc~mul~3->interface~associate_field_fd_1d proc~newrealmul newrealmul proc~newrealmul->interface~associate_field_fd_1d proc~div~3 div proc~div~3->interface~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_FD_1D_rank1 Source Code function associate_field_FD_1D_rank1 ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input (:) !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer (:) !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_rank1","tags":"","loc":"proc/associate_field_fd_1d_rank1.html","title":"associate_field_FD_1D_rank1 – openpde"},{"text":"private function associate_field_FD_1D_rank2(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:,:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer,(:,:) Finite Difference 1D field pointer. Called By proc~~associate_field_fd_1d_rank2~~CalledByGraph proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d associate_field_FD_1D interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~realmul~3 realmul proc~realmul~3->interface~associate_field_fd_1d proc~integrate~3 integrate proc~integrate~3->interface~associate_field_fd_1d proc~mulreal~3 mulreal proc~mulreal~3->interface~associate_field_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_field_fd_1d proc~sub~3 sub proc~sub~3->interface~associate_field_fd_1d proc~add~3 add proc~add~3->interface~associate_field_fd_1d proc~assign_field~2 assign_field proc~assign_field~2->interface~associate_field_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_field_fd_1d proc~integrate integrate proc~integrate->interface~associate_field_fd_1d proc~operate~10 operate proc~operate~10->interface~associate_field_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_field_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_field_fd_1d proc~operate~2 operate proc~operate~2->interface~associate_field_fd_1d proc~mul~3 mul proc~mul~3->interface~associate_field_fd_1d proc~newrealmul newrealmul proc~newrealmul->interface~associate_field_fd_1d proc~div~3 div proc~div~3->interface~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_FD_1D_rank2 Source Code function associate_field_FD_1D_rank2 ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input (:,:) !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FD_1D ), pointer :: field_pointer (:,:) !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FD_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FD_1D_rank2","tags":"","loc":"proc/associate_field_fd_1d_rank2.html","title":"associate_field_FD_1D_rank2 – openpde"},{"text":"private function add(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~add~3~~CallsGraph proc~add~3 add interface~associate_field_fd_1d associate_field_FD_1D proc~add~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%add' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add~3.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mul~3~~CallsGraph proc~mul~3 mul interface~associate_field_fd_1d associate_field_FD_1D proc~mul~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mul Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%mul' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs_cur % val end function mul","tags":"","loc":"proc/mul~3.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mulreal~3~~CallsGraph proc~mulreal~3 mulreal interface~associate_field_fd_1d associate_field_FD_1D proc~mulreal~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mulreal Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal~3.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~realmul~3~~CallsGraph proc~realmul~3 realmul interface~associate_field_fd_1d associate_field_FD_1D proc~realmul~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code realmul Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul~3.html","title":"realmul – openpde"},{"text":"private function newrealmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~newrealmul~~CallsGraph proc~newrealmul newrealmul interface~associate_field_fd_1d associate_field_FD_1D proc~newrealmul->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code newrealmul Source Code function newrealmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FD_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % val = lhs * rhs % val end function newrealmul","tags":"","loc":"proc/newrealmul.html","title":"newrealmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~sub~3~~CallsGraph proc~sub~3 sub interface~associate_field_fd_1d associate_field_FD_1D proc~sub~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%sub' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub~3.html","title":"sub – openpde"},{"text":"private function div(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~div~3~~CallsGraph proc~div~3 div interface~associate_field_fd_1d associate_field_FD_1D proc~div~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code div Source Code function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FD_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%sub' ) allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure field_FD_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % val = lhs % val / rhs_cur % val end function div","tags":"","loc":"proc/div~3.html","title":"div – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~associate_mesh~2~~CallsGraph proc~associate_mesh~2 associate_mesh interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~associate_mesh~2->interface~associate_mesh_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. mesh_cur => associate_mesh_FD_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_1D%associate_mesh' ) this % m => mesh_cur if ( allocated ( this % val )) deallocate ( this % val ) ; allocate ( this % val ( 1 - mesh_cur % ng : mesh_cur % n + mesh_cur % ng )) if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh~2.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~init~3~~CallsGraph proc~init~3 init interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~init~3->interface~associate_mesh_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FD_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FD_1D%init' ) this % val (:) = 0._R_P !        do i = 1, mesh_cur%n do i = 1 - mesh_cur % ng , mesh_cur % n + mesh_cur % ng this % val ( i ) = sin ( i * 2._R_P * acos ( - 1._R_P ) / mesh_cur % n ) enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~3.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_FD_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: imin !< Lower extent. integer ( I_P ) :: imax !< Upper extent. integer ( I_P ) :: i !< Counter. imin = lbound ( this % val , dim = 1 ) imax = ubound ( this % val , dim = 1 ) open ( unit = 11 , file = filename ) do i = imin , imax write ( 11 , * ) this % val ( i ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~3.html","title":"output – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Calls proc~~assign_field~2~~CallsGraph proc~assign_field~2 assign_field interface~associate_field_fd_1d associate_field_FD_1D proc~assign_field~2->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_field Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FD_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FD_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FD_1D ( field_input = rhs , emsg = 'calling procedure field_FD_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % val = rhs_cur % val end subroutine assign_field","tags":"","loc":"proc/assign_field~2.html","title":"assign_field – openpde"},{"text":"private subroutine set(this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code subroutine set ( this , field_mesh , description , val , error ) !< Set field. class ( field_FD_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), optional , target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description real ( R_P ), intent ( in ), optional :: val ( 1 :) !< Field value. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( field_mesh )) call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description if ( present ( val )) this % val ( 1 :) = val ! TO BE FIXED SINCE THERE ARE GHOST NODES if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~2.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FD_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free~4.html","title":"free – openpde"},{"text":"public interface associate_field_FD_1D Calls interface~~associate_field_fd_1d~~CallsGraph interface~associate_field_fd_1d associate_field_FD_1D proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~associate_field_fd_1d~~CalledByGraph interface~associate_field_fd_1d associate_field_FD_1D proc~realmul~3 realmul proc~realmul~3->interface~associate_field_fd_1d proc~integrate~3 integrate proc~integrate~3->interface~associate_field_fd_1d proc~mulreal~3 mulreal proc~mulreal~3->interface~associate_field_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_field_fd_1d proc~sub~3 sub proc~sub~3->interface~associate_field_fd_1d proc~add~3 add proc~add~3->interface~associate_field_fd_1d proc~assign_field~2 assign_field proc~assign_field~2->interface~associate_field_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_field_fd_1d proc~integrate integrate proc~integrate->interface~associate_field_fd_1d proc~operate~10 operate proc~operate~10->interface~associate_field_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_field_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_field_fd_1d proc~operate~2 operate proc~operate~2->interface~associate_field_fd_1d proc~mul~3 mul proc~mul~3->interface~associate_field_fd_1d proc~newrealmul newrealmul proc~newrealmul->interface~associate_field_fd_1d proc~div~3 div proc~div~3->interface~associate_field_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures associate_field_FD_1D_scalar associate_field_FD_1D_rank1 associate_field_FD_1D_rank2 Module Procedures private function associate_field_FD_1D_scalar (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer Finite Difference 1D field pointer. private function associate_field_FD_1D_rank1 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:) Finite Difference 1D field pointer. private function associate_field_FD_1D_rank2 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:,:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:,:) Finite Difference 1D field pointer.","tags":"","loc":"interface/associate_field_fd_1d.html","title":"associate_field_FD_1D – openpde"},{"text":"public function associate_field_surface_FV_1D(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Volume 1D field surface pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_surface_FV_1D ),\n  pointer Concrete field pointer. Called By proc~~associate_field_surface_fv_1d~~CalledByGraph proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~sub~4 sub proc~sub~4->proc~associate_field_surface_fv_1d proc~add~4 add proc~add~4->proc~associate_field_surface_fv_1d proc~mul~4 mul proc~mul~4->proc~associate_field_surface_fv_1d proc~assign_field~3 assign_field proc~assign_field~3->proc~associate_field_surface_fv_1d proc~compute_fluxes~2 compute_fluxes proc~compute_fluxes~2->proc~associate_field_surface_fv_1d proc~mulreal~4 mulreal proc~mulreal~4->proc~associate_field_surface_fv_1d proc~div~4 div proc~div~4->proc~associate_field_surface_fv_1d proc~realmul~4 realmul proc~realmul~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_surface_FV_1D Source Code function associate_field_surface_FV_1D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Volume 1D field surface pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_surface_FV_1D ), pointer :: field_pointer !< Concrete field pointer. select type ( field_input ) type is ( field_surface_FV_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_surface_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_surface_FV_1D","tags":"","loc":"proc/associate_field_surface_fv_1d.html","title":"associate_field_surface_FV_1D – openpde"},{"text":"private function add(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~add~4~~CallsGraph proc~add~4 add proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~add~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%add' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks + rhs_cur % blocks end function add","tags":"","loc":"proc/add~4.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mul~4~~CallsGraph proc~mul~4 mul proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~mul~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mul Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%mul' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs_cur % blocks end function mul","tags":"","loc":"proc/mul~4.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mulreal~4~~CallsGraph proc~mulreal~4 mulreal proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~mulreal~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mulreal Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs end function mulreal","tags":"","loc":"proc/mulreal~4.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~realmul~4~~CallsGraph proc~realmul~4 realmul proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~realmul~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code realmul Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_surface_FV_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % blocks = lhs * rhs % blocks end function realmul","tags":"","loc":"proc/realmul~4.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~sub~4~~CallsGraph proc~sub~4 sub proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~sub~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%sub' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks - rhs_cur % blocks end function sub","tags":"","loc":"proc/sub~4.html","title":"sub – openpde"},{"text":"private function div(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~div~4~~CallsGraph proc~div~4 div proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~div~4->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code div Source Code function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_surface_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_surface_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%sub' ) allocate ( field_surface_FV_1D :: opr ) opr_cur => associate_field_surface_FV_1D ( field_input = opr , emsg = 'calling procedure field_surface_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks / rhs_cur % blocks end function div","tags":"","loc":"proc/div~4.html","title":"div – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~associate_mesh~3~~CallsGraph proc~associate_mesh~3 associate_mesh proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~associate_mesh~3->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_surface_FV_1D%associate_mesh' ) this % m => mesh_cur this % nb = mesh_cur % nb if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = 1 , this % nb call this % blocks ( b )% alloc ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh~3.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Initialize field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~init~4~~CallsGraph proc~init~4 init proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~init~4->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize field. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_surface_FV_1D%init' ) do b = 1 , this % nb call this % blocks ( b )% init ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~4.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Output field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~output~4~~CallsGraph proc~output~4 output proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~output~4->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code output Source Code subroutine output ( this , filename , error ) !< Output field. class ( field_surface_FV_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: unit !< File unit. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = this % m , emsg = 'calling procedure field_surface_FV_1D%output' ) open ( newunit = unit , file = filename ) do b = 1 , mesh_cur % nb call this % blocks ( b )% output ( unit = unit , mesh_block = mesh_cur % blocks ( b ), error = error ) enddo close ( unit ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~4.html","title":"output – openpde"},{"text":"private subroutine compute_fluxes(this, field_cell, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~compute_fluxes~2~~CallsGraph proc~compute_fluxes~2 compute_fluxes proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~compute_fluxes~2->proc~associate_field_surface_fv_1d proc~associate_field_fv_1d associate_field_FV_1D proc~compute_fluxes~2->proc~associate_field_fv_1d proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~compute_fluxes~2->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_fluxes Source Code subroutine compute_fluxes ( this , field_cell , error ) !< Compute fluxes of field through surfaces. class ( field_surface_FV_1D ), intent ( inout ) :: this !< Fluxex. class ( field ), intent ( in ) :: field_cell !< Field at cells center. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( field_FV_1D ), pointer :: field_cell_cur !< Dummy pointer for field at cells center. class ( field_surface_FV_1D ), pointer :: flux_cur !< Dummy pointer for fluxes. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. field_cell_cur => associate_field_FV_1D ( field_input = field_cell , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = field_cell_cur % m , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) flux_cur => associate_field_surface_FV_1D ( field_input = this , emsg = 'calling procedure field_surface_FV_1D%fluxes' ) do b = 1 , mesh_cur % nb call flux_cur % blocks ( b )% compute_fluxes ( field_cell = field_cell_cur % blocks ( b ), mesh_block = mesh_cur % blocks ( b ), error = error ) end do end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~2.html","title":"compute_fluxes – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Calls proc~~assign_field~3~~CallsGraph proc~assign_field~3 assign_field proc~associate_field_surface_fv_1d associate_field_surface_FV_1D proc~assign_field~3->proc~associate_field_surface_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_field Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_surface_FV_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_surface_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_surface_FV_1D ( field_input = rhs , emsg = 'calling procedure field_surface_FV_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % blocks = rhs_cur % blocks end subroutine assign_field","tags":"","loc":"proc/assign_field~3.html","title":"assign_field – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_surface_FV_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free","tags":"","loc":"proc/free~5.html","title":"free – openpde"},{"text":"private elemental function add(lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Add blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val + rhs % val end function add","tags":"","loc":"proc/add~5.html","title":"add – openpde"},{"text":"private elemental function mul(lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Multiply blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs % val end function mul","tags":"","loc":"proc/mul~5.html","title":"mul – openpde"},{"text":"private elemental function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code mulreal Source Code elemental function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val * rhs end function mulreal","tags":"","loc":"proc/mulreal~5.html","title":"mulreal – openpde"},{"text":"private elemental function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code realmul Source Code elemental function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_block_FV_1D ), intent ( in ) :: rhs !< Right hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul~5.html","title":"realmul – openpde"},{"text":"private elemental function sub(lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val - rhs % val end function sub","tags":"","loc":"proc/sub~5.html","title":"sub – openpde"},{"text":"private elemental function div(lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Subtract blocks. class ( field_block_FV_1D ), intent ( in ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. type ( field_block_FV_1D ) :: opr !< Operator result. opr % val = lhs % val / rhs % val end function div","tags":"","loc":"proc/div~5.html","title":"div – openpde"},{"text":"private subroutine alloc(this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code alloc Source Code subroutine alloc ( this , mesh_block , error ) !< Allocate block. class ( field_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free allocate ( this % val ( 1 - mesh_block % ng : mesh_block % n + mesh_block % ng )) if ( present ( error )) error = 0 end subroutine alloc","tags":"","loc":"proc/alloc~2.html","title":"alloc – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_block_FV_1D ), intent ( inout ) :: this !< The field. if ( allocated ( this % val )) deallocate ( this % val ) end subroutine free","tags":"","loc":"proc/free~6.html","title":"free – openpde"},{"text":"private subroutine init(this, mesh_field, b, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_FV_1D), intent(in) :: mesh_field Mesh of the whole field. integer(kind=I_P), intent(in) :: b Block index. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , mesh_field , b , error ) !< Initialize block. class ( field_block_FV_1D ), intent ( inout ) :: this !< The block. type ( mesh_FV_1D ), intent ( in ) :: mesh_field !< Mesh of the whole field. integer ( I_P ), intent ( in ) :: b !< Block index. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: offset !< Cells offset. integer ( I_P ) :: n !< Total number of Cells. integer ( I_P ) :: i !< Counter. offset = 0 ; if ( b > 1 ) offset = sum ( mesh_field % blocks ( 1 : b - 1 )% n , dim = 1 ) n = sum ( mesh_field % blocks % n , dim = 1 ) call this % alloc ( mesh_block = mesh_field % blocks ( b ), error = error ) do i = 1 , mesh_field % blocks ( b )% n this % val ( i ) = sin (( i + offset ) * 2._R_P * acos ( - 1._R_P ) / n ) enddo if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~5.html","title":"init – openpde"},{"text":"private subroutine output(this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , unit , mesh_block , error ) !< Output block data. class ( field_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( in ) :: unit !< Unit file. type ( mesh_block_FV_1D ), intent ( in ) :: mesh_block !< Mesh of the block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Counter. do i = 1 , mesh_block % n write ( unit , * ) this % val ( i ) enddo if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~5.html","title":"output – openpde"},{"text":"private elemental subroutine assign_block(lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Source Code assign_block Source Code elemental subroutine assign_block ( lhs , rhs ) !< Assign blocks. class ( field_block_FV_1D ), intent ( inout ) :: lhs !< Left hand side. type ( field_block_FV_1D ), intent ( in ) :: rhs !< Left hand side. lhs % val = rhs % val end subroutine assign_block","tags":"","loc":"proc/assign_block~2.html","title":"assign_block – openpde"},{"text":"public function associate_field_FV_1D(field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FV_1D ),\n  pointer Finite Difference 1D field pointer. Called By proc~~associate_field_fv_1d~~CalledByGraph proc~associate_field_fv_1d associate_field_FV_1D proc~assign_field~4 assign_field proc~assign_field~4->proc~associate_field_fv_1d proc~operate~9 operate proc~operate~9->proc~associate_field_fv_1d proc~div~6 div proc~div~6->proc~associate_field_fv_1d proc~realmul~6 realmul proc~realmul~6->proc~associate_field_fv_1d proc~sub~6 sub proc~sub~6->proc~associate_field_fv_1d proc~compute_fluxes~2 compute_fluxes proc~compute_fluxes~2->proc~associate_field_fv_1d proc~operate~8 operate proc~operate~8->proc~associate_field_fv_1d proc~add~6 add proc~add~6->proc~associate_field_fv_1d proc~mul~6 mul proc~mul~6->proc~associate_field_fv_1d proc~mulreal~6 mulreal proc~mulreal~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_field_FV_1D Source Code function associate_field_FV_1D ( field_input , emsg ) result ( field_pointer ) !< Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. class ( field ), intent ( in ), target :: field_input !< Input field. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( field_FV_1D ), pointer :: field_pointer !< Finite Difference 1D field pointer. select type ( field_input ) type is ( field_FV_1D ) field_pointer => field_input class default write ( stderr , '(A)' ) 'error: cast field to field_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_field_FV_1D","tags":"","loc":"proc/associate_field_fv_1d.html","title":"associate_field_FV_1D – openpde"},{"text":"private function add(lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~add~6~~CallsGraph proc~add~6 add proc~associate_field_fv_1d associate_field_FV_1D proc~add~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code function add ( lhs , rhs ) result ( opr ) !< Add fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%add' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%add' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks + rhs_cur % blocks end function add","tags":"","loc":"proc/add~6.html","title":"add – openpde"},{"text":"private function mul(lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mul~6~~CallsGraph proc~mul~6 mul proc~associate_field_fv_1d associate_field_FV_1D proc~mul~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mul Source Code function mul ( lhs , rhs ) result ( opr ) !< Multiply fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%mul' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%mul' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs_cur % blocks end function mul","tags":"","loc":"proc/mul~6.html","title":"mul – openpde"},{"text":"private function mulreal(lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~mulreal~6~~CallsGraph proc~mulreal~6 mulreal proc~associate_field_fv_1d associate_field_FV_1D proc~mulreal~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mulreal Source Code function mulreal ( lhs , rhs ) result ( opr ) !< Multiply field for real. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%mulreal' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks * rhs end function mulreal","tags":"","loc":"proc/mulreal~6.html","title":"mulreal – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~realmul~6~~CallsGraph proc~realmul~6 realmul proc~associate_field_fv_1d associate_field_FV_1D proc~realmul~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code realmul Source Code function realmul ( lhs , rhs ) result ( opr ) !< Multiply real for field. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( field_FV_1D ), intent ( in ) :: rhs !< Right hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%realmul' ) call opr_cur % associate_mesh ( field_mesh = rhs % m ) opr_cur % blocks = lhs * rhs % blocks end function realmul","tags":"","loc":"proc/realmul~6.html","title":"realmul – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~sub~6~~CallsGraph proc~sub~6 sub proc~associate_field_fv_1d associate_field_FV_1D proc~sub~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%sub' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks - rhs_cur % blocks end function sub","tags":"","loc":"proc/sub~6.html","title":"sub – openpde"},{"text":"private function div(lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable,target Operator result. Calls proc~~div~6~~CallsGraph proc~div~6 div proc~associate_field_fv_1d associate_field_FV_1D proc~div~6->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code div Source Code function div ( lhs , rhs ) result ( opr ) !< Subtract fields. class ( field_FV_1D ), intent ( in ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Left hand side. class ( field ), allocatable , target :: opr !< Operator result. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%sub' ) allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure field_FV_1D%sub' ) call opr_cur % associate_mesh ( field_mesh = lhs % m ) opr_cur % blocks = lhs % blocks / rhs_cur % blocks end function div","tags":"","loc":"proc/div~6.html","title":"div – openpde"},{"text":"private subroutine associate_mesh(this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~associate_mesh~4~~CallsGraph proc~associate_mesh~4 associate_mesh proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~associate_mesh~4->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh Source Code subroutine associate_mesh ( this , field_mesh , error ) !< Associate field to a mesh. class ( field_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FV_1D%associate_mesh' ) this % m => mesh_cur this % nb = mesh_cur % nb if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = 1 , this % nb call this % blocks ( b )% alloc ( mesh_block = mesh_cur % blocks ( b ), error = error ) end do if ( present ( error )) error = 0 end subroutine associate_mesh","tags":"","loc":"proc/associate_mesh~4.html","title":"associate_mesh – openpde"},{"text":"private subroutine init(this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~init~6~~CallsGraph proc~init~6 init proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~init~6->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( this , field_mesh , description , error ) !< Initialize finite difference 1D field. class ( field_FV_1D ), intent ( inout ) :: this !< The field. class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. call this % free call this % associate_mesh ( field_mesh = field_mesh , error = error ) if ( present ( description )) this % description = description mesh_cur => associate_mesh_FV_1D ( mesh_input = field_mesh , emsg = 'calling procedure field_FV_1D%init' ) do b = 1 , this % nb call this % blocks ( b )% init ( mesh_field = mesh_cur , b = b , error = error ) end do if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~6.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Calls proc~~output~6~~CallsGraph proc~output~6 output proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~output~6->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code output Source Code subroutine output ( this , filename , error ) !< Output field data. class ( field_FV_1D ), intent ( in ) :: this !< The field. character ( len =* ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. mesh_cur => associate_mesh_FV_1D ( mesh_input = this % m , emsg = 'calling procedure field_FV_1D%output' ) open ( unit = 11 , file = filename ) do b = 1 , mesh_cur % nb call this % blocks ( b )% output ( unit = 11 , mesh_block = mesh_cur % blocks ( b ), error = error ) enddo close ( 11 ) if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~6.html","title":"output – openpde"},{"text":"private subroutine assign_field(lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Calls proc~~assign_field~4~~CallsGraph proc~assign_field~4 assign_field proc~associate_field_fv_1d associate_field_FV_1D proc~assign_field~4->proc~associate_field_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_field Source Code subroutine assign_field ( lhs , rhs ) !< Assign fields. class ( field_FV_1D ), intent ( inout ) :: lhs !< Left hand side. class ( field ), intent ( in ), target :: rhs !< Right hand side. class ( field_FV_1D ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_field_FV_1D ( field_input = rhs , emsg = 'calling procedure field_FV_1D%assign' ) call lhs % associate_mesh ( field_mesh = rhs_cur % m ) lhs % blocks = rhs_cur % blocks end subroutine assign_field","tags":"","loc":"proc/assign_field~4.html","title":"assign_field – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( field_FV_1D ), intent ( inout ) :: this !< The field. ! call this%field%free if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free","tags":"","loc":"proc/free~7.html","title":"free – openpde"},{"text":"private subroutine operate(this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_2D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field. Calls proc~~operate~~CallsGraph proc~operate operate proc~associate_field_fd_2d associate_field_FD_2D proc~operate->proc~associate_field_fd_2d proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code subroutine operate ( this , vec , fie ) !< Operator operation. class ( v2f_FD_2D ), intent ( in ) :: this !< The operator. class ( vector ), intent ( in ) :: vec !< Input vector. class ( field ), intent ( inout ), dimension (:) :: fie !< Returned field. class ( field_FD_2D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = this % n_equ mesh_cur => associate_mesh_FD_2D ( mesh_input = this % mesh ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny do i_equ = 1 , n_equ call fie ( i_equ )% init ( field_mesh = this % mesh ) fie_cur => associate_field_FD_2D ( field_input = fie ( i_equ )) ! No concrete features of vector are used so dynamic casting is not needed do j = 1 , ny do i = 1 , nx i_vec = n * ( n_equ - 1 ) + ( j - 1 ) * nx + i fie_cur % val ( i , j ) = vec % get ( i_vec ) enddo enddo enddo end subroutine operate","tags":"","loc":"proc/operate.html","title":"operate – openpde"},{"text":"private subroutine operate(this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_1D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field. Calls proc~~operate~2~~CallsGraph proc~operate~2 operate interface~associate_field_fd_1d associate_field_FD_1D proc~operate~2->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code subroutine operate ( this , vec , fie ) !< Operator operation. class ( v2f_FD_1D ), intent ( in ) :: this !< The operator. class ( vector ), intent ( in ) :: vec !< Input vector. class ( field ), intent ( inout ), dimension (:) :: fie !< Returned field. class ( field_FD_1D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = this % n_equ n = vec % n / n_equ do i_equ = 1 , n_equ call fie ( i_equ )% init ( field_mesh = this % mesh ) fie_cur => associate_field_FD_1D ( field_input = fie ( i_equ )) ! No concrete features of vector are used so dynamic casting is not needed do i = 1 , n i_vec = n * ( n_equ - 1 ) + i fie_cur % val ( i ) = vec % get ( i_vec ) enddo enddo end subroutine operate","tags":"","loc":"proc/operate~2.html","title":"operate – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The linsolver. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( linsolver ), intent ( inout ) :: this !< The linsolver. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~8.html","title":"free – openpde"},{"text":"private subroutine init(this, n) Init linsolver Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this integer(kind=I_P) :: n Source Code init Source Code subroutine init ( this , n ) !< Init linsolver class ( linsolver_gmlapack ), intent ( inout ) :: this integer ( I_P ) :: n allocate ( matrix_simple :: this % mat ) allocate ( vector_simple :: this % vec ) allocate ( vector_simple :: this % sol ) call this % mat % init ( n ) call this % vec % init ( n ) call this % sol % init ( n ) allocate ( this % ipiv ( n )) this % lda = n end subroutine init","tags":"","loc":"proc/init~7.html","title":"init – openpde"},{"text":"private subroutine set_matrix(this, mat) Set the solver matrix A. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( matrix ), intent(in), target :: mat Source Code set_matrix Source Code subroutine set_matrix ( this , mat ) !< Set the solver matrix A. class ( linsolver_gmlapack ), intent ( inout ) :: this class ( matrix ), intent ( in ), target :: mat !debug select type(mat) !debug     type is(matrix_simple) !debug         print*,\"SET_MATRIX allocated(mat%val)      : \",allocated(mat%val),      size(mat%val) !debug end select !debug associate(m => this%mat) !debug select type(m) !debug     type is(matrix_simple) !debug        print*,\"SET_MATRIX allocated(this%mat%val) : \",allocated(m%val), size(m%val) !debug end select !debug end associate this % mat = mat end subroutine set_matrix","tags":"","loc":"proc/set_matrix.html","title":"set_matrix – openpde"},{"text":"private subroutine set_vector(this, vec) Set the solver vector b. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( vector ), intent(in), target :: vec Source Code set_vector Source Code subroutine set_vector ( this , vec ) !< Set the solver vector b. class ( linsolver_gmlapack ), intent ( inout ) :: this class ( vector ), intent ( in ), target :: vec this % vec = vec end subroutine set_vector","tags":"","loc":"proc/set_vector.html","title":"set_vector – openpde"},{"text":"private subroutine solve(this) Solve the linear system. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout), target :: this Calls proc~~solve~~CallsGraph proc~solve solve proc~associate_vector_simple associate_vector_simple proc~solve->proc~associate_vector_simple dgetrs dgetrs proc~solve->dgetrs dgetrf dgetrf proc~solve->dgetrf proc~associate_matrix_simple associate_matrix_simple proc~solve->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code solve Source Code subroutine solve ( this ) !< Solve the linear system. class ( linsolver_gmlapack ), intent ( inout ), target :: this integer ( I_P ) :: n class ( matrix_simple ), pointer :: mat_cur class ( vector_simple ), pointer :: vec_cur n = this % mat % n !debug print*,\"allocated(this%mat): \",allocated(this%mat) !debug associate(v => this%mat) !debug select type(v) !debug     type is(matrix_simple) !debug         mat_cur => v !debug         print*,\"allocated(this%mat%val): \",allocated(v%val) !debug         print*,\"this%mat%val: \",v%val(:,:) !debug end select !debug end associate !debug associate(v => this%vec) !debug select type(v) !debug     type is(vector_simple) !debug         print*,\"this%vec%val: \",v%val(:) !debug         vec_cur => v !debug end select !debug end associate vec_cur => associate_vector_simple ( vector_input = this % vec ) mat_cur => associate_matrix_simple ( matrix_input = this % mat ) ! Factorize matrix call dgetrf ( n , n , mat_cur % val , this % lda , this % ipiv , this % info ) ! Solver linear system call dgetrs ( 'n' , n , 1 , mat_cur % val , this % lda , this % ipiv , vec_cur % val , n , this % info ) ! Assign solution to sol vector this % sol = this % vec !debug associate(v => this%sol) !debug select type(v) !debug     type is(vector_simple) !debug         print*,\"this%sol%val: \",v%val(:) !debug end select !debug end associate end subroutine solve","tags":"","loc":"proc/solve.html","title":"solve – openpde"},{"text":"private function operate(this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable,target Matrix representing the operator application. Calls proc~~operate~3~~CallsGraph proc~operate~3 operate interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~3->interface~associate_mesh_fd_1d interface~associate_field_fd_1d associate_field_FD_1D proc~operate~3->interface~associate_field_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. real ( R_P ) :: invd !< Temporary 1/D**2 integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp ( i_equ_ )% m ) n = mesh_cur % n n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invd = 1._R_P / mesh_cur % h ** 2 allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) inp_cur => associate_field_FD_1D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n call opr % set ( 1_I_P + i_row_offset , 1_I_P + i_col_offset , invd ) do i = 2 , n - 1 call opr % set ( i + i_row_offset , i + i_col_offset , - 2._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset - 1 , 1._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset + 1 , 1._R_P * invd ) enddo call opr % set ( n + i_row_offset , n + i_col_offset , invd ) end function operate","tags":"","loc":"proc/operate~3.html","title":"operate – openpde"},{"text":"private function operate(this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable,target Matrix representing the operator application. Calls proc~~operate~4~~CallsGraph proc~operate~4 operate interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~4->interface~associate_mesh_fd_1d interface~associate_field_fd_1d associate_field_FD_1D proc~operate~4->interface~associate_field_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. real ( R_P ) :: invd !< Temporary 1/D**2 integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp ( i_equ_ )% m ) n = mesh_cur % n n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invd = 1._R_P / ( 2._R_P * mesh_cur % h ) allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) inp_cur => associate_field_FD_1D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n call opr % set ( 1_I_P + i_row_offset , 1_I_P + i_col_offset , invd ) do i = 2 , n - 1 call opr % set ( i + i_row_offset , i + i_col_offset - 1 , - 1._R_P * invd ) call opr % set ( i + i_row_offset , i + i_col_offset + 1 , 1._R_P * invd ) enddo call opr % set ( n + i_row_offset , n + i_col_offset , invd ) end function operate","tags":"","loc":"proc/operate~4.html","title":"operate – openpde"},{"text":"private function operate(this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable,target Matrix representing the operator application. Calls proc~~operate~5~~CallsGraph proc~operate~5 operate proc~associate_field_fd_2d associate_field_FD_2D proc~operate~5->proc~associate_field_fd_2d proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~5->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , i_equ , i_fie , dir ) result ( opr ) !< Operator 2 derivative implicit FD 1D class ( f2m_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), dimension (:), intent ( in ), target :: inp !< Input field. class ( matrix ), allocatable , target :: opr !< Matrix representing the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i , j !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. integer ( I_P ) :: n_tot !< Number of points. integer ( I_P ), intent ( in ), optional :: i_equ !< Counter. integer ( I_P ), intent ( in ), optional :: i_fie !< Counter. integer ( I_P ) :: i_equ_ !< Counter. integer ( I_P ) :: i_fie_ !< Counter. real ( R_P ) :: invd !< Temporary 1/D**2 real ( R_P ) :: invdx !< Temporary 1/D**2 real ( R_P ) :: invdy !< Temporary 1/D**2 integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i_row_offset integer ( I_P ) :: i_col_offset integer ( I_P ) :: i_dir_offset integer ( I_P ) :: i_vec dir_ = 1 ; if ( present ( dir )) dir_ = dir i_equ_ = 1 ; if ( present ( i_equ )) i_equ_ = i_equ i_fie_ = 1 ; if ( present ( i_fie )) i_fie_ = i_fie n_equ = size ( inp ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp ( i_equ_ )% m ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny n_tot = n * n_equ ! no concrete features of matrix are used so dynamic casting is not needed invdx = 1._R_P / mesh_cur % hx ** 2 invdy = 1._R_P / mesh_cur % hy ** 2 allocate ( opr , mold = this % mat ) call opr % init ( n_tot ) i_row_offset = ( i_equ_ - 1 ) * n i_col_offset = ( i_fie_ - 1 ) * n if ( dir_ == 1 ) then i_dir_offset = 1 invd = invdx endif if ( dir_ == 2 ) then i_dir_offset = nx invd = invdy endif inp_cur => associate_field_FD_2D ( field_input = inp ( i_equ_ ), emsg = 'casting error' ) do j = 2 , ny - 1 do i = 2 , nx - 1 i_vec = ( j - 1 ) * nx + i call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset , - 2._R_P * invd ) call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset - i_dir_offset , 1._R_P * invd ) call opr % set ( i_vec + i_row_offset , i_vec + i_col_offset + i_dir_offset , 1._R_P * invd ) enddo enddo end function operate","tags":"","loc":"proc/operate~5.html","title":"operate – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator_adv ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~9.html","title":"free – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. Calls proc~~integrate~~CallsGraph proc~integrate integrate interface~associate_field_fd_1d associate_field_FD_1D proc~integrate->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation definition. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp (:) !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary class ( field_FD_1D ), pointer :: inp_cur (:) !< Field input pointer. class ( field_FD_1D ), pointer :: fields (:,:) !< Fields pointer to MG fields. class ( field_FD_1D ), pointer :: fields0 (:,:) !< Initial fields pointer to MG fields. class ( field_FD_1D ), pointer :: residuals (:,:) !< Residual field pointer to MG fields. class ( field_FD_1D ), pointer :: sources (:,:) !< Sources field pointer to MG fields. class ( field_FD_1D ), pointer :: tau (:,:) !< Field input pointer. integer ( I_P ) :: ie !< Counter. integer ( I_P ) :: iv !< Counter. integer ( I_P ) :: n_levels !< Counter. integer ( I_P ) :: i_mg !< Counter. integer ( I_P ) :: i_up !< Counter. integer ( I_P ) :: i_down !< Counter. if ( equ % enable_explicit ) then !print*,'Explicit solver enabled' ! (1a) Imposes boundary conditions: modify \"inp\" field array call equ % bc_e ( inp = inp , t = t ) ! (1b) Computes the residual term: modify \"equ%resvar_e\" call equ % resid_e ( inp = inp , t = t ) ! (1c) Updates the inp field according to Euler scheme do ie = 1 , size ( inp ) inp ( ie ) = inp ( ie ) + this % dt * equ % resvar_e ( ie ) enddo endif if ( equ % enable_implicit ) then !print*,'Implicit solver enabled' ! (2a) Computes the residual term: modify \"equ%resvar_i\" call equ % resid_i ( inp = inp , t = t ) ! (2b) Compute the linear solver matrix and vector this % matA = this % mat_identity - this % dt * equ % resvar_i !this%matA = this%mat_identity - ((1._R_P-this%alpha)*this%dt) * equ%resvar_i this % vecB = equ % f2v_opr % operate ( inp ) ! (2c) Impose boundary conditions call equ % bc_i ( matA = this % matA , vecB = this % vecB , t = t ) !          call this%matA%output(\"matA.dat\") !          call this%vecB%output(\"vecB.dat\") ! (2d) Assign solver vector and matrix (A and b of A*x=b) call equ % solver % set_vector ( this % vecB ) call equ % solver % set_matrix ( this % matA ) ! (2e) Solve linear system call equ % solver % solve () ! (2f) Assign the solution to the input field this % vecS = equ % solver % sol !          call this%vecS%output(\"vecS.dat\") call equ % v2f_opr % operate ( this % vecS , inp ) endif if ( equ % enable_multigrid ) then n_levels = equ % mg % levels_number inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) tau => associate_field_FD_1D ( field_input = equ % mg % tau , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields => associate_field_FD_1D ( field_input = equ % mg % fields , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields0 => associate_field_FD_1D ( field_input = equ % mg % fields0 , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) residuals => associate_field_FD_1D ( field_input = equ % mg % residuals , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) sources => associate_field_FD_1D ( field_input = equ % mg % sources , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) do ie = 1 , equ % n_equ fields ( ie , 1 ) = inp_cur ( ie ) enddo !  du ! ---- + R(u) = 0 !  dt ! Start multigrid v-cycle v_cycle : do iv = 1 , equ % mg % max_iterations ! Iterations for actual grid (fine grid) - Smoothing iteration i_mg = 1 do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! R(u) evaluation call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Check convergence ! equ%mg%norm = equ%mg%compute_norm(residuals(:,i_mg)) ! TODO implement norm print * , \"iv, Multigrid convergence norm: \" , iv , equ % mg % norm if ( equ % mg % norm <= equ % mg % tolerance ) then print * , \"iv, Convergence reached: \" , iv exit v_cycle endif ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo ! Iterations for nested grids (coarse grids) - downward do i_mg = 2 , n_levels ! Tasks: ! (1) Approximation of coarse grid solution ! (2) Source term evaluation ! Restriction of solution fine => coarse ! fields(:,i_mg) = equ%mg%restriction(fields(:,i_mg-1)) ! TODO implement resistriction ! Save restriction do ie = 1 , equ % n_equ fields0 ( ie , i_mg ) = fields ( ie , i_mg ) enddo ! Collect residuals fine => coarse ! sources(:,i_mg) = equ%mg%collect(residuals(:,i_mg-1)) ! TODO implement collect ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Compute source term for coarse grid do ie = 1 , equ % n_equ sources ( ie , i_mg ) = sources ( ie , i_mg ) - residuals ( ie , i_mg ) enddo ! Tasks: ! (1) Smoothing iteration: new estimate computation !--------------------------------------------------------------------------- do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo do i_mg = n_levels - 1 , 2 , - 1 ! Tasks: ! (1) Correction estimation ! (2) Prolungation ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields is the correction enddo ! Prolongation coarse => fine ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation ! Tasks: ! (1) Smoothing iteration: new estimate computation do i_down = 1 , equ % mg % n_it_down ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo i_mg = 1 ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields correction enddo ! Prolungation to finest grid ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation enddo v_cycle do ie = 1 , size ( inp , dim = 1 ) inp_cur ( ie ) = fields ( ie , 1 ) enddo endif error = 0 end function integrate","tags":"","loc":"proc/integrate.html","title":"integrate – openpde"},{"text":"private subroutine init(this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: n integer ( I_P ) :: i n = equ % n_size call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.005_R_P if ( present ( error )) error = 0 endif this % alpha = 0._R_P allocate ( this % matA , mold = equ % solver % mat ) allocate ( this % vecB , mold = equ % solver % vec ) allocate ( this % vecS , mold = equ % solver % sol ) call this % matA % init ( n ) call this % vecB % init ( n ) call this % vecS % init ( n ) allocate ( this % mat_identity , mold = equ % solver % mat ) call this % mat_identity % init ( n ) do i = 1 , this % mat_identity % n call this % mat_identity % set ( i , i , 1._R_P ) enddo !call this%mat_identity%output(\"identity.dat\") end subroutine init","tags":"","loc":"proc/init~8.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_euler_implicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json.html","title":"load_from_json – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Uses: openpde_field_FD_1D proc~~integrate~2~~UsesGraph proc~integrate~2 integrate module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_fd_1d->proc~integrate~2 module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d var panprocintegrate2UsesGraph = svgPanZoom('#procintegrate2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. Source Code integrate Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. use openpde_field_FD_1D class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target , dimension (:) :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary integer ( I_P ) :: ie !< Count equation ! Imposes boundary conditions: modify \"inp\" field array call equ % bc_e ( inp = inp , t = t ) !allocate(for(size(inp)), mold=inp(1)) !do ie=1,size(inp) !    call for(ie)%init(field_mesh=inp(1)%m) !enddo ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? !associate(for1 => for(1)) !    select type(for1) !        type is(field_FD_1D) !            print*,\"size of for1: \",size(for1%val) !    end select !endassociate ! Computes the residual term: modify \"equ%resvar_e\" call equ % resid_e ( inp = inp , t = t ) ! Updates the inp field according to Euler scheme do ie = 1 , size ( inp ) inp ( ie ) = inp ( ie ) + this % dt * equ % resvar_e ( ie ) enddo !RIMETTERE for = equ%resid_e(inp=inp, t=t) !RIMETTERE inp = inp + this%dt * for error = 0 end function integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – openpde"},{"text":"private subroutine init(this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~9.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~2.html","title":"load_from_json – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. Calls proc~~integrate~3~~CallsGraph proc~integrate~3 integrate interface~associate_field_fd_1d associate_field_FD_1D proc~integrate~3->interface~associate_field_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation definition. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp (:) !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable , dimension (:) :: for !< Temporary class ( field_FD_1D ), pointer :: inp_cur (:) !< Field input pointer. class ( field_FD_1D ), pointer :: fields (:,:) !< Fields pointer to MG fields. class ( field_FD_1D ), pointer :: fields0 (:,:) !< Initial fields pointer to MG fields. class ( field_FD_1D ), pointer :: residuals (:,:) !< Residual field pointer to MG fields. class ( field_FD_1D ), pointer :: sources (:,:) !< Sources field pointer to MG fields. class ( field_FD_1D ), pointer :: tau (:,:) !< Field input pointer. integer ( I_P ) :: ie !< Counter. integer ( I_P ) :: iv !< Counter. integer ( I_P ) :: n_levels !< Counter. integer ( I_P ) :: i_mg !< Counter. integer ( I_P ) :: i_up !< Counter. integer ( I_P ) :: i_down !< Counter. integer ( I_P ) :: s integer ( I_P ) :: ss if ( equ % enable_explicit ) then do s = 1 , this % n_stages do ie = 1 , size ( inp ) this % stages ( s , ie ) = inp ( ie ) enddo do ie = 1 , size ( inp ) do ss = 1 , s - 1 this % stages ( s , ie ) = this % stages ( s , ie ) + this % stages ( ss , ie ) * ( this % dt * this % rk_alph ( s , ss )) enddo enddo call equ % bc_e ( inp = this % stages ( s ,:), t = t ) call equ % resid_e ( inp = this % stages ( s ,:), t = t ) do ie = 1 , size ( inp ) this % stages ( s , ie ) = equ % resvar_e ( ie ) enddo enddo ! computing new time step do ie = 1 , size ( inp ) do s = 1 , this % n_stages inp ( ie ) = inp ( ie ) + this % stages ( s , ie ) * ( this % dt * this % rk_beta ( s )) enddo enddo endif if ( equ % enable_implicit ) then STOP \"rk implicit to be implemented\" !print*,'Implicit solver enabled' ! (2a) Computes the residual term: modify \"equ%resvar_i\" call equ % resid_i ( inp = inp , t = t ) ! (2b) Compute the linear solver matrix and vector this % matA = this % mat_identity - this % dt * equ % resvar_i !this%matA = this%mat_identity - ((1._R_P-this%alpha)*this%dt) * equ%resvar_i this % vecB = equ % f2v_opr % operate ( inp ) ! (2c) Impose boundary conditions call equ % bc_i ( matA = this % matA , vecB = this % vecB , t = t ) !          call this%matA%output(\"matA.dat\") !          call this%vecB%output(\"vecB.dat\") ! (2d) Assign solver vector and matrix (A and b of A*x=b) call equ % solver % set_vector ( this % vecB ) call equ % solver % set_matrix ( this % matA ) ! (2e) Solve linear system call equ % solver % solve () ! (2f) Assign the solution to the input field this % vecS = equ % solver % sol !          call this%vecS%output(\"vecS.dat\") call equ % v2f_opr % operate ( this % vecS , inp ) endif if ( equ % enable_multigrid ) then STOP \"rk mg to be implemented\" n_levels = equ % mg % levels_number inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) tau => associate_field_FD_1D ( field_input = equ % mg % tau , emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields => associate_field_FD_1D ( field_input = equ % mg % fields , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) fields0 => associate_field_FD_1D ( field_input = equ % mg % fields0 , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) residuals => associate_field_FD_1D ( field_input = equ % mg % residuals , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) sources => associate_field_FD_1D ( field_input = equ % mg % sources , & emsg = 'calling procedure integrator_adv_euler_implicit%integrate' ) do ie = 1 , equ % n_equ fields ( ie , 1 ) = inp_cur ( ie ) enddo !  du ! ---- + R(u) = 0 !  dt ! Start multigrid v-cycle v_cycle : do iv = 1 , equ % mg % max_iterations ! Iterations for actual grid (fine grid) - Smoothing iteration i_mg = 1 do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! R(u) evaluation call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Check convergence ! equ%mg%norm = equ%mg%compute_norm(residuals(:,i_mg)) ! TODO implement norm print * , \"iv, Multigrid convergence norm: \" , iv , equ % mg % norm if ( equ % mg % norm <= equ % mg % tolerance ) then print * , \"iv, Convergence reached: \" , iv exit v_cycle endif ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo ! Iterations for nested grids (coarse grids) - downward do i_mg = 2 , n_levels ! Tasks: ! (1) Approximation of coarse grid solution ! (2) Source term evaluation ! Restriction of solution fine => coarse ! fields(:,i_mg) = equ%mg%restriction(fields(:,i_mg-1)) ! TODO implement resistriction ! Save restriction do ie = 1 , equ % n_equ fields0 ( ie , i_mg ) = fields ( ie , i_mg ) enddo ! Collect residuals fine => coarse ! sources(:,i_mg) = equ%mg%collect(residuals(:,i_mg-1)) ! TODO implement collect ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Compute source term for coarse grid do ie = 1 , equ % n_equ sources ( ie , i_mg ) = sources ( ie , i_mg ) - residuals ( ie , i_mg ) enddo ! Tasks: ! (1) Smoothing iteration: new estimate computation !--------------------------------------------------------------------------- do i_up = 1 , equ % mg % n_it_up ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo do i_mg = n_levels - 1 , 2 , - 1 ! Tasks: ! (1) Correction estimation ! (2) Prolungation ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields is the correction enddo ! Prolongation coarse => fine ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation ! Tasks: ! (1) Smoothing iteration: new estimate computation do i_down = 1 , equ % mg % n_it_down ( i_mg ) ! Compute R(u) on coarse grid (same result as normal explicit case) call equ % resid_emg ( inp = fields (:, i_mg ), t = t , output = residuals (:, i_mg )) ! Summing du/dt (it results 0 only when converged) ! call this%temp_sum(residuals(:,i_mg)) ! TODO implement temp_sum ! Add source term do ie = 1 , equ % n_equ residuals ( ie , i_mg ) = residuals ( ie , i_mg ) + sources ( ie , i_mg ) enddo ! Update of current estimate do ie = 1 , equ % n_equ fields ( ie , i_mg ) = fields ( ie , i_mg ) + residuals ( ie , i_mg ) * tau ( ie , i_mg ) enddo enddo enddo i_mg = 1 ! Compute correction at coarser grid do ie = 1 , equ % n_equ fields ( ie , i_mg + 1 ) = fields ( ie , i_mg + 1 ) - fields0 ( ie , i_mg + 1 ) ! now fields correction enddo ! Prolungation to finest grid ! fields(:,i_mg) = fields(:,i_mg) + equ%mg%prolongation(fields(:,i_mg+1)) ! TODO implement prolongation enddo v_cycle do ie = 1 , size ( inp , dim = 1 ) inp_cur ( ie ) = fields ( ie , 1 ) enddo endif error = 0 end function integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – openpde"},{"text":"private subroutine init(this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , equ , description , filename , error ) !< Initialize integrator. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. class ( equation_adv ), intent ( inout ), target :: equ !< The equation. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: n integer ( I_P ) :: i this % n_stages = 5 allocate ( this % rk_alph ( this % n_stages , this % n_stages )) allocate ( this % rk_beta ( this % n_stages )) allocate ( this % rk_gamm ( this % n_stages )) this % rk_alph (:,:) = 0._R_P this % rk_beta (:) = 0._R_P this % rk_gamm (:) = 0._R_P allocate ( this % stages ( this % n_stages , equ % n_equ ), mold = equ % resvar_e ( 1 )) select case ( this % n_stages ) case ( 1 ) ! RK(1,1) Forward-Euler this % rk_beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) this % rk_beta ( 1 ) = 0.5_R_P this % rk_beta ( 2 ) = 0.5_R_P this % rk_alph ( 2 , 1 ) = 1._R_P this % rk_gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) this % rk_beta ( 1 ) = 1._R_P / 6._R_P this % rk_beta ( 2 ) = 1._R_P / 6._R_P this % rk_beta ( 3 ) = 2._R_P / 3._R_P this % rk_alph ( 2 , 1 ) = 1._R_P this % rk_alph ( 3 , 1 ) = 0.25_R_P this % rk_alph ( 3 , 2 ) = 0.25_R_P this % rk_gamm ( 2 ) = 1._R_P this % rk_gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) this % rk_beta ( 1 ) = 0.14681187618661_R_P this % rk_beta ( 2 ) = 0.24848290924556_R_P this % rk_beta ( 3 ) = 0.10425883036650_R_P this % rk_beta ( 4 ) = 0.27443890091960_R_P this % rk_beta ( 5 ) = 0.22600748319395_R_P this % rk_alph ( 2 , 1 ) = 0.39175222700392_R_P this % rk_alph ( 3 , 1 ) = 0.21766909633821_R_P this % rk_alph ( 3 , 2 ) = 0.36841059262959_R_P this % rk_alph ( 4 , 1 ) = 0.08269208670950_R_P this % rk_alph ( 4 , 2 ) = 0.13995850206999_R_P this % rk_alph ( 4 , 3 ) = 0.25189177424738_R_P this % rk_alph ( 5 , 1 ) = 0.06796628370320_R_P this % rk_alph ( 5 , 2 ) = 0.11503469844438_R_P this % rk_alph ( 5 , 3 ) = 0.20703489864929_R_P this % rk_alph ( 5 , 4 ) = 0.54497475021237_R_P this % rk_gamm ( 2 ) = 0.39175222700392_R_P this % rk_gamm ( 3 ) = 0.58607968896780_R_P this % rk_gamm ( 4 ) = 0.47454236302687_R_P this % rk_gamm ( 5 ) = 0.93501063100924_R_P endselect n = equ % n_size call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.0005_R_P if ( present ( error )) error = 0 endif this % alpha = 0._R_P allocate ( this % matA , mold = equ % solver % mat ) allocate ( this % vecB , mold = equ % solver % vec ) allocate ( this % vecS , mold = equ % solver % sol ) call this % matA % init ( n ) call this % vecB % init ( n ) call this % vecS % init ( n ) allocate ( this % mat_identity , mold = equ % solver % mat ) call this % mat_identity % init ( n ) do i = 1 , this % mat_identity % n call this % mat_identity % set ( i , i , 1._R_P ) enddo !call this%mat_identity%output(\"identity.dat\") end subroutine init","tags":"","loc":"proc/init~10.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_adv_rk_implicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"rk implicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"rk implicit\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~3.html","title":"load_from_json – openpde"},{"text":"public function associate_vector_simple(vector_input, emsg) result(vector_pointer) Check the type of the vector passed as input and return a vector pointer with type vector_simple Arguments Type Intent Optional Attributes Name class( vector ), intent(in), target :: vector_input Input vector. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( vector_simple ),\n  pointer Simple vector pointer. Called By proc~~associate_vector_simple~~CalledByGraph proc~associate_vector_simple associate_vector_simple proc~assign_vector assign_vector proc~assign_vector->proc~associate_vector_simple proc~solve solve proc~solve->proc~associate_vector_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_vector_simple Source Code function associate_vector_simple ( vector_input , emsg ) result ( vector_pointer ) !< Check the type of the vector passed as input and return a vector pointer with type vector_simple class ( vector ), intent ( in ), target :: vector_input !< Input vector. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( vector_simple ), pointer :: vector_pointer !< Simple vector pointer. select type ( vector_input ) type is ( vector_simple ) vector_pointer => vector_input class default write ( stderr , '(A)' ) 'error: cast vector to vector_simple' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_vector_simple","tags":"","loc":"proc/associate_vector_simple.html","title":"associate_vector_simple – openpde"},{"text":"private function get(this, i) result(val) Get vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. Return Value real(kind=R_P) Value to assign. Source Code get Source Code function get ( this , i ) result ( val ) !< Get vector value class ( vector_simple ), intent ( in ) :: this !< The vector. integer ( I_P ), intent ( in ) :: i !< Vector index filled. real ( R_P ) :: val !< Value to assign. val = this % val ( i ) end function get","tags":"","loc":"proc/get.html","title":"get – openpde"},{"text":"private subroutine assign_vector(lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. Calls proc~~assign_vector~~CallsGraph proc~assign_vector assign_vector proc~associate_vector_simple associate_vector_simple proc~assign_vector->proc~associate_vector_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_vector Source Code subroutine assign_vector ( lhs , rhs ) !< Assignment overloading. class ( vector_simple ), intent ( inout ) :: lhs !< Left hand side. class ( vector ), intent ( in ), target :: rhs !< Right hand side. class ( vector_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_vector_simple ( vector_input = rhs , emsg = 'calling procedure vector_simple%assign_vector' ) lhs % val = rhs_cur % val !TODO automatic lhs%val allocation can occur here, is it ok? end subroutine assign_vector","tags":"","loc":"proc/assign_vector.html","title":"assign_vector – openpde"},{"text":"private subroutine init(this, n, description, error) Initialize vector. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , n , description , error ) !< Initialize vector. class ( vector_simple ), intent ( inout ) :: this !< The vector. integer ( I_P ), intent ( in ) :: n !< Vector number of elements. character ( * ), intent ( in ), optional :: description !< Vector description. integer ( I_P ), intent ( out ), optional :: error !< Error status. this % n = n allocate ( this % val ( n )) this % val (:) = 0._R_P !TODO might be avoided here end subroutine init","tags":"","loc":"proc/init~11.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Print (naively) vector Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , filename , error ) !< Print (naively) vector class ( vector_simple ), intent ( inout ) :: this !< The vector. character ( * ), intent ( in ) :: filename !< Output file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Loop index open ( unit = 11 , file = filename ) do i = 1 , this % n write ( 11 , \"(G15.8)\" ) this % val ( i ) enddo close ( 11 ) end subroutine output","tags":"","loc":"proc/output~7.html","title":"output – openpde"},{"text":"private subroutine set(this, i, val) Set vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. real(kind=R_P), intent(in) :: val Value to assign. Source Code set Source Code subroutine set ( this , i , val ) !< Set vector value class ( vector_simple ), intent ( inout ) :: this !< The vector. real ( R_P ), intent ( in ) :: val !< Value to assign. integer ( I_P ), intent ( in ) :: i !< Vector index filled. this % val ( i ) = val end subroutine set","tags":"","loc":"proc/set~3.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( vector ), intent ( inout ) :: this !< The vector. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~10.html","title":"free – openpde"},{"text":"private function jacobian(this, inp, t) result(opr) Return the jacobian, useful for multigrid Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( matrix ),\n  allocatable Field computed. Source Code jacobian Source Code function jacobian ( this , inp , t ) result ( opr ) !< Return the jacobian, useful for multigrid class ( equation_adv ), intent ( in ) :: this !< The equation. class ( field ), intent ( in ), target :: inp !< Input field. real ( R_P ), intent ( in ) :: t !< Time. class ( matrix ), allocatable :: opr !< Field computed. STOP 'jacobian to be implemented by your equation and depending on your integrator' end function jacobian","tags":"","loc":"proc/jacobian.html","title":"jacobian – openpde"},{"text":"private subroutine init(this, n_equ, field_mesh, inp, description, filename, error) Initialize equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. integer(kind=I_P), intent(in) :: n_equ Number of equations class( mesh ), intent(in), target :: field_mesh Mesh of the field. class( field ), intent(inout), target :: inp (:) Input field. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , n_equ , field_mesh , inp , description , filename , error ) !< Initialize equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. integer ( I_P ), intent ( in ) :: n_equ !< Number of equations class ( mesh ), intent ( in ), target :: field_mesh !< Mesh of the field. class ( field ), intent ( inout ), target :: inp (:) !< Input field. character ( * ), intent ( in ), optional :: description !< Equation description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. STOP 'init to be implemented by your equation and depending on your integrator' end subroutine init","tags":"","loc":"proc/init~12.html","title":"init – openpde"},{"text":"private subroutine bc_e(this, inp, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. Source Code bc_e Source Code subroutine bc_e ( this , inp , t ) !< Equation boundary condition. class ( equation_adv ), intent ( in ) :: this !< The equation. class ( field ), intent ( inout ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'bc_e to be implemented by your equation and depending on your integrator' end subroutine bc_e","tags":"","loc":"proc/bc_e.html","title":"bc_e – openpde"},{"text":"private subroutine bc_i(this, matA, vecB, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( matrix ), intent(inout), target :: matA Input field. class( vector ), intent(inout), target :: vecB Input field. real(kind=R_P), intent(in) :: t Time. Source Code bc_i Source Code subroutine bc_i ( this , matA , vecB , t ) !< Equation boundary condition. class ( equation_adv ), intent ( in ) :: this !< The equation. class ( matrix ), intent ( inout ), target :: matA !< Input field. class ( vector ), intent ( inout ), target :: vecB !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'bc_i to be implemented by your equation and depending on your integrator' end subroutine bc_i","tags":"","loc":"proc/bc_i.html","title":"bc_i – openpde"},{"text":"private subroutine resid_e(this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. Source Code resid_e Source Code subroutine resid_e ( this , inp , t ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_e to be implemented by your equation and depending on your integrator' end subroutine resid_e","tags":"","loc":"proc/resid_e.html","title":"resid_e – openpde"},{"text":"private subroutine resid_emg(this, inp, t, output) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. class( field ), intent(out), target :: output (:) Input field. Source Code resid_emg Source Code subroutine resid_emg ( this , inp , t , output ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. class ( field ), intent ( out ), target :: output (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_emg to be implemented by your equation and depending on your integrator' end subroutine resid_emg","tags":"","loc":"proc/resid_emg.html","title":"resid_emg – openpde"},{"text":"private subroutine resid_i(this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. Source Code resid_i Source Code subroutine resid_i ( this , inp , t ) !< Return the field after forcing the equation. class ( equation_adv ), intent ( inout ) :: this !< The equation. class ( field ), intent ( in ), target :: inp (:) !< Input field. real ( R_P ), intent ( in ) :: t !< Time. STOP 'resid_i to be implemented by your equation and depending on your integrator' end subroutine resid_i","tags":"","loc":"proc/resid_i.html","title":"resid_i – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. To be completed. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. !< !< To be completed. class ( equation_adv ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~11.html","title":"free – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~6~~CallsGraph proc~operate~6 operate proc~associate_field_fd_2d associate_field_FD_2D proc~operate~6->proc~associate_field_fd_2d proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~6->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) inp_cur => associate_field_FD_2D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FD_2D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - 2._R_P * inp_cur % val ( i , :) + inp_cur % val ( i - 1 , :)) / ( mesh_cur % hx ** 2 ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - 2._R_P * inp_cur % val (:, j ) + inp_cur % val (:, j - 1 )) / ( mesh_cur % hy ** 2 ) enddo endif end function operate","tags":"","loc":"proc/operate~6.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~7~~CallsGraph proc~operate~7 operate proc~associate_field_fd_2d associate_field_FD_2D proc~operate~7->proc~associate_field_fd_2d proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~7->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_2D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_2D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: dir_ !< Direction of operation. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. allocate ( field_FD_2D :: opr ) opr_cur => associate_field_FD_2D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) inp_cur => associate_field_FD_2D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) mesh_cur => associate_mesh_FD_2D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FD_2D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) dir_ = 1 ; if ( present ( dir )) dir_ = dir if ( dir_ == 1 ) then do i = 1 , mesh_cur % nx opr_cur % val ( i , :) = ( inp_cur % val ( i + 1 , :) - inp_cur % val ( i , :)) / ( mesh_cur % hx ) enddo else do j = 1 , mesh_cur % ny opr_cur % val (:, j ) = ( inp_cur % val (:, j + 1 ) - inp_cur % val (:, j )) / ( mesh_cur % hy ) enddo endif end function operate","tags":"","loc":"proc/operate~7.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~8~~CallsGraph proc~operate~8 operate proc~associate_field_fv_1d associate_field_FV_1D proc~operate~8->proc~associate_field_fv_1d proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~operate~8->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FV_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FV_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. integer ( I_P ) :: i !< Counter. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) inp_cur => associate_field_FV_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FV_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do b = 1 , mesh_cur % nb do i = 1 , mesh_cur % blocks ( b )% n opr_cur % blocks ( b )% val ( i ) = ( inp_cur % blocks ( b )% val ( i + 1 ) - inp_cur % blocks ( b )% val ( i )) / ( mesh_cur % blocks ( b )% h ) enddo enddo end function operate","tags":"","loc":"proc/operate~8.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~9~~CallsGraph proc~operate~9 operate proc~associate_field_fv_1d associate_field_FV_1D proc~operate~9->proc~associate_field_fv_1d proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~operate~9->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FV_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FV_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FV_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FV_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: b !< Counter. integer ( I_P ) :: i !< Counter. allocate ( field_FV_1D :: opr ) opr_cur => associate_field_FV_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) inp_cur => associate_field_FV_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) mesh_cur => associate_mesh_FV_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FV_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do b = 1 , mesh_cur % nb do i = 1 , mesh_cur % blocks ( b )% n opr_cur % blocks ( b )% val ( i ) = ( inp_cur % blocks ( b )% val ( i + 1 ) - & 2._R_P * inp_cur % blocks ( b )% val ( i ) + & inp_cur % blocks ( b )% val ( i - 1 )) / ( mesh_cur % blocks ( b )% h ** 2 ) enddo enddo end function operate","tags":"","loc":"proc/operate~9.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~10~~CallsGraph proc~operate~10 operate interface~associate_field_fd_1d associate_field_FD_1D proc~operate~10->interface~associate_field_fd_1d interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~10->interface~associate_mesh_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d1_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d1_FD_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - inp_cur % val ( i )) / ( mesh_cur % h ) enddo end function operate","tags":"","loc":"proc/operate~10.html","title":"operate – openpde"},{"text":"private function operate(this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable,target Field resulting after the operator application. Calls proc~~operate~11~~CallsGraph proc~operate~11 operate interface~associate_field_fd_1d associate_field_FD_1D proc~operate~11->interface~associate_field_fd_1d interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~11->interface~associate_mesh_fd_1d proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , inp , dir ) result ( opr ) !< Operator operation. class ( spatial_operator_d2_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), target :: inp !< Input field. integer ( I_P ), intent ( in ), optional :: dir !< Direction of operation. class ( field ), allocatable , target :: opr !< Field resulting after the operator application. class ( field_FD_1D ), pointer :: inp_cur !< Dummy pointer for input field. class ( field_FD_1D ), pointer :: opr_cur !< Dummy pointer for operator result. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. allocate ( field_FD_1D :: opr ) opr_cur => associate_field_FD_1D ( field_input = opr , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) inp_cur => associate_field_FD_1D ( field_input = inp , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) mesh_cur => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure spatial_operator_d2_FD_1D%operate' ) call opr_cur % associate_mesh ( field_mesh = inp % m ) do i = 1 , mesh_cur % n opr_cur % val ( i ) = ( inp_cur % val ( i + 1 ) - 2._R_P * inp_cur % val ( i ) + inp_cur % val ( i - 1 )) / ( mesh_cur % h ** 2 ) enddo end function operate","tags":"","loc":"proc/operate~11.html","title":"operate – openpde"},{"text":"private function operate(this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector. Calls proc~~operate~12~~CallsGraph proc~operate~12 operate interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~12->interface~associate_mesh_fd_1d interface~associate_field_fd_1d associate_field_FD_1D proc~operate~12->interface~associate_field_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 proc~associate_field_fd_1d_scalar associate_field_FD_1D_scalar interface~associate_field_fd_1d->proc~associate_field_fd_1d_scalar proc~associate_field_fd_1d_rank2 associate_field_FD_1D_rank2 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank2 proc~associate_field_fd_1d_rank1 associate_field_FD_1D_rank1 interface~associate_field_fd_1d->proc~associate_field_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , fie ) result ( vec ) !< Operator operation. class ( f2v_FD_1D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), dimension (:), target :: fie !< Input field. class ( vector ), allocatable :: vec !< Returned vector. class ( field_FD_1D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_1D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = size ( fie ) mesh_cur => associate_mesh_FD_1D ( mesh_input = fie ( 1 )% m , emsg = 'mesh' ) n = mesh_cur % n allocate ( vec , mold = this % vec ) call vec % init ( n * n_equ ) do i_equ = 1 , n_equ fie_cur => associate_field_FD_1D ( field_input = fie ( i_equ ), emsg = 'casting error' ) ! No concrete features of vector are used so dynamic casting is not needed do i = 1 , n i_vec = n * ( i_equ - 1 ) + i !    print*,\"i, fie_cur%val(i) :\",i, fie_cur%val(i) call vec % set ( i_vec , fie_cur % val ( i )) enddo enddo end function operate","tags":"","loc":"proc/operate~12.html","title":"operate – openpde"},{"text":"private function operate(this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector. Calls proc~~operate~13~~CallsGraph proc~operate~13 operate proc~associate_field_fd_2d associate_field_FD_2D proc~operate~13->proc~associate_field_fd_2d proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~13->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code operate Source Code function operate ( this , fie ) result ( vec ) !< Operator operation. class ( f2v_FD_2D ), intent ( in ) :: this !< The operator. class ( field ), intent ( in ), dimension (:), target :: fie !< Input field. class ( vector ), allocatable :: vec !< Returned vector. class ( field_FD_2D ), pointer :: fie_cur !< Dummy pointer for input field. class ( mesh_FD_2D ), pointer :: mesh_cur !< Dummy pointer for mesh. integer ( I_P ) :: i , j !< Counter. integer ( I_P ) :: i_equ !< Counter. integer ( I_P ) :: i_vec !< Counter. integer ( I_P ) :: n , nx , ny !< Number of points. integer ( I_P ) :: n_equ !< Number of points. n_equ = size ( fie ) mesh_cur => associate_mesh_FD_2D ( mesh_input = fie ( 1 )% m , emsg = 'mesh' ) nx = mesh_cur % nx ny = mesh_cur % ny n = nx * ny allocate ( vec , mold = this % vec ) call vec % init ( n * n_equ ) do i_equ = 1 , n_equ fie_cur => associate_field_FD_2D ( field_input = fie ( i_equ ), emsg = 'casting error' ) ! No concrete features of vector are used so dynamic casting is not needed do j = 1 , ny do i = 1 , nx i_vec = n * ( n_equ - 1 ) + ( j - 1 ) * nx + i !    print*,\"i, fie_cur%val(i) :\",i, fie_cur%val(i) call vec % set ( i_vec , fie_cur % val ( i , j )) enddo enddo enddo end function operate","tags":"","loc":"proc/operate~13.html","title":"operate – openpde"},{"text":"private function integrate(this, equ, t, inp) result(error) Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Source Code integrate Source Code function integrate ( this , equ , t , inp ) result ( error ) !< Integrate the field accordingly the to equation by means of the Euler explicit scheme. class ( integrator_euler_explicit ), intent ( in ) :: this !< The integrator. class ( equation ), intent ( in ), target :: equ !< The equation. real ( R_P ), intent ( in ) :: t !< Time. class ( field ), intent ( inout ), target :: inp !< Input field. integer ( I_P ) :: error !< Error status. class ( field ), allocatable :: for !< Temporary call equ % bc ( inp = inp , t = t ) allocate ( for , mold = inp ) ! the temporary variable for seems to be needed by intel compiler ! otherwise there is an internal compiler error or seg fault ! especially multiplying by this%dt. Why....? for = equ % forcing ( inp = inp , t = t ) inp = inp + this % dt * for error = 0 end function integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – openpde"},{"text":"private subroutine init(this, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , description , filename , error ) !< Initialize integrator. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ), optional :: description !< Integrator description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % dt = 0.001_R_P if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~13.html","title":"init – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load integrator definition from JSON file. class ( integrator_euler_explicit ), intent ( inout ) :: this !< The integrator. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: integrator_type !< Integrator type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'integrator.type' , integrator_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( integrator_type == \"euler explicit\" ) then call json % get ( 'integrator.dt' , this % dt , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"dt\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: integrator definition of \"' // filename // '\" is not \"euler explicit\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~4.html","title":"load_from_json – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( integrator ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~12.html","title":"free – openpde"},{"text":"private subroutine create_subgrids_field(this, inp, subgrids) Create subgrid-levels field. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. Source Code create_subgrids_field Source Code subroutine create_subgrids_field ( this , inp , subgrids ) !< Create subgrid-levels field. class ( multigrid_FD_1D ), intent ( in ), target :: this !< The solver. class ( field ), intent ( in ) :: inp (:) !< Input field on finest mesh. class ( field ), intent ( inout ) :: subgrids (:,:) !< Subgrid-levels field. integer ( I_P ) :: e !< Counter. integer ( I_P ) :: l !< Counter. do l = 1 , this % levels_number do e = 1 , size ( subgrids , dim = 1 ) subgrids ( e , l )% m => this % meshes ( l ) enddo enddo end subroutine create_subgrids_field","tags":"","loc":"proc/create_subgrids_field.html","title":"create_subgrids_field – openpde"},{"text":"private subroutine init(this, inp, levels_number) Init multigrid solver. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Number of MG levels. Calls proc~~init~14~~CallsGraph proc~init~14 init interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~init~14->interface~associate_mesh_fd_1d proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( this , inp , levels_number ) !< Init multigrid solver. class ( multigrid_FD_1D ), intent ( inout ) :: this !< The solver. class ( field ), intent ( in ), target :: inp !< Input field on finest mesh. integer ( I_P ), intent ( in ) :: levels_number !< Number of MG levels. class ( mesh_FD_1D ), pointer :: mesh_finest !< Pointer to finest mesh. class ( mesh_FD_1D ), pointer :: mesh_mg (:) !< Pointer to MG meshes. integer ( I_P ) :: l !< Counter. integer ( I_P ) :: n_mg !< Counter. allocate ( this % meshes ( this % levels_number ), mold = inp % m ) mesh_finest => associate_mesh_FD_1D ( mesh_input = inp % m , emsg = 'calling procedure multigrid_FD_1D%init' ) mesh_mg => associate_mesh_FD_1D ( mesh_input = this % meshes , emsg = 'calling procedure multigrid_FD_1D%init' ) mesh_mg ( 1 ) = mesh_finest do l = 2 , this % levels_number n_mg = mesh_mg ( l - 1 )% n / 2 + 1 mesh_mg ( l )% n = n_mg mesh_mg ( l )% ng = mesh_mg ( l - 1 )% ng enddo end subroutine init","tags":"","loc":"proc/init~14.html","title":"init – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(inout) :: this The linsolver. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( multigrid ), intent ( inout ) :: this !< The linsolver. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % fields )) deallocate ( this % fields ) if ( allocated ( this % meshes )) deallocate ( this % meshes ) if ( allocated ( this % fields0 )) deallocate ( this % fields0 ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) if ( allocated ( this % sources )) deallocate ( this % sources ) if ( allocated ( this % n_it_up )) deallocate ( this % n_it_up ) if ( allocated ( this % n_it_down )) deallocate ( this % n_it_down ) if ( allocated ( this % stability )) deallocate ( this % stability ) if ( allocated ( this % tau )) deallocate ( this % tau ) end subroutine free","tags":"","loc":"proc/free~13.html","title":"free – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The integrator. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( matrix ), intent ( inout ) :: this !< The integrator. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~14.html","title":"free – openpde"},{"text":"public function associate_matrix_simple(matrix_input, emsg) result(matrix_pointer) Check the type of the matrix passed as input and return a matrix pointer with type matrix_simple Arguments Type Intent Optional Attributes Name class( matrix ), intent(in), target :: matrix_input Input matrix. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( matrix_simple ),\n  pointer Simple matrix pointer. Called By proc~~associate_matrix_simple~~CalledByGraph proc~associate_matrix_simple associate_matrix_simple proc~add~7 add proc~add~7->proc~associate_matrix_simple proc~realmul~7 realmul proc~realmul~7->proc~associate_matrix_simple proc~assign_matrix assign_matrix proc~assign_matrix->proc~associate_matrix_simple proc~solve solve proc~solve->proc~associate_matrix_simple proc~sub~7 sub proc~sub~7->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_matrix_simple Source Code function associate_matrix_simple ( matrix_input , emsg ) result ( matrix_pointer ) !< Check the type of the matrix passed as input and return a matrix pointer with type matrix_simple class ( matrix ), intent ( in ), target :: matrix_input !< Input matrix. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( matrix_simple ), pointer :: matrix_pointer !< Simple matrix pointer. select type ( matrix_input ) type is ( matrix_simple ) matrix_pointer => matrix_input class default write ( stderr , '(A)' ) 'error: cast matrix to matrix_simple' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_matrix_simple","tags":"","loc":"proc/associate_matrix_simple.html","title":"associate_matrix_simple – openpde"},{"text":"private function add(lhs, rhs) result(opr) Add matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable,target Operator result. Calls proc~~add~7~~CallsGraph proc~add~7 add proc~associate_matrix_simple associate_matrix_simple proc~add~7->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code add Source Code function add ( lhs , rhs ) result ( opr ) !< Add matrix. class ( matrix_simple ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%add' ) allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%add' ) call opr_cur % init ( lhs % n ) opr_cur % val = lhs % val + rhs_cur % val end function add","tags":"","loc":"proc/add~7.html","title":"add – openpde"},{"text":"private function sub(lhs, rhs) result(opr) Subtract matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable,target Operator result. Calls proc~~sub~7~~CallsGraph proc~sub~7 sub proc~associate_matrix_simple associate_matrix_simple proc~sub~7->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub Source Code function sub ( lhs , rhs ) result ( opr ) !< Subtract matrix. class ( matrix_simple ), intent ( in ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%sub' ) allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%sub' ) call opr_cur % init ( lhs % n ) opr_cur % val = lhs % val - rhs_cur % val end function sub","tags":"","loc":"proc/sub~7.html","title":"sub – openpde"},{"text":"private function realmul(lhs, rhs) result(opr) Real matrix multiply. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix_simple ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable,target Operator result. Calls proc~~realmul~7~~CallsGraph proc~realmul~7 realmul proc~associate_matrix_simple associate_matrix_simple proc~realmul~7->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code realmul Source Code function realmul ( lhs , rhs ) result ( opr ) !< Real matrix multiply. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( matrix_simple ), intent ( in ) :: rhs !< Right hand side. class ( matrix ), allocatable , target :: opr !< Operator result. class ( matrix_simple ), pointer :: opr_cur !< Dummy pointer for result. allocate ( matrix_simple :: opr ) opr_cur => associate_matrix_simple ( matrix_input = opr , emsg = 'calling procedure matrix_simple%realmul' ) call opr_cur % init ( rhs % n ) opr_cur % val = lhs * rhs % val end function realmul","tags":"","loc":"proc/realmul~7.html","title":"realmul – openpde"},{"text":"private subroutine assign_matrix(lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Calls proc~~assign_matrix~~CallsGraph proc~assign_matrix assign_matrix proc~associate_matrix_simple associate_matrix_simple proc~assign_matrix->proc~associate_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code assign_matrix Source Code subroutine assign_matrix ( lhs , rhs ) !< Assignment overloading. class ( matrix_simple ), intent ( inout ) :: lhs !< Left hand side. class ( matrix ), intent ( in ), target :: rhs !< Right hand side. class ( matrix_simple ), pointer :: rhs_cur !< Dummy pointer for rhs. rhs_cur => associate_matrix_simple ( matrix_input = rhs , emsg = 'calling procedure matrix_simple%assign' ) lhs % n = rhs_cur % n lhs % val = rhs_cur % val end subroutine assign_matrix","tags":"","loc":"proc/assign_matrix.html","title":"assign_matrix – openpde"},{"text":"private subroutine init(this, n, description, error) Initialize matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Matrix size. character(len=*), intent(in), optional :: description Matrix description. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , n , description , error ) !< Initialize matrix class ( matrix_simple ), intent ( inout ) :: this !< The matrix. integer ( I_P ) :: n !< Matrix size. character ( * ), intent ( in ), optional :: description !< Matrix description. integer ( I_P ), intent ( out ), optional :: error !< Error status. this % n = n allocate ( this % val ( n , n )) !TODO maybe allocation and zeroification should be separed this % val (:,:) = 0._R_P end subroutine init","tags":"","loc":"proc/init~15.html","title":"init – openpde"},{"text":"private subroutine output(this, filename, error) Print matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , filename , error ) !< Print matrix class ( matrix_simple ), intent ( inout ) :: this !< The matrix. character ( * ), intent ( in ) :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: i !< Loop index i integer ( I_P ) :: j !< Loop index j open ( unit = 11 , file = filename ) do i = 1 , this % n do j = 1 , this % n write ( 11 , \"(G15.8)\" , advance = \"no\" ) this % val ( i , j ) enddo write ( 11 , * ) enddo close ( 11 ) end subroutine output","tags":"","loc":"proc/output~8.html","title":"output – openpde"},{"text":"private subroutine set(this, i, j, val) Set matrix value Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P), intent(in) :: i Index i where set matrix. integer(kind=I_P), intent(in) :: j Index i where set matrix. real(kind=R_P), intent(in) :: val Value to be inserted Source Code set Source Code subroutine set ( this , i , j , val ) !< Set matrix value class ( matrix_simple ), intent ( inout ) :: this !< The matrix. real ( R_P ), intent ( in ) :: val !< Value to be inserted integer ( I_P ), intent ( in ) :: i !< Index i where set matrix. integer ( I_P ), intent ( in ) :: j !< Index i where set matrix. this % val ( i , j ) = val end subroutine set","tags":"","loc":"proc/set~4.html","title":"set – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( equation ), intent ( inout ) :: this !< The equation. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~15.html","title":"free – openpde"},{"text":"public function associate_mesh_FD_2D(mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_2D ),\n  pointer Finite Difference 2D mesh pointer. Called By proc~~associate_mesh_fd_2d~~CalledByGraph proc~associate_mesh_fd_2d associate_mesh_FD_2D proc~operate~7 operate proc~operate~7->proc~associate_mesh_fd_2d proc~operate~5 operate proc~operate~5->proc~associate_mesh_fd_2d proc~operate operate proc~operate->proc~associate_mesh_fd_2d proc~operate~6 operate proc~operate~6->proc~associate_mesh_fd_2d proc~operate~13 operate proc~operate~13->proc~associate_mesh_fd_2d proc~associate_mesh associate_mesh proc~associate_mesh->proc~associate_mesh_fd_2d proc~init init proc~init->proc~associate_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh_FD_2D Source Code function associate_mesh_FD_2D ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_2D ), pointer :: mesh_pointer !< Finite Difference 2D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_2D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_2D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_2D","tags":"","loc":"proc/associate_mesh_fd_2d.html","title":"associate_mesh_FD_2D – openpde"},{"text":"private pure subroutine init(this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code pure subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description this % nx = 50 this % ny = 40 this % ngx = 2 this % ngy = 2 this % s = 1 this % hx = 0.05_R8P this % hy = 0.07_R8P if ( present ( error )) error = 0 end subroutine init","tags":"","loc":"proc/init~16.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_2D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"nx: \" , this % nx print * , \"ny: \" , this % ny print * , \"ngx: \" , this % ngx print * , \"ngy: \" , this % ngy print * , \"s: \" , this % s print * , \"hx: \" , this % hx print * , \"hy: \" , this % hy if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~9.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, nx, ny, ngx, ngy, s, hx, hy, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code pure subroutine set ( this , description , nx , ny , ngx , ngy , s , hx , hy , error ) !< Set mesh. class ( mesh_FD_2D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nx !< Number of X points. integer ( I_P ), intent ( in ), optional :: ny !< Number of Y points. integer ( I_P ), intent ( in ), optional :: ngx !< Number of X ghost points. integer ( I_P ), intent ( in ), optional :: ngy !< Number of Y ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: hx !< Cell X size. real ( R_P ), intent ( in ), optional :: hy !< Cell Y size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( nx )) this % nx = nx if ( present ( ny )) this % ny = ny if ( present ( ngx )) this % ngx = ngx if ( present ( ngy )) this % ngy = ngy if ( present ( s )) this % s = s if ( present ( hx )) this % hx = hx if ( present ( hy )) this % hy = hy if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~5.html","title":"set – openpde"},{"text":"private subroutine output(this, error) Output block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , error ) !< Output block. class ( mesh_block_FV_1D ), intent ( in ) :: this !< The block. integer ( I_P ), intent ( out ), optional :: error !< Error status. print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~10.html","title":"output – openpde"},{"text":"private pure subroutine set(this, n, ng, h, error) Set block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. integer(kind=I_P), intent(in), optional :: n Number of cells. integer(kind=I_P), intent(in), optional :: ng Number of ghost cells. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code pure subroutine set ( this , n , ng , h , error ) !< Set block. class ( mesh_block_FV_1D ), intent ( inout ) :: this !< The block. integer ( I_P ), intent ( in ), optional :: n !< Number of cells. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost cells. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~6.html","title":"set – openpde"},{"text":"private subroutine load_from_json(this, json, block_number, error) Load block definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. type(json_file), intent(inout) :: json JSON file handler. character(len=*), intent(in) :: block_number Block number ID, e.g. 'block5', 'block33'. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , json , block_number , error ) !< Load block definition from JSON file. class ( mesh_block_FV_1D ), intent ( inout ) :: this !< The block. type ( json_file ), intent ( inout ) :: json !< JSON file handler. character ( * ), intent ( in ) :: block_number !< Block number ID, e.g. 'block5', 'block33'. integer ( I_P ), intent ( out ), optional :: error !< Error status. logical :: found !< Flag inquiring the result json parsing. call json % get ( 'mesh.' // block_number // '.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // '.n\" missing' stop endif call json % get ( 'mesh.' // block_number // '.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // 'ng\" missing' stop endif call json % get ( 'mesh.' // block_number // '.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition incomplete!' write ( stderr , \"(A)\" ) '   \"mesh.' // block_number // 'h\" missing' stop endif if ( present ( error )) error = 0 endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~5.html","title":"load_from_json – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) end subroutine free","tags":"","loc":"proc/free~16.html","title":"free – openpde"},{"text":"private function associate_mesh_FD_1D_scalar(mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer Finite Difference 1D mesh pointer. Called By proc~~associate_mesh_fd_1d_scalar~~CalledByGraph proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d associate_mesh_FD_1D interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~operate~10 operate proc~operate~10->interface~associate_mesh_fd_1d proc~associate_mesh~2 associate_mesh proc~associate_mesh~2->interface~associate_mesh_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_mesh_fd_1d proc~init~3 init proc~init~3->interface~associate_mesh_fd_1d proc~init~14 init proc~init~14->interface~associate_mesh_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_mesh_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_mesh_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh_FD_1D_scalar Source Code function associate_mesh_FD_1D_scalar ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_1D ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_1D_scalar","tags":"","loc":"proc/associate_mesh_fd_1d_scalar.html","title":"associate_mesh_FD_1D_scalar – openpde"},{"text":"private function associate_mesh_FD_1D_rank1(mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input (:) Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer,(:) Finite Difference 1D mesh pointer. Called By proc~~associate_mesh_fd_1d_rank1~~CalledByGraph proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d associate_mesh_FD_1D interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 proc~operate~10 operate proc~operate~10->interface~associate_mesh_fd_1d proc~associate_mesh~2 associate_mesh proc~associate_mesh~2->interface~associate_mesh_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_mesh_fd_1d proc~init~3 init proc~init~3->interface~associate_mesh_fd_1d proc~init~14 init proc~init~14->interface~associate_mesh_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_mesh_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_mesh_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh_FD_1D_rank1 Source Code function associate_mesh_FD_1D_rank1 ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input (:) !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FD_1D ), pointer :: mesh_pointer (:) !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FD_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FD_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FD_1D_rank1","tags":"","loc":"proc/associate_mesh_fd_1d_rank1.html","title":"associate_mesh_FD_1D_rank1 – openpde"},{"text":"private subroutine init(this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % n = 128 this % ng = 2 this % s = 1 this % h = 1 2._R_P / 128 !0.05_R8P if ( present ( error )) error = 0 endif end subroutine init","tags":"","loc":"proc/init~17.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_FD_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( allocated ( this % description )) print \"(A)\" , this % description print * , \"n: \" , this % n print * , \"ng: \" , this % ng print * , \"s: \" , this % s print * , \"h: \" , this % h if ( present ( error )) error = 0 end subroutine output","tags":"","loc":"proc/output~11.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, n, ng, s, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code pure subroutine set ( this , description , n , ng , s , h , error ) !< Set mesh. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: n !< Number of points. integer ( I_P ), intent ( in ), optional :: ng !< Number of ghost points. integer ( I_P ), intent ( in ), optional :: s !< Number of replicas for steps/stages. real ( R_P ), intent ( in ), optional :: h !< Cell size. integer ( I_P ), intent ( out ), optional :: error !< Error status. if ( present ( description )) this % description = description if ( present ( n )) this % n = n if ( present ( ng )) this % ng = ng if ( present ( s )) this % s = s if ( present ( h )) this % h = h if ( present ( error )) error = 0 end subroutine set","tags":"","loc":"proc/set~7.html","title":"set – openpde"},{"text":"private elemental subroutine assign_mesh_FD_1D(lhs, rhs) Implementation of = operator. Note This implementation is not polymorphic: in future this must become a deferred procudere of the\n abstract mesh class, thus must become actually polymorphic (maybe a select type construct will be necessary). Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: lhs Left hand side. type( mesh_FD_1D ), intent(in) :: rhs Right hand side. Source Code assign_mesh_FD_1D Source Code elemental subroutine assign_mesh_FD_1D ( lhs , rhs ) !< Implementation of `=` operator. !< !< @note This implementation is not polymorphic: in future this must become a deferred procudere of the !< abstract [[mesh]] class, thus must become actually polymorphic (maybe a `select type` construct will be necessary). class ( mesh_FD_1D ), intent ( inout ) :: lhs !< Left hand side. type ( mesh_FD_1D ), intent ( in ) :: rhs !< Right hand side. lhs % n = rhs % n lhs % ng = rhs % ng lhs % s = rhs % s lhs % h = rhs % h end subroutine assign_mesh_FD_1D","tags":"","loc":"proc/assign_mesh_fd_1d.html","title":"assign_mesh_FD_1D – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FD_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite difference 1D\" ) then call json % get ( 'mesh.n' , this % n , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif call json % get ( 'mesh.ng' , this % ng , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"ng\" missing' stop endif call json % get ( 'mesh.h' , this % h , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"h\" missing' stop endif else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite difference 1D\"!' stop endif if ( present ( error )) error = 0 endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~6.html","title":"load_from_json – openpde"},{"text":"public interface associate_mesh_FD_1D Calls interface~~associate_mesh_fd_1d~~CallsGraph interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~associate_mesh_fd_1d_scalar associate_mesh_FD_1D_scalar interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_scalar proc~associate_mesh_fd_1d_rank1 associate_mesh_FD_1D_rank1 interface~associate_mesh_fd_1d->proc~associate_mesh_fd_1d_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~associate_mesh_fd_1d~~CalledByGraph interface~associate_mesh_fd_1d associate_mesh_FD_1D proc~operate~10 operate proc~operate~10->interface~associate_mesh_fd_1d proc~associate_mesh~2 associate_mesh proc~associate_mesh~2->interface~associate_mesh_fd_1d proc~operate~4 operate proc~operate~4->interface~associate_mesh_fd_1d proc~init~3 init proc~init~3->interface~associate_mesh_fd_1d proc~init~14 init proc~init~14->interface~associate_mesh_fd_1d proc~operate~12 operate proc~operate~12->interface~associate_mesh_fd_1d proc~operate~11 operate proc~operate~11->interface~associate_mesh_fd_1d proc~operate~3 operate proc~operate~3->interface~associate_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures associate_mesh_FD_1D_scalar associate_mesh_FD_1D_rank1 Module Procedures private function associate_mesh_FD_1D_scalar (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer Finite Difference 1D mesh pointer. private function associate_mesh_FD_1D_rank1 (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input (:) Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer, (:) Finite Difference 1D mesh pointer.","tags":"","loc":"interface/associate_mesh_fd_1d.html","title":"associate_mesh_FD_1D – openpde"},{"text":"public function associate_mesh_FV_1D(mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FV_1D ),\n  pointer Finite Difference 1D mesh pointer. Called By proc~~associate_mesh_fv_1d~~CalledByGraph proc~associate_mesh_fv_1d associate_mesh_FV_1D proc~output~4 output proc~output~4->proc~associate_mesh_fv_1d proc~associate_mesh~4 associate_mesh proc~associate_mesh~4->proc~associate_mesh_fv_1d proc~associate_mesh~3 associate_mesh proc~associate_mesh~3->proc~associate_mesh_fv_1d proc~compute_fluxes~2 compute_fluxes proc~compute_fluxes~2->proc~associate_mesh_fv_1d proc~init~4 init proc~init~4->proc~associate_mesh_fv_1d proc~init~6 init proc~init~6->proc~associate_mesh_fv_1d proc~operate~8 operate proc~operate~8->proc~associate_mesh_fv_1d proc~output~6 output proc~output~6->proc~associate_mesh_fv_1d proc~operate~9 operate proc~operate~9->proc~associate_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code associate_mesh_FV_1D Source Code function associate_mesh_FV_1D ( mesh_input , emsg ) result ( mesh_pointer ) !< Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. class ( mesh ), intent ( in ), target :: mesh_input !< Input mesh. character ( * ), intent ( in ), optional :: emsg !< Auxiliary error message. class ( mesh_FV_1D ), pointer :: mesh_pointer !< Finite Difference 1D mesh pointer. select type ( mesh_input ) type is ( mesh_FV_1D ) mesh_pointer => mesh_input class default write ( stderr , '(A)' ) 'error: cast mesh to mesh_FV_1D' if ( present ( emsg )) write ( stderr , '(A)' ) emsg stop end select end function associate_mesh_FV_1D","tags":"","loc":"proc/associate_mesh_fv_1d.html","title":"associate_mesh_FV_1D – openpde"},{"text":"private subroutine init(this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. Source Code init Source Code subroutine init ( this , description , filename , error ) !< Initialize mesh. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description. character ( * ), intent ( in ), optional :: filename !< Initialization file name. integer ( I_P ), intent ( out ), optional :: error !< Error status. call this % free if ( present ( description )) this % description = description if ( present ( filename )) then call this % load ( filename = filename , error = error ) else this % nb = 1 allocate ( this % blocks ( 1 )) call this % blocks ( 1 )% set ( n = 50 , ng = 2 , h = 0.05_R_P , error = error ) endif call this % output ( error = error ) end subroutine init","tags":"","loc":"proc/init~18.html","title":"init – openpde"},{"text":"private subroutine output(this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Source Code output Source Code subroutine output ( this , error ) !< Output mesh. class ( mesh_FV_1D ), intent ( in ) :: this !< The mesh. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: b !< Counter. if ( allocated ( this % description )) print \"(A)\" , this % description if ( allocated ( this % blocks )) then print * , 'nb: ' , this % nb do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) print * , 'block ' , b call this % blocks ( b )% output ( error = error ) end do end if end subroutine output","tags":"","loc":"proc/output~12.html","title":"output – openpde"},{"text":"private pure subroutine set(this, description, nb, n, ng, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nb Number of blocks. integer(kind=I_P), intent(in), optional :: n (1:) Number of points for each block. integer(kind=I_P), intent(in), optional :: ng (1:) Number of ghost points for each block. real(kind=R_P), intent(in), optional :: h (1:) Cell size for each block. integer(kind=I_P), intent(out), optional :: error Error status. Source Code set Source Code pure subroutine set ( this , description , nb , n , ng , h , error ) !< Set mesh. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ), optional :: description !< Mesh description integer ( I_P ), intent ( in ), optional :: nb !< Number of blocks. integer ( I_P ), intent ( in ), optional :: n ( 1 :) !< Number of points for each block. integer ( I_P ), intent ( in ), optional :: ng ( 1 :) !< Number of ghost points for each block. real ( R_P ), intent ( in ), optional :: h ( 1 :) !< Cell size for each block. integer ( I_P ), intent ( out ), optional :: error !< Error status. integer ( I_P ) :: b !< Counter. if ( present ( description )) this % description = description if ( present ( nb )) then this % nb = nb if ( allocated ( this % blocks )) then if ( nb /= size ( this % blocks , dim = 1 )) then deallocate ( this % blocks ) allocate ( this % blocks ( 1 : nb )) endif endif endif if ( allocated ( this % blocks )) then do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) call this % blocks ( b )% set ( n = n ( b ), ng = ng ( b ), h = h ( b ), error = error ) end do end if end subroutine set","tags":"","loc":"proc/set~8.html","title":"set – openpde"},{"text":"private subroutine load_from_json(this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. Source Code load_from_json Source Code subroutine load_from_json ( this , filename , error ) !< Load mesh definition from JSON file. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. character ( * ), intent ( in ) :: filename !< File name of JSON file. integer ( I_P ), intent ( out ), optional :: error !< Error status. character ( len = :), allocatable :: mesh_type !< Mesh type. type ( string ) :: block_number !< Block number ID, e.g. 'block5', 'block33'. type ( json_file ) :: json !< JSON file handler. logical :: found !< Flag inquiring the result json parsing. integer ( I_P ) :: b !< Counter. call json % initialize () if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % load_file ( filename = filename ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if call json % get ( 'mesh.type' , mesh_type , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"type\" missing' stop endif if ( mesh_type == \"finite volume 1D\" ) then call json % get ( 'mesh.nb' , this % nb , found ) if ( json % failed ()) then call json % print_error_message ( stderr ) ; stop end if if (. not . found ) then write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" incomplete!' write ( stderr , \"(A)\" ) '   \"n\" missing' stop endif if ( allocated ( this % blocks )) deallocate ( this % blocks ) ; allocate ( this % blocks ( 1 : this % nb )) do b = lbound ( this % blocks , dim = 1 ), ubound ( this % blocks , dim = 1 ) block_number = b block_number = block_number % replace ( old = '+' , new = '' ) call this % blocks ( b )% load ( json = json , block_number = 'block' // block_number , error = error ) end do else write ( stderr , \"(A)\" ) ' error: mesh definition of \"' // filename // '\" is not \"finite volume 1D\"!' stop endif endsubroutine load_from_json","tags":"","loc":"proc/load_from_json~7.html","title":"load_from_json – openpde"},{"text":"private elemental subroutine free(this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. Source Code free Source Code elemental subroutine free ( this ) !< Free dynamic memory. class ( mesh_FV_1D ), intent ( inout ) :: this !< The mesh. if ( allocated ( this % description )) deallocate ( this % description ) if ( allocated ( this % blocks )) deallocate ( this % blocks ) end subroutine free","tags":"","loc":"proc/free~17.html","title":"free – openpde"},{"text":"Definition of reals and integer kind parameters of openpde library. Used By module~~openpde_kinds~~UsedByGraph module~openpde_kinds openpde_kinds module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_kinds->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_kinds->module~openpde_field_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_kinds->module~openpde_integrator_adv_rk_implicit module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_equation_abstract openpde_equation_abstract module~openpde_kinds->module~openpde_equation_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_kinds->module~openpde_integrator_adv_euler_explicit module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_kinds->module~openpde_v2f_fd_2d module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_kinds->module~openpde_linsolver_gmlapack module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_kinds->module~openpde_multigrid_fd_1d module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde openpde module~openpde_kinds->module~openpde module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_kinds->module~openpde_field_surface_abstract module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_kinds->module~openpde_f2m_d1_fd_1d module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds->module~openpde_f2m_abstract module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_kinds->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_kinds->module~openpde_f2v_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_kinds->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_kinds->module~openpde_field_fv_1d module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_kinds->module~openpde_f2m_d2_fd_2d module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_kinds->module~openpde_field_surface_fv_1d module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_kinds->module~openpde_f2v_fd_1d module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_kinds->module~openpde_spatial_operator_d2_fv_1d module~openpde_matrix_simple openpde_matrix_simple module~openpde_kinds->module~openpde_matrix_simple module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_vector_simple openpde_vector_simple module~openpde_kinds->module~openpde_vector_simple module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_kinds->module~openpde_field_surface_block_fv_1d module~openpde_equation_adv openpde_equation_adv module~openpde_kinds->module~openpde_equation_adv module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_kinds->module~openpde_v2f_fd_1d module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_2d->module~openpde_v2f_fd_2d module~openpde_mesh_fd_2d->module~openpde module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_mesh_fd_2d->module~openpde_f2v_fd_2d module~openpde_mesh_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_v2f_abstract->module~openpde module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_field_surface_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_linsolver_gmlapack->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde module~openpde_multigrid_fd_1d->module~openpde module~openpde_f2v_abstract->module~openpde module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_matrix_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_matrix_abstract->module~openpde_linsolver_gmlapack module~openpde_matrix_abstract->module~openpde module~openpde_matrix_abstract->module~openpde_f2m_d1_fd_1d module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_1d module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_2d module~openpde_matrix_abstract->module~openpde_matrix_simple module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_abstract module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde_mesh_fv_1d->module~openpde module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_surface_abstract->module~openpde module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_f2m_abstract->module~openpde module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_f2v_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_fd_1d->module~openpde_v2f_fd_1d proc~integrate~2 integrate module~openpde_field_fd_1d->proc~integrate~2 module~openpde_field_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_v2f_fd_2d module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_multigrid_fd_1d module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_f2m_d1_fd_1d module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_f2v_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_f2m_d2_fd_2d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_field_surface_fv_1d module~openpde_field_abstract->module~openpde_f2v_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_v2f_fd_1d module~openpde_field_fv_1d->module~openpde module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_vector_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_vector_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_v2f_fd_2d module~openpde_vector_abstract->module~openpde_linsolver_gmlapack module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde module~openpde_vector_abstract->module~openpde_f2v_fd_2d module~openpde_vector_abstract->module~openpde_f2v_fd_1d module~openpde_vector_abstract->module~openpde_vector_simple module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_v2f_fd_1d module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde module~openpde_field_surface_fv_1d->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_matrix_simple->module~openpde_linsolver_gmlapack module~openpde_matrix_simple->module~openpde module~openpde_mesh_fd_1d->module~openpde_multigrid_fd_1d module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2v_fd_1d module~openpde_mesh_fd_1d->module~openpde_v2f_fd_1d module~openpde_vector_simple->module~openpde_linsolver_gmlapack module~openpde_vector_simple->module~openpde module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_linsolver_abstract->module~openpde module~openpde_linsolver_abstract->module~openpde_equation_adv module~openpde_v2f_fd_1d->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d var panmoduleopenpde_kindsUsedByGraph = svgPanZoom('#moduleopenpde_kindsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables R8P R4P R_P I8P I4P I2P I1P I_P Variables Type Visibility Attributes Name Initial integer, public, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision.","tags":"","loc":"module/openpde_kinds.html","title":"openpde_kinds – openpde"},{"text":"Uses: openpde_equation_abstract openpde_field_abstract openpde_field_surface_abstract openpde_integrator_abstract openpde_integrator_adv_abstract openpde_mesh_abstract openpde_spatial_operator_abstract openpde_spatial_operator_d1_abstract openpde_spatial_operator_d2_abstract openpde_vector_abstract openpde_matrix_abstract openpde_f2v_abstract openpde_v2f_abstract openpde_f2m_abstract openpde_f2m_d1_abstract openpde_f2m_d2_abstract openpde_linsolver_abstract openpde_equation_adv openpde_field_FD_1D openpde_field_FD_2D openpde_field_FV_1D openpde_field_surface_FV_1D openpde_integrator_euler_explicit openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_implicit openpde_integrator_adv_rk_implicit openpde_mesh_FD_1D openpde_mesh_FD_2D openpde_mesh_FV_1D openpde_spatial_operator_d1_FD_1D openpde_spatial_operator_d1_FD_2D openpde_spatial_operator_d1_FV_1D openpde_spatial_operator_d2_FD_1D openpde_spatial_operator_d2_FD_2D openpde_spatial_operator_d2_FV_1D openpde_vector_simple openpde_matrix_simple openpde_f2v_FD_1D openpde_v2f_FD_1D openpde_f2v_FD_2D openpde_v2f_FD_2D openpde_f2m_d1_FD_1D openpde_f2m_d2_FD_1D openpde_f2m_d2_FD_2D openpde_linsolver_gmlapack openpde_multigrid_FD_1D openpde_kinds module~~openpde~~UsesGraph module~openpde openpde module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_f2v_abstract->module~openpde module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_equation_adv openpde_equation_adv module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_mesh_fd_2d->module~openpde_v2f_fd_2d module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_mesh_fd_2d->module~openpde_f2v_fd_2d module~openpde_mesh_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_integrator_euler_explicit->module~openpde module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_mesh_abstract->module~openpde_field_surface_fv_1d module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde module~openpde_kinds->module~openpde_f2v_abstract module~openpde_kinds->module~openpde_integrator_adv_euler_implicit module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_kinds->module~openpde_integrator_adv_rk_implicit module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_spatial_operator_d1_fv_1d module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_integrator_adv_euler_explicit module~openpde_kinds->module~openpde_v2f_fd_2d module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_kinds->module~openpde_linsolver_gmlapack module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_kinds->module~openpde_field_surface_abstract module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_kinds->module~openpde_multigrid_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_kinds->module~openpde_field_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds->module~openpde_f2m_abstract module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_f2v_fd_2d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_kinds->module~openpde_f2m_d2_fd_1d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_kinds->module~openpde_f2m_d2_fd_2d module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_field_surface_fv_1d module~openpde_kinds->module~openpde_f2v_fd_1d module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_kinds->module~openpde_spatial_operator_d2_fv_1d module~openpde_matrix_simple openpde_matrix_simple module~openpde_kinds->module~openpde_matrix_simple module~openpde_vector_simple openpde_vector_simple module~openpde_kinds->module~openpde_vector_simple module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_kinds->module~openpde_f2m_d1_fd_1d module~openpde_kinds->module~openpde_equation_adv module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_kinds->module~openpde_v2f_fd_1d module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_kinds->module~openpde_field_surface_block_fv_1d module~openpde_linsolver_gmlapack->module~openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_field_surface_abstract->module~openpde module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde_multigrid_fd_1d->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_matrix_abstract->module~openpde module~openpde_matrix_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_matrix_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_matrix_abstract->module~openpde_linsolver_gmlapack module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_1d module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_2d module~openpde_matrix_abstract->module~openpde_matrix_simple module~openpde_matrix_abstract->module~openpde_f2m_d1_fd_1d module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_multigrid_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2v_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_v2f_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_field_fv_1d->module~openpde module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_mesh_fv_1d->module~openpde module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_f2m_abstract->module~openpde module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_f2v_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_field_fd_1d->module~openpde_v2f_fd_1d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_v2f_fd_2d module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_multigrid_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_f2v_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_field_abstract->module~openpde_f2m_d2_fd_2d module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_field_surface_fv_1d module~openpde_field_abstract->module~openpde_f2v_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_abstract->module~openpde_f2m_d1_fd_1d module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_v2f_fd_1d module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_v2f_abstract->module~openpde module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_vector_abstract->module~openpde module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_vector_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_vector_abstract->module~openpde_v2f_fd_2d module~openpde_vector_abstract->module~openpde_linsolver_gmlapack module~openpde_vector_abstract->module~openpde_f2v_fd_2d module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_f2v_fd_1d module~openpde_vector_abstract->module~openpde_vector_simple module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_v2f_fd_1d module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_field_surface_fv_1d->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_matrix_simple->module~openpde module~openpde_matrix_simple->module~openpde_linsolver_gmlapack module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_vector_simple->module~openpde module~openpde_vector_simple->module~openpde_linsolver_gmlapack module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_equation_adv->module~openpde module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_linsolver_abstract->module~openpde module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_linsolver_abstract->module~openpde_equation_adv module~openpde_v2f_fd_1d->module~openpde iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_adv_euler_implicit iso_fortran_env->module~openpde_field_fd_2d iso_fortran_env->module~openpde_integrator_adv_rk_implicit iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_integrator_euler_explicit iso_fortran_env->module~openpde_integrator_adv_euler_explicit iso_fortran_env->module~openpde_linsolver_gmlapack iso_fortran_env->module~openpde_field_surface_abstract iso_fortran_env->module~openpde_mesh_fd_1d iso_fortran_env->module~openpde_field_fv_1d iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_field_surface_fv_1d iso_fortran_env->module~openpde_matrix_simple iso_fortran_env->module~openpde_vector_simple iso_fortran_env->module~openpde_field_block_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_field_surface_block_fv_1d json_module json_module json_module->module~openpde_integrator_adv_euler_implicit json_module->module~openpde_integrator_adv_rk_implicit json_module->module~openpde_integrator_euler_explicit json_module->module~openpde_integrator_adv_euler_explicit json_module->module~openpde_mesh_fd_1d json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d vtk_fortran->module~openpde_mesh_fd_1d vtk_fortran->module~openpde_mesh_fv_1d module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_block_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d var panmoduleopenpdeUsesGraph = svgPanZoom('#moduleopenpdeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Open Fortran Library for PDE solving.","tags":"","loc":"module/openpde.html","title":"openpde – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_mesh_abstract openpde_kinds openpde_mesh_FD_2D module~~openpde_field_fd_2d~~UsesGraph module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_2d iso_fortran_env->module~openpde_mesh_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field for Finite Difference 2D methods. Used By module~~openpde_field_fd_2d~~UsedByGraph module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde openpde module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_v2f_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_f2v_fd_2d->module~openpde module~openpde_f2m_d2_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_FD_2D Functions associate_field_FD_2D add mul mulreal realmul sub div Subroutines associate_mesh init output assign_field set free Derived Types type, public, extends( field ) :: field_FD_2D Concrete class of field for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. real(kind=R_P), public, allocatable, dimension(:,:) :: val Field value. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field data. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, private, pass(lhs) :: div Subtract fields. procedure, public, pass(this) :: set Set field. Functions public function associate_field_FD_2D (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 2D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_2D ),\n  pointer Finite Difference 2D field pointer. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_2D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Subroutines private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine init (this, field_mesh, description, error) Initialize finite difference 2D field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. private subroutine set (this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:,1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FD_2D ), intent(inout) :: this The field.","tags":"","loc":"module/openpde_field_fd_2d.html","title":"openpde_field_FD_2D – openpde"},{"text":"Uses: openpde_mesh_abstract openpde_kinds module~~openpde_field_abstract~~UsesGraph module~openpde_field_abstract openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_mesh_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of field. Used By module~~openpde_field_abstract~~UsedByGraph module~openpde_field_abstract openpde_field_abstract module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_field_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_field_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_field_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_field_abstract->module~openpde_v2f_fd_2d module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_field_abstract->module~openpde_multigrid_fd_1d module~openpde_equation_adv openpde_equation_adv module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_field_abstract->module~openpde_f2v_fd_1d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_field_abstract->module~openpde_f2v_fd_2d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_field_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_field_abstract->module~openpde_f2m_d2_fd_2d module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_field_abstract->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_abstract->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_field_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_field_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_field_abstract->module~openpde_v2f_fd_1d module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_equation_abstract->module~openpde module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde module~openpde_multigrid_fd_1d->module~openpde module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde_field_surface_abstract->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_fv_1d->module~openpde module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_f2m_abstract->module~openpde module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_f2v_fd_2d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_field_fd_1d->module~openpde_v2f_fd_1d proc~integrate~2 integrate module~openpde_field_fd_1d->proc~integrate~2 module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde module~openpde_field_surface_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_abstract->module~openpde module~openpde_v2f_fd_1d->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d var panmoduleopenpde_field_abstractUsedByGraph = svgPanZoom('#moduleopenpde_field_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_associate_mesh abstract_init abstract_output abstract_simmetric_operator abstract_field_op_real abstract_real_op_field abstract_assign Derived Types field Subroutines free Abstract Interfaces abstract interface Associate a mesh to field. private subroutine abstract_associate_mesh (this, field_mesh, error) Associate a mesh to field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Initialize the field. private subroutine abstract_init (this, field_mesh, description, error) Initialize the field. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh The mesh. character(len=*), intent(in), optional :: description Description of the field. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Output the field. private subroutine abstract_output (this, filename, error) Output the field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output fiel name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Symmetric operator field.op.field. private function abstract_simmetric_operator (lhs, rhs) result(opr) Symmetric operator field.op.field. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. abstract interface Non symmetric operator field.op.real. private function abstract_field_op_real (lhs, rhs) result(opr) Non symmetric operator field.op.real. Arguments Type Intent Optional Attributes Name class( field ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. abstract interface Non symmetric operator real.op.field. private function abstract_real_op_field (lhs, rhs) result(opr) Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable Operator result. abstract interface Assignment overloading. private subroutine abstract_assign (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. Derived Types type, public, abstract :: field Abstract class of field. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure(abstract_associate_mesh), public, pass(this) :: associate_mesh Associate mesh. procedure(abstract_init), public, pass(this) :: init Initilize field. procedure(abstract_output), public, pass(this) :: output Output field data. procedure(abstract_simmetric_operator), private, pass(lhs) :: add Add fields. procedure(abstract_assign), private, pass(lhs) :: assign_field Assign fields. procedure(abstract_simmetric_operator), private, pass(lhs) :: mul Multiply fields. procedure(abstract_field_op_real), private, pass(lhs) :: mulreal Multiply field for real. procedure(abstract_real_op_field), private, pass(rhs) :: realmul Multiply real for field. procedure(abstract_simmetric_operator), private, pass(lhs) :: sub Subtract fields. procedure(abstract_simmetric_operator), private, pass(lhs) :: div Divide fields. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field ), intent(inout) :: this The field.","tags":"","loc":"module/openpde_field_abstract.html","title":"openpde_field_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_kinds openpde_field_block_FV_1D openpde_mesh_FV_1D openpde_mesh_block_FV_1D module~~openpde_field_surface_block_fv_1d~~UsesGraph module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_surface_block_fv_1d iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_field_block_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_surface_block_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fv_1d var panmoduleopenpde_field_surface_block_fv_1dUsesGraph = svgPanZoom('#moduleopenpde_field_surface_block_fv_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field surface block for Finite Volume 1D methods. Used By module~~openpde_field_surface_block_fv_1d~~UsedByGraph module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_surface_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_surface_block_FV_1D Functions add mul mulreal realmul sub div Subroutines alloc compute_fluxes free init output assign_block Derived Types type, public :: field_surface_block_FV_1D Concrete class of field surface block for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Block value. Type-Bound Procedures procedure, public, pass(this) :: alloc Allocate block. procedure, public, pass(this) :: compute_fluxes Compute fluxes of field through surfaces. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize block. procedure, public, pass(this) :: output Output block data. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator / overloading. generic, public :: assignment(=) => assign_block Assignment overloading. procedure, private, pass(lhs) :: add Add blocks. procedure, private, pass(lhs) :: assign_block Assign blocks. procedure, private, pass(lhs) :: mul Multiply blocks. procedure, private, pass(lhs) :: mulreal Multiply block for real. procedure, private, pass(rhs) :: realmul Multiply real for block. procedure, private, pass(lhs) :: sub Divide blocks. procedure, private, pass(lhs) :: div Divide blocks. Functions private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_surface_block_FV_1D ) Operator result. Subroutines private subroutine alloc (this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine compute_fluxes (this, field_cell, mesh_block, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(field_block_FV_1D), intent(in) :: field_cell Field at cells center. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The field. private subroutine init (this, mesh_block, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_surface_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_surface_block_FV_1D ), intent(in) :: rhs Left hand side.","tags":"","loc":"module/openpde_field_surface_block_fv_1d.html","title":"openpde_field_surface_block_FV_1D – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_kinds openpde_mesh_abstract openpde_mesh_FD_1D module~~openpde_field_fd_1d~~UsesGraph module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fd_1d module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field for Finite Difference 1D methods. Used By module~~openpde_field_fd_1d~~UsedByGraph module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde openpde module~openpde_field_fd_1d->module~openpde module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_field_fd_1d->module~openpde_v2f_fd_1d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d proc~integrate~2 integrate module~openpde_field_fd_1d->proc~integrate~2 module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_v2f_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_f2v_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces associate_field_FD_1D Derived Types field_FD_1D Functions associate_field_FD_1D_scalar associate_field_FD_1D_rank1 associate_field_FD_1D_rank2 add mul mulreal realmul newrealmul sub div Subroutines associate_mesh init output assign_field set free Interfaces public interface associate_field_FD_1D private function associate_field_FD_1D_scalar (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer Finite Difference 1D field pointer. private function associate_field_FD_1D_rank1 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:) Finite Difference 1D field pointer. private function associate_field_FD_1D_rank2 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:,:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:,:) Finite Difference 1D field pointer. Derived Types type, public, extends( field ) :: field_FD_1D Concrete class of field for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. real(kind=R_P), public, allocatable, dimension(:) :: val Field value. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field data. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, private, pass(lhs) :: div Subtract fields. procedure, public, pass(this) :: set Set field. Functions private function associate_field_FD_1D_scalar (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer Finite Difference 1D field pointer. private function associate_field_FD_1D_rank1 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:) Finite Difference 1D field pointer. private function associate_field_FD_1D_rank2 (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input (:,:) Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FD_1D ),\n  pointer, (:,:) Finite Difference 1D field pointer. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function newrealmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FD_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Subroutines private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine init (this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. private subroutine set (this, field_mesh, description, val, error) Set field. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field. class( mesh ), intent(in), optional target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description real(kind=R_P), intent(in), optional :: val (1:) Field value. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FD_1D ), intent(inout) :: this The field.","tags":"","loc":"module/openpde_field_fd_1d.html","title":"openpde_field_FD_1D – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_kinds module~~openpde_field_surface_abstract~~UsesGraph module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_surface_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of field surface. Used By module~~openpde_field_surface_abstract~~UsedByGraph module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_surface_abstract->module~openpde module~openpde_field_surface_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_compute_fluxes Derived Types field_surface Abstract Interfaces abstract interface Compute fluxes of field through surfaces. private subroutine abstract_compute_fluxes (this, field_cell, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. Derived Types type, public, abstract, extends( field ) :: field_surface Abstract class of field surface. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. Type-Bound Procedures procedure(abstract_associate_mesh), public, pass(this) :: associate_mesh Associate mesh. procedure(abstract_init), public, pass(this) :: init Initilize field. procedure(abstract_output), public, pass(this) :: output Output field data. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure(abstract_compute_fluxes), public, pass(this) :: compute_fluxes Compute fluxes of field through surfaces.","tags":"","loc":"module/openpde_field_surface_abstract.html","title":"openpde_field_surface_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_field_FV_1D openpde_field_surface_abstract openpde_field_surface_block_FV_1D openpde_kinds openpde_mesh_abstract openpde_mesh_FV_1D openpde_mesh_block_FV_1D module~~openpde_field_surface_fv_1d~~UsesGraph module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_kinds->module~openpde_field_surface_abstract module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_kinds->module~openpde_field_surface_block_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_kinds->module~openpde_field_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_abstract->module~openpde_field_surface_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_field_abstract->module~openpde_field_surface_fv_1d module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_field_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_surface_fv_1d iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_field_surface_abstract iso_fortran_env->module~openpde_field_surface_block_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_field_fv_1d iso_fortran_env->module~openpde_field_block_fv_1d json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_fv_1d var panmoduleopenpde_field_surface_fv_1dUsesGraph = svgPanZoom('#moduleopenpde_field_surface_fv_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field surface for Finite Volume 1D methods. This field is associated to a meh based on a uniform, Cartesian cell-centered discretization of the domain,\n that is a multiblock mesh. Used By module~~openpde_field_surface_fv_1d~~UsedByGraph module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde openpde module~openpde_field_surface_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_surface_FV_1D Functions associate_field_surface_FV_1D add mul mulreal realmul sub div Subroutines associate_mesh init output compute_fluxes assign_field free Derived Types type, public, extends( field_surface ) :: field_surface_FV_1D Concrete class of field surface for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. integer(kind=I_P), public :: nb Number of blocks. type(field_surface_block_FV_1D), public, allocatable, dimension(:) :: blocks The blocks. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field. procedure, public, pass(this) :: compute_fluxes Compute fluxes of field through surfaces. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, private, pass(lhs) :: div Subtract fields. Functions public function associate_field_surface_FV_1D (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Volume 1D field surface pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_surface_FV_1D ),\n  pointer Concrete field pointer. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_surface_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Subroutines private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine init (this, field_mesh, description, error) Initialize field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Output field. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine compute_fluxes (this, field_cell, error) Compute fluxes of field through surfaces. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this Fluxex. class( field ), intent(in) :: field_cell Field at cells center. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_surface_FV_1D ), intent(inout) :: this The field.","tags":"","loc":"module/openpde_field_surface_fv_1d.html","title":"openpde_field_surface_FV_1D – openpde"},{"text":"Uses: iso_fortran_env openpde_kinds openpde_mesh_FV_1D openpde_mesh_block_FV_1D module~~openpde_field_block_fv_1d~~UsesGraph module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_block_fv_1d iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field block for Finite Volume 1D methods. Used By module~~openpde_field_block_fv_1d~~UsedByGraph module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_surface_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde var panmoduleopenpde_field_block_fv_1dUsedByGraph = svgPanZoom('#moduleopenpde_field_block_fv_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_block_FV_1D Functions add mul mulreal realmul sub div Subroutines alloc free init output assign_block Derived Types type, public :: field_block_FV_1D Concrete class of field block for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable, dimension(:) :: val Block value. Type-Bound Procedures procedure, public, pass(this) :: alloc Allocate block. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize block. procedure, public, pass(this) :: output Output block data. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_block Assignment overloading. procedure, private, pass(lhs) :: add Add blocks. procedure, private, pass(lhs) :: assign_block Assign blocks. procedure, private, pass(lhs) :: mul Multiply blocks. procedure, private, pass(lhs) :: mulreal Multiply block for real. procedure, private, pass(rhs) :: realmul Multiply real for block. procedure, private, pass(lhs) :: sub Subtract blocks. procedure, private, pass(lhs) :: div Subtract blocks. Functions private elemental function add (lhs, rhs) result(opr) Add blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function mul (lhs, rhs) result(opr) Multiply blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_block_FV_1D ), intent(in) :: rhs Right hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function sub (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. private elemental function div (lhs, rhs) result(opr) Subtract blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side. Return Value type( field_block_FV_1D ) Operator result. Subroutines private subroutine alloc (this, mesh_block, error) Allocate block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The field. private subroutine init (this, mesh_field, b, error) Initialize block. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: this The block. type(mesh_FV_1D), intent(in) :: mesh_field Mesh of the whole field. integer(kind=I_P), intent(in) :: b Block index. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, unit, mesh_block, error) Output block data. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(in) :: unit Unit file. type(mesh_block_FV_1D), intent(in) :: mesh_block Mesh of the block. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine assign_block (lhs, rhs) Assign blocks. Arguments Type Intent Optional Attributes Name class( field_block_FV_1D ), intent(inout) :: lhs Left hand side. type( field_block_FV_1D ), intent(in) :: rhs Left hand side.","tags":"","loc":"module/openpde_field_block_fv_1d.html","title":"openpde_field_block_FV_1D – openpde"},{"text":"Uses: iso_fortran_env openpde_field_abstract openpde_field_block_FV_1D openpde_kinds openpde_mesh_abstract openpde_mesh_FV_1D openpde_mesh_block_FV_1D module~~openpde_field_fv_1d~~UsesGraph module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_field_abstract openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fv_1d iso_fortran_env->module~openpde_field_block_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_mesh_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_field_fv_1d module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d json_module json_module json_module->module~openpde_mesh_block_fv_1d json_module->module~openpde_mesh_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d var panmoduleopenpde_field_fv_1dUsesGraph = svgPanZoom('#moduleopenpde_field_fv_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field for Finite Volume 1D methods. This field is associated to a meh based on a uniform, Cartesian cell-centered discretization of the domain,\n that is a multiblock mesh. Used By module~~openpde_field_fv_1d~~UsedByGraph module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_surface_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_FV_1D Functions associate_field_FV_1D add mul mulreal realmul sub div Subroutines associate_mesh init output assign_field free Derived Types type, public, extends( field ) :: field_FV_1D Concrete class of field for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Field description. class( mesh ), public, pointer :: m => null() Pointer to the mesh of the field. integer(kind=I_P), public :: nb Number of blocks. type(field_block_FV_1D), public, allocatable, dimension(:) :: blocks The blocks. Type-Bound Procedures generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(*) => mul, realmul, mulreal Operator * overloading. generic, public :: operator(-) => sub Operator - overloading. generic, public :: operator(/) => div Operator - overloading. generic, public :: assignment(=) => assign_field Assignment overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: associate_mesh Associate field to a mesh. procedure, public, pass(this) :: init Initilize field. procedure, public, pass(this) :: output Output field data. procedure, private, pass(lhs) :: add Add fields. procedure, private, pass(lhs) :: assign_field Assign fields. procedure, private, pass(lhs) :: mul Multiply fields. procedure, private, pass(lhs) :: mulreal Multiply field for real. procedure, private, pass(rhs) :: realmul Multiply real for field. procedure, private, pass(lhs) :: sub Subtract fields. procedure, private, pass(lhs) :: div Subtract fields. Functions public function associate_field_FV_1D (field_input, emsg) result(field_pointer) Check the type of the field passed as input and return a Finite Difference 1D field pointer associated to field. Arguments Type Intent Optional Attributes Name class( field ), intent(in), target :: field_input Input field. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( field_FV_1D ),\n  pointer Finite Difference 1D field pointer. private function add (lhs, rhs) result(opr) Add fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mul (lhs, rhs) result(opr) Multiply fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function mulreal (lhs, rhs) result(opr) Multiply field for real. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Multiply real for field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( field_FV_1D ), intent(in) :: rhs Right hand side. Return Value class( field ),\n  allocatable, target Operator result. private function sub (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. private function div (lhs, rhs) result(opr) Subtract fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: lhs Left hand side. class( field ), intent(in), target :: rhs Left hand side. Return Value class( field ),\n  allocatable, target Operator result. Subroutines private subroutine associate_mesh (this, field_mesh, error) Associate field to a mesh. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine init (this, field_mesh, description, error) Initialize finite difference 1D field. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field. class( mesh ), intent(in), target :: field_mesh Mesh of the field. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Output field data. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(in) :: this The field. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine assign_field (lhs, rhs) Assign fields. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: lhs Left hand side. class( field ), intent(in), target :: rhs Right hand side. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( field_FV_1D ), intent(inout) :: this The field.","tags":"","loc":"module/openpde_field_fv_1d.html","title":"openpde_field_FV_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_v2f_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D openpde_vector_abstract module~~openpde_v2f_fd_2d~~UsesGraph module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_v2f_fd_2d module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_kinds->module~openpde_field_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_fd_2d->module~openpde_v2f_fd_2d module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_v2f_fd_2d module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_vector_abstract->module~openpde_v2f_fd_2d module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_field_fd_2d->module~openpde_v2f_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d var panmoduleopenpde_v2f_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_v2f_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of v2f (vector to field) for FD 1D Used By module~~openpde_v2f_fd_2d~~UsedByGraph module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde openpde module~openpde_v2f_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types v2f_FD_2D Subroutines operate Derived Types type, public, extends( v2f ) :: v2f_FD_2D Concrete class of v2f (vector to field) for FD 1D Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure, public :: operate Operator operation. Subroutines private subroutine operate (this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_2D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field.","tags":"","loc":"module/openpde_v2f_fd_2d.html","title":"openpde_v2f_FD_2D – openpde"},{"text":"Uses: openpde_field_abstract openpde_v2f_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D openpde_vector_abstract module~~openpde_v2f_fd_1d~~UsesGraph module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_v2f_fd_1d module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_vector_abstract->module~openpde_v2f_fd_1d module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_field_fd_1d->module~openpde_v2f_fd_1d module~openpde_field_abstract->module~openpde_v2f_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_mesh_fd_1d->module~openpde_v2f_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d var panmoduleopenpde_v2f_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_v2f_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of v2f (vector to field) for FD 1D Used By module~~openpde_v2f_fd_1d~~UsedByGraph module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde openpde module~openpde_v2f_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types v2f_FD_1D Subroutines operate Derived Types type, public, extends( v2f ) :: v2f_FD_1D Concrete class of v2f (vector to field) for FD 1D Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure, public :: operate Operator operation. Subroutines private subroutine operate (this, vec, fie) Operator operation. Arguments Type Intent Optional Attributes Name class( v2f_FD_1D ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Returned field.","tags":"","loc":"module/openpde_v2f_fd_1d.html","title":"openpde_v2f_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_mesh_abstract openpde_vector_abstract openpde_kinds module~~openpde_v2f_abstract~~UsesGraph module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_v2f_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of v2f (vector to field). Used By module~~openpde_v2f_abstract~~UsedByGraph module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_equation_adv openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde openpde module~openpde_v2f_abstract->module~openpde module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_v2f_fd_2d->module~openpde module~openpde_v2f_fd_1d->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit var panmoduleopenpde_v2f_abstractUsedByGraph = svgPanZoom('#moduleopenpde_v2f_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_operate Derived Types v2f Abstract Interfaces abstract interface Operator operation. private subroutine abstract_operate (this, vec, fie) Operator function. Arguments Type Intent Optional Attributes Name class( v2f ), intent(in) :: this The operator. class( vector ), intent(in) :: vec Input vector. class( field ), intent(inout), dimension(:) :: fie Resulting field. Derived Types type, public, abstract :: v2f Abstract class of v2f. Components Type Visibility Attributes Name Initial class( mesh ), public, pointer :: mesh integer(kind=I_P), public :: n_equ Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function.","tags":"","loc":"module/openpde_v2f_abstract.html","title":"openpde_v2f_abstract – openpde"},{"text":"Uses: openpde_matrix_abstract openpde_vector_abstract openpde_kinds module~~openpde_linsolver_abstract~~UsesGraph module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of linsolver. Used By module~~openpde_linsolver_abstract~~UsedByGraph module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_equation_adv openpde_equation_adv module~openpde_linsolver_abstract->module~openpde_equation_adv module~openpde openpde module~openpde_linsolver_abstract->module~openpde module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_linsolver_gmlapack->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit var panmoduleopenpde_linsolver_abstractUsedByGraph = svgPanZoom('#moduleopenpde_linsolver_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_init abstract_set_matrix abstract_set_vector abstract_solve Derived Types linsolver Subroutines free Abstract Interfaces abstract interface private subroutine abstract_init (this, n) Init linsolver. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this integer(kind=I_P) :: n abstract interface private subroutine abstract_set_matrix (this, mat) Set matrix. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( matrix ), intent(in), target :: mat The mesh. abstract interface private subroutine abstract_set_vector (this, vec) Set vector. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The field. class( vector ), intent(in), target :: vec The mesh. abstract interface Initialize the field. private subroutine abstract_solve (this) Solve system. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout), target :: this The field. Derived Types type, public, abstract :: linsolver Abstract class of linsolver. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( matrix ), public, allocatable :: mat Matrix A class( vector ), public, allocatable :: vec Vector b class( vector ), public, allocatable :: sol Solution x Type-Bound Procedures procedure(abstract_init), public :: init Initilize field. procedure(abstract_set_matrix), public :: set_matrix Associate matrix procedure(abstract_set_vector), public :: set_vector Associate vector procedure(abstract_solve), public :: solve Solve system. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( linsolver ), intent(inout) :: this The linsolver.","tags":"","loc":"module/openpde_linsolver_abstract.html","title":"openpde_linsolver_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_linsolver_abstract openpde_matrix_abstract openpde_vector_abstract openpde_matrix_simple openpde_vector_simple openpde_kinds module~~openpde_linsolver_gmlapack~~UsesGraph module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_linsolver_gmlapack module~openpde_matrix_simple openpde_matrix_simple iso_fortran_env->module~openpde_matrix_simple module~openpde_vector_simple openpde_vector_simple iso_fortran_env->module~openpde_vector_simple module~openpde_matrix_simple->module~openpde_linsolver_gmlapack module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_matrix_abstract->module~openpde_linsolver_gmlapack module~openpde_matrix_abstract->module~openpde_matrix_simple module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_vector_simple->module~openpde_linsolver_gmlapack module~openpde_vector_abstract openpde_vector_abstract module~openpde_vector_abstract->module~openpde_linsolver_gmlapack module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_vector_simple module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_linsolver_gmlapack module~openpde_kinds->module~openpde_matrix_simple module~openpde_kinds->module~openpde_matrix_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_kinds->module~openpde_vector_simple module~openpde_kinds->module~openpde_vector_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of linsolver using LAPACK with general matrix. Used By module~~openpde_linsolver_gmlapack~~UsedByGraph module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde openpde module~openpde_linsolver_gmlapack->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types linsolver_gmlapack Subroutines init set_matrix set_vector solve Derived Types type, public, extends( linsolver ) :: linsolver_gmlapack Concrete class of linsolver using LAPACK with general matrix. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( matrix ), public, allocatable :: mat Matrix A class( vector ), public, allocatable :: vec Vector b class( vector ), public, allocatable :: sol Solution x integer(kind=I_P), public, allocatable :: ipiv (:) integer(kind=I_P), public :: info integer(kind=I_P), public :: lda Type-Bound Procedures procedure, public :: init procedure, public :: set_matrix procedure, public :: set_vector procedure, public :: solve Subroutines private subroutine init (this, n) Init linsolver Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this integer(kind=I_P) :: n private subroutine set_matrix (this, mat) Set the solver matrix A. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( matrix ), intent(in), target :: mat private subroutine set_vector (this, vec) Set the solver vector b. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout) :: this class( vector ), intent(in), target :: vec private subroutine solve (this) Solve the linear system. Arguments Type Intent Optional Attributes Name class( linsolver_gmlapack ), intent(inout), target :: this","tags":"","loc":"module/openpde_linsolver_gmlapack.html","title":"openpde_linsolver_gmlapack – openpde"},{"text":"Uses: openpde_field_abstract openpde_f2m_d2_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D openpde_matrix_abstract module~~openpde_f2m_d2_fd_1d~~UsesGraph module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_d2_fd_1d module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds->module~openpde_f2m_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_mesh_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d var panmoduleopenpde_f2m_d2_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_f2m_d2_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field to matrix (implicit) second derivative operator for FD 1D Used By module~~openpde_f2m_d2_fd_1d~~UsedByGraph module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde openpde module~openpde_f2m_d2_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2m_d2_FD_1D Functions operate Derived Types type, public, extends( f2m_d2 ) :: f2m_d2_FD_1D Concrete class of field to matrix (implicit) second derivative operator for FD 1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application.","tags":"","loc":"module/openpde_f2m_d2_fd_1d.html","title":"openpde_f2m_d2_FD_1D – openpde"},{"text":"Uses: openpde_matrix_abstract openpde_f2m_abstract module~~openpde_f2m_d1_abstract~~UsesGraph module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_f2m_d1_abstractUsesGraph = svgPanZoom('#moduleopenpde_f2m_d1_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of matrix operator of first derivative. Used By module~~openpde_f2m_d1_abstract~~UsedByGraph module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde openpde module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2m_d1_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2m_d1 Derived Types type, public, abstract, extends( f2m ) :: f2m_d1 Abstract class of matrix operator of first derivative. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure(abstract_operate), public :: operate Operator function.","tags":"","loc":"module/openpde_f2m_d1_abstract.html","title":"openpde_f2m_d1_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_f2m_d1_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D openpde_matrix_abstract module~~openpde_f2m_d1_fd_1d~~UsesGraph module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_d1_fd_1d module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds->module~openpde_f2m_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_field_abstract->module~openpde_f2m_d1_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_mesh_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract var panmoduleopenpde_f2m_d1_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_f2m_d1_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field to matrix (implicit) second derivative operator for FD 1D Used By module~~openpde_f2m_d1_fd_1d~~UsedByGraph module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde openpde module~openpde_f2m_d1_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2m_d1_FD_1D Functions operate Derived Types type, public, extends( f2m_d1 ) :: f2m_d1_FD_1D Concrete class of field to matrix (implicit) second derivative operator for FD 1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application.","tags":"","loc":"module/openpde_f2m_d1_fd_1d.html","title":"openpde_f2m_d1_FD_1D – openpde"},{"text":"Uses: openpde_matrix_abstract openpde_f2m_abstract module~~openpde_f2m_d2_abstract~~UsesGraph module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_f2m_d2_abstractUsesGraph = svgPanZoom('#moduleopenpde_f2m_d2_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of matrix operator of second derivative. Used By module~~openpde_f2m_d2_abstract~~UsedByGraph module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde openpde module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2m_d2 Derived Types type, public, abstract, extends( f2m ) :: f2m_d2 Abstract class of matrix operator of second derivative. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure(abstract_operate), public :: operate Operator function.","tags":"","loc":"module/openpde_f2m_d2_abstract.html","title":"openpde_f2m_d2_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_f2m_d2_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D openpde_matrix_abstract module~~openpde_f2m_d2_fd_2d~~UsesGraph module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_d2_fd_2d module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_kinds->module~openpde_field_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds->module~openpde_f2m_abstract module~openpde_mesh_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_field_abstract->module~openpde_f2m_d2_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract var panmoduleopenpde_f2m_d2_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_f2m_d2_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of field to matrix (implicit) second derivative operator for FD 1D Used By module~~openpde_f2m_d2_fd_2d~~UsedByGraph module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde openpde module~openpde_f2m_d2_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2m_d2_FD_2D Functions operate Derived Types type, public, extends( f2m_d2 ) :: f2m_d2_FD_2D Concrete class of field to matrix (implicit) second derivative operator for FD 1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, i_equ, i_fie, dir) result(opr) Operator 2 derivative implicit FD 1D Arguments Type Intent Optional Attributes Name class( f2m_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Counter. integer(kind=I_P), intent(in), optional :: i_fie Counter. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator application.","tags":"","loc":"module/openpde_f2m_d2_fd_2d.html","title":"openpde_f2m_d2_FD_2D – openpde"},{"text":"Uses: openpde_field_abstract openpde_matrix_abstract openpde_kinds module~~openpde_f2m_abstract~~UsesGraph module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2m_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of f2m (field to matrix) operator. Used By module~~openpde_f2m_abstract~~UsedByGraph module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde openpde module~openpde_f2m_abstract->module~openpde module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_f2m_d1_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_operate Derived Types f2m Abstract Interfaces abstract interface Operator operation. private function abstract_operate (this, inp, i_equ, i_fie, dir) result(opr) Operator function. Arguments Type Intent Optional Attributes Name class( f2m ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: inp Input field. integer(kind=I_P), intent(in), optional :: i_equ Direction of operation. integer(kind=I_P), intent(in), optional :: i_fie Direction of operation. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( matrix ),\n  allocatable, target Matrix representing the operator as f(u)=A*u Derived Types type, public, abstract :: f2m Abstract class of f2m operator. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. class( matrix ), public, allocatable :: mat Matrix used only to decide the type Type-Bound Procedures procedure(abstract_operate), public :: operate Operator function.","tags":"","loc":"module/openpde_f2m_abstract.html","title":"openpde_f2m_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_equation_adv openpde_kinds module~~openpde_integrator_adv_abstract~~UsesGraph module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv openpde_equation_adv module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_equation_adv module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_equation_adv module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_linsolver_abstract->module~openpde_equation_adv var panmoduleopenpde_integrator_adv_abstractUsesGraph = svgPanZoom('#moduleopenpde_integrator_adv_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of integrator. Used By module~~openpde_integrator_adv_abstract~~UsedByGraph module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde openpde module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_init abstract_integrate Derived Types integrator_adv Subroutines free Abstract Interfaces abstract interface Initialize integrator. private subroutine abstract_init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Integrate the field accordingly the equation. private function abstract_integrate (this, equ, t, inp) result(error) Integrate the field accordingly to the equation. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. Derived Types type, public, abstract :: integrator_adv Abstract class of integrator. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure(abstract_init), public, pass(this) :: init Initilize integrator. procedure(abstract_integrate), public, pass(this) :: integrate Integrate the field accordingly to the equation. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator_adv ), intent(inout) :: this The integrator.","tags":"","loc":"module/openpde_integrator_adv_abstract.html","title":"openpde_integrator_adv_abstract – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_equation_adv openpde_field_abstract openpde_matrix_abstract openpde_vector_abstract openpde_integrator_adv_abstract openpde_kinds openpde_field_FD_1D module~~openpde_integrator_adv_euler_implicit~~UsesGraph module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_equation_adv openpde_equation_adv module~openpde_kinds->module~openpde_equation_adv module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_adv_euler_implicit iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_matrix_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract json_module json_module json_module->module~openpde_integrator_adv_euler_implicit json_module->module~openpde_mesh_fd_1d module~openpde_field_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_linsolver_abstract->module~openpde_equation_adv var panmoduleopenpde_integrator_adv_euler_implicitUsesGraph = svgPanZoom('#moduleopenpde_integrator_adv_euler_implicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of integrator, Euler explicit scheme. Used By module~~openpde_integrator_adv_euler_implicit~~UsedByGraph module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde openpde module~openpde_integrator_adv_euler_implicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrator_adv_euler_implicit Functions integrate Subroutines init load_from_json Derived Types type, public, extends( integrator_adv ) :: integrator_adv_euler_implicit Concrete class of integrator, Euler implicit scheme. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. real(kind=R_P), public :: alpha class( matrix ), public, allocatable :: matA class( vector ), public, allocatable :: vecB class( vector ), public, allocatable :: vecS class( matrix ), public, allocatable :: mat_identity Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. generic, public :: load => load_from_json Load integrator definition from file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. Functions private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. Subroutines private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_integrator_adv_euler_implicit.html","title":"openpde_integrator_adv_euler_implicit – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_equation_adv openpde_field_abstract openpde_integrator_adv_abstract openpde_kinds module~~openpde_integrator_adv_euler_explicit~~UsesGraph module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_adv_euler_explicit module~openpde_equation_adv openpde_equation_adv module~openpde_kinds->module~openpde_equation_adv module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract json_module json_module json_module->module~openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_v2f_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_linsolver_abstract->module~openpde_equation_adv var panmoduleopenpde_integrator_adv_euler_explicitUsesGraph = svgPanZoom('#moduleopenpde_integrator_adv_euler_explicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of integrator, Euler explicit scheme. Used By module~~openpde_integrator_adv_euler_explicit~~UsedByGraph module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde openpde module~openpde_integrator_adv_euler_explicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrator_adv_euler_explicit Functions integrate Subroutines init load_from_json Derived Types type, public, extends( integrator_adv ) :: integrator_adv_euler_explicit Concrete class of integrator, Euler explicit scheme. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. generic, public :: load => load_from_json Load integrator definition from file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. Functions private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target, dimension(:) :: inp Input field. Return Value integer(kind=I_P) Error status. Subroutines private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_integrator_adv_euler_explicit.html","title":"openpde_integrator_adv_euler_explicit – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_equation_adv openpde_field_abstract openpde_matrix_abstract openpde_vector_abstract openpde_integrator_adv_abstract openpde_kinds openpde_field_FD_1D module~~openpde_integrator_adv_rk_implicit~~UsesGraph module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_equation_adv openpde_equation_adv module~openpde_kinds->module~openpde_equation_adv module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_kinds->module~openpde_integrator_adv_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_adv_rk_implicit iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_matrix_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract json_module json_module json_module->module~openpde_integrator_adv_rk_implicit json_module->module~openpde_mesh_fd_1d module~openpde_field_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_linsolver_abstract->module~openpde_equation_adv var panmoduleopenpde_integrator_adv_rk_implicitUsesGraph = svgPanZoom('#moduleopenpde_integrator_adv_rk_implicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of integrator, Euler explicit scheme. Used By module~~openpde_integrator_adv_rk_implicit~~UsedByGraph module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde openpde module~openpde_integrator_adv_rk_implicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrator_adv_rk_implicit Functions integrate Subroutines init load_from_json Derived Types type, public, extends( integrator_adv ) :: integrator_adv_rk_implicit Concrete class of integrator, Euler implicit scheme. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. real(kind=R_P), public :: alpha class( matrix ), public, allocatable :: matA class( vector ), public, allocatable :: vecB class( vector ), public, allocatable :: vecS class( matrix ), public, allocatable :: mat_identity integer(kind=I_P), public :: n_stages real(kind=R_P), public, allocatable :: rk_alph (:,:) real(kind=R_P), public, allocatable :: rk_beta (:) real(kind=R_P), public, allocatable :: rk_gamm (:) class( field ), public, allocatable :: stages (:,:) Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. generic, public :: load => load_from_json Load integrator definition from file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. Functions private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation definition. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp (:) Input field. Return Value integer(kind=I_P) Error status. Subroutines private subroutine init (this, equ, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. class( equation_adv ), intent(inout), target :: equ The equation. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_adv_rk_implicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_integrator_adv_rk_implicit.html","title":"openpde_integrator_adv_rk_implicit – openpde"},{"text":"Uses: iso_fortran_env openpde_vector_abstract openpde_kinds module~~openpde_vector_simple~~UsesGraph module~openpde_vector_simple openpde_vector_simple module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_vector_simple module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_vector_simple module~openpde_vector_abstract->module~openpde_vector_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of vector, naive. Used By module~~openpde_vector_simple~~UsedByGraph module~openpde_vector_simple openpde_vector_simple module~openpde openpde module~openpde_vector_simple->module~openpde module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_vector_simple->module~openpde_linsolver_gmlapack module~openpde_linsolver_gmlapack->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types vector_simple Functions associate_vector_simple get Subroutines assign_vector init output set Derived Types type, public, extends( vector ) :: vector_simple Naive vector (not sparse) Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Vector description. integer(kind=I_P), public :: n Vector size. real(kind=R_P), public, dimension(:), allocatable :: val Vector values Type-Bound Procedures generic, public :: assignment(=) => assign_vector Operator `= overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public :: init procedure, public :: output procedure, public :: set procedure, public :: get procedure, private :: assign_vector Functions public function associate_vector_simple (vector_input, emsg) result(vector_pointer) Check the type of the vector passed as input and return a vector pointer with type vector_simple Arguments Type Intent Optional Attributes Name class( vector ), intent(in), target :: vector_input Input vector. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( vector_simple ),\n  pointer Simple vector pointer. private function get (this, i) result(val) Get vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. Return Value real(kind=R_P) Value to assign. Subroutines private subroutine assign_vector (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. private subroutine init (this, n, description, error) Initialize vector. Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Print (naively) vector Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine set (this, i, val) Set vector value Arguments Type Intent Optional Attributes Name class( vector_simple ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Vector index filled. real(kind=R_P), intent(in) :: val Value to assign.","tags":"","loc":"module/openpde_vector_simple.html","title":"openpde_vector_simple – openpde"},{"text":"Uses: openpde_kinds module~~openpde_vector_abstract~~UsesGraph module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_vector_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of vector Used By module~~openpde_vector_abstract~~UsedByGraph module~openpde_vector_abstract openpde_vector_abstract module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_vector_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_vector_abstract->module~openpde_linsolver_gmlapack module~openpde openpde module~openpde_vector_abstract->module~openpde module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_vector_abstract->module~openpde_v2f_fd_2d module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_vector_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv openpde_equation_adv module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_vector_abstract->module~openpde_f2v_fd_2d module~openpde_vector_simple openpde_vector_simple module~openpde_vector_abstract->module~openpde_vector_simple module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_vector_abstract->module~openpde_v2f_fd_1d module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_vector_abstract->module~openpde_f2v_fd_1d module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_linsolver_gmlapack->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_f2v_fd_2d->module~openpde module~openpde_vector_simple->module~openpde_linsolver_gmlapack module~openpde_vector_simple->module~openpde module~openpde_v2f_fd_1d->module~openpde module~openpde_f2v_abstract->module~openpde module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_v2f_abstract->module~openpde module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_linsolver_abstract->module~openpde module~openpde_linsolver_abstract->module~openpde_equation_adv module~openpde_f2v_fd_1d->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit var panmoduleopenpde_vector_abstractUsedByGraph = svgPanZoom('#moduleopenpde_vector_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_vectorinit abstract_vectoroutput abstract_vectorset abstract_vectorget abstract_assign Derived Types vector Subroutines free Abstract Interfaces abstract interface Initialize vector. private subroutine abstract_vectorinit (this, n, description, error) Initialize vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: n Vector number of elements. character(len=*), intent(in), optional :: description Vector description. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Output vector. private subroutine abstract_vectoroutput (this, filename, error) Output vector. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. character(len=*), intent(in) :: filename Output filename. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Set vector element. private subroutine abstract_vectorset (this, i, val) Set vector element. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector. integer(kind=I_P), intent(in) :: i Index to set real(kind=R_P), intent(in) :: val Value to be assigned abstract interface Get vector element. private function abstract_vectorget (this, i) result(val) Set vector element. Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: this The vector. integer(kind=I_P), intent(in) :: i Index to get Return Value real(kind=R_P) Value to be extracted abstract interface Assignment overloading. private subroutine abstract_assign (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: lhs Left hand side. class( vector ), intent(in), target :: rhs Right hand side. Derived Types type, public, abstract :: vector Abstract class of vector Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Vector description. integer(kind=I_P), public :: n Vector size. Type-Bound Procedures procedure(abstract_vectorinit), public :: init Initilize vector. procedure(abstract_vectoroutput), public :: output Output vector. procedure(abstract_vectorset), public :: set Set vector element. procedure(abstract_vectorget), public :: get Get vector element. procedure(abstract_assign), private :: assign_vector Assign vector. generic, public :: assignment(=) => assign_vector Operator `= overloading. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( vector ), intent(inout) :: this The vector.","tags":"","loc":"module/openpde_vector_abstract.html","title":"openpde_vector_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_v2f_abstract openpde_f2v_abstract openpde_matrix_abstract openpde_vector_abstract openpde_mesh_abstract openpde_multigrid_abstract openpde_linsolver_abstract openpde_kinds module~~openpde_equation_adv~~UsesGraph module~openpde_equation_adv openpde_equation_adv module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_equation_adv module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_kinds->module~openpde_v2f_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_kinds->module~openpde_linsolver_abstract module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_vector_abstract->module~openpde_equation_adv module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_v2f_abstract module~openpde_vector_abstract->module~openpde_linsolver_abstract module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_linsolver_abstract->module~openpde_equation_adv var panmoduleopenpde_equation_advUsesGraph = svgPanZoom('#moduleopenpde_equation_advUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Simil-abstract class of equation advanced. Used By module~~openpde_equation_adv~~UsedByGraph module~openpde_equation_adv openpde_equation_adv module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde openpde module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde var panmoduleopenpde_equation_advUsedByGraph = svgPanZoom('#moduleopenpde_equation_advUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types equation_adv Functions jacobian Subroutines init bc_e bc_i resid_e resid_emg resid_i free Derived Types type, public :: equation_adv Simil-abstract class of equation_adv. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. integer(kind=I_P), public :: n_equ = 0_I_P Number of equations class( mesh ), public, pointer :: m Mesh pointer logical, public :: enable_explicit = .false. Activate explicit solver. logical, public :: enable_implicit = .false. Activate implicit solver. logical, public :: enable_multigrid = .false. Activate multigrid solver. class( field ), public, allocatable, dimension(:) :: resvar_e Residuals field for explicit solver. integer(kind=I_P), public :: n_size Number of elements (vector size for linear solvers). class( matrix ), public, allocatable :: resvar_i Residuals field for implicit solver. class( linsolver ), public, allocatable :: solver Linear solver. class( f2v ), public, allocatable :: f2v_opr Field to vector converter. class( v2f ), public, allocatable :: v2f_opr Vector to Field converter. class( multigrid ), public, allocatable :: mg Multigrid solver. class( field ), public, allocatable, dimension(:) :: resvar_mg Residuals field for multigrid solver. class( field ), public, allocatable, dimension(:) :: source_mg Sources field for multigrid solver. Type-Bound Procedures procedure, public :: bc_e Equation boundary conditions explicit. procedure, public :: bc_i Equation boundary conditions implicit. procedure, public :: init Initialize the equation. procedure, public :: jacobian Jacobian for multigrid solution procedure, public :: resid_e Residual explicit procedure, public :: resid_emg Residual for multigrid procedure, public :: resid_i Residual implicit procedure, public :: free Free dynamic memory. Functions private function jacobian (this, inp, t) result(opr) Return the jacobian, useful for multigrid Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( matrix ),\n  allocatable Field computed. Subroutines private subroutine init (this, n_equ, field_mesh, inp, description, filename, error) Initialize equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. integer(kind=I_P), intent(in) :: n_equ Number of equations class( mesh ), intent(in), target :: field_mesh Mesh of the field. class( field ), intent(inout), target :: inp (:) Input field. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine bc_e (this, inp, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. private subroutine bc_i (this, matA, vecB, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(in) :: this The equation. class( matrix ), intent(inout), target :: matA Input field. class( vector ), intent(inout), target :: vecB Input field. real(kind=R_P), intent(in) :: t Time. private subroutine resid_e (this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. private subroutine resid_emg (this, inp, t, output) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. class( field ), intent(out), target :: output (:) Input field. private subroutine resid_i (this, inp, t) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation. class( field ), intent(in), target :: inp (:) Input field. real(kind=R_P), intent(in) :: t Time. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( equation_adv ), intent(inout) :: this The equation.","tags":"","loc":"module/openpde_equation_adv.html","title":"openpde_equation_adv – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d2_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D module~~openpde_spatial_operator_d2_fd_2d~~UsesGraph module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d2_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_kinds->module~openpde_field_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract var panmoduleopenpde_spatial_operator_d2_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Used By module~~openpde_spatial_operator_d2_fd_2d~~UsedByGraph module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d2_FD_2D Functions operate Derived Types type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_2D Concrete class of spatial operator of second derivative for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d2_fd_2d.html","title":"openpde_spatial_operator_d2_FD_2D – openpde"},{"text":"Uses: openpde_spatial_operator_abstract module~~openpde_spatial_operator_d2_abstract~~UsesGraph module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_spatial_operator_d2_abstractUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of spatial operator of second derivative. Used By module~~openpde_spatial_operator_d2_abstract~~UsedByGraph module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde openpde module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d2 Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_d2 Abstract class of spatial operator of second derivative. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function.","tags":"","loc":"module/openpde_spatial_operator_d2_abstract.html","title":"openpde_spatial_operator_d2_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d1_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D module~~openpde_spatial_operator_d1_fd_2d~~UsesGraph module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d1_fd_2d module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_field_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract var panmoduleopenpde_spatial_operator_d1_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Used By module~~openpde_spatial_operator_d1_fd_2d~~UsedByGraph module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d1_FD_2D Functions operate Derived Types type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_2D Concrete class of spatial operator of first derivative for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d1_fd_2d.html","title":"openpde_spatial_operator_d1_FD_2D – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d1_abstract openpde_field_FV_1D openpde_kinds openpde_mesh_FV_1D module~~openpde_spatial_operator_d1_fv_1d~~UsesGraph module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d1_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_kinds->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_field_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_field_block_fv_1d json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_field_block_fv_1d->module~openpde_field_fv_1d var panmoduleopenpde_spatial_operator_d1_fv_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_fv_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of first derivative for Finite Volume 1D methods. Used By module~~openpde_spatial_operator_d1_fv_1d~~UsedByGraph module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d1_FV_1D Functions operate Derived Types type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FV_1D Concrete class of spatial operator of first derivative for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d1_fv_1d.html","title":"openpde_spatial_operator_d1_FV_1D – openpde"},{"text":"Uses: openpde_spatial_operator_abstract module~~openpde_spatial_operator_d1_abstract~~UsesGraph module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_spatial_operator_d1_abstractUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of spatial operator of first derivative. Used By module~~openpde_spatial_operator_d1_abstract~~UsedByGraph module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde openpde module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d1 Derived Types type, public, abstract, extends( spatial_operator ) :: spatial_operator_d1 Abstract class of spatial operator of first derivative. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function.","tags":"","loc":"module/openpde_spatial_operator_d1_abstract.html","title":"openpde_spatial_operator_d1_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_kinds module~~openpde_spatial_operator_abstract~~UsesGraph module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of spatial operator. Used By module~~openpde_spatial_operator_abstract~~UsedByGraph module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde var panmoduleopenpde_spatial_operator_abstractUsedByGraph = svgPanZoom('#moduleopenpde_spatial_operator_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_operate Derived Types spatial_operator Abstract Interfaces abstract interface Operator operation. private function abstract_operate (this, inp, dir) result(opr) Operator function. Arguments Type Intent Optional Attributes Name class( spatial_operator ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application. Derived Types type, public, abstract :: spatial_operator Abstract class of spatial operator. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function.","tags":"","loc":"module/openpde_spatial_operator_abstract.html","title":"openpde_spatial_operator_abstract – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d2_abstract openpde_field_FV_1D openpde_kinds openpde_mesh_FV_1D module~~openpde_spatial_operator_d2_fv_1d~~UsesGraph module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d2_fv_1d module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_kinds->module~openpde_field_fv_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_kinds->module~openpde_field_block_fv_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fv_1d iso_fortran_env->module~openpde_field_fv_1d iso_fortran_env->module~openpde_mesh_block_fv_1d iso_fortran_env->module~openpde_field_block_fv_1d json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract var panmoduleopenpde_spatial_operator_d2_fv_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_fv_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of second derivative for Finite Volume 1D methods. Used By module~~openpde_spatial_operator_d2_fv_1d~~UsedByGraph module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d2_FV_1D Functions operate Derived Types type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FV_1D Concrete class of spatial operator of second derivative for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FV_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d2_fv_1d.html","title":"openpde_spatial_operator_d2_FV_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d1_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D module~~openpde_spatial_operator_d1_fd_1d~~UsesGraph module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_1d iso_fortran_env->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_1d var panmoduleopenpde_spatial_operator_d1_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d1_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Used By module~~openpde_spatial_operator_d1_fd_1d~~UsedByGraph module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d1_FD_1D Functions operate Derived Types type, public, extends( spatial_operator_d1 ) :: spatial_operator_d1_FD_1D Concrete class of spatial operator of first derivative for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d1_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d1_fd_1d.html","title":"openpde_spatial_operator_d1_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_spatial_operator_d2_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D module~~openpde_spatial_operator_d2_fd_1d~~UsesGraph module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_spatial_operator_d2_fd_1d module~openpde_kinds->module~openpde_field_fd_1d module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_kinds->module~openpde_spatial_operator_abstract module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract var panmoduleopenpde_spatial_operator_d2_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_spatial_operator_d2_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Used By module~~openpde_spatial_operator_d2_fd_1d~~UsedByGraph module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types spatial_operator_d2_FD_1D Functions operate Derived Types type, public, extends( spatial_operator_d2 ) :: spatial_operator_d2_FD_1D Concrete class of spatial operator of second derivative for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Operator description. Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, inp, dir) result(opr) Operator operation. Arguments Type Intent Optional Attributes Name class( spatial_operator_d2_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), target :: inp Input field. integer(kind=I_P), intent(in), optional :: dir Direction of operation. Return Value class( field ),\n  allocatable, target Field resulting after the operator application.","tags":"","loc":"module/openpde_spatial_operator_d2_fd_1d.html","title":"openpde_spatial_operator_d2_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_f2v_abstract openpde_field_FD_1D openpde_kinds openpde_mesh_FD_1D openpde_vector_abstract module~~openpde_f2v_fd_1d~~UsesGraph module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2v_fd_1d module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_kinds->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_vector_abstract->module~openpde_f2v_fd_1d module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_abstract->module~openpde_f2v_fd_1d module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2v_fd_1d module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_field_fd_1d iso_fortran_env->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d var panmoduleopenpde_f2v_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_f2v_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of f2v (field to vector) for FD 1D Used By module~~openpde_f2v_fd_1d~~UsedByGraph module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde openpde module~openpde_f2v_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2v_FD_1D Functions operate Derived Types type, public, extends( f2v ) :: f2v_FD_1D Concrete class of f2v (field to vector) for FD 1D Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_1D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector.","tags":"","loc":"module/openpde_f2v_fd_1d.html","title":"openpde_f2v_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_f2v_abstract openpde_field_FD_2D openpde_kinds openpde_mesh_FD_2D openpde_vector_abstract module~~openpde_f2v_fd_2d~~UsesGraph module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2v_fd_2d module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds->module~openpde_f2v_abstract module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_kinds->module~openpde_field_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_mesh_fd_2d->module~openpde_f2v_fd_2d module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_f2v_fd_2d module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_vector_abstract->module~openpde_f2v_fd_2d module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_field_fd_2d->module~openpde_f2v_fd_2d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d iso_fortran_env->module~openpde_field_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_fd_2d var panmoduleopenpde_f2v_fd_2dUsesGraph = svgPanZoom('#moduleopenpde_f2v_fd_2dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of f2v (field to vector) for FD 1D Used By module~~openpde_f2v_fd_2d~~UsedByGraph module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde openpde module~openpde_f2v_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types f2v_FD_2D Functions operate Derived Types type, public, extends( f2v ) :: f2v_FD_2D Concrete class of f2v (field to vector) for FD 1D Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure, public :: operate Operator operation. Functions private function operate (this, fie) result(vec) Operator operation. Arguments Type Intent Optional Attributes Name class( f2v_FD_2D ), intent(in) :: this The operator. class( field ), intent(in), dimension(:), target :: fie Input field. Return Value class( vector ),\n  allocatable Returned vector.","tags":"","loc":"module/openpde_f2v_fd_2d.html","title":"openpde_f2v_FD_2D – openpde"},{"text":"Uses: openpde_field_abstract openpde_vector_abstract openpde_kinds module~~openpde_f2v_abstract~~UsesGraph module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_f2v_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_vector_abstract openpde_vector_abstract module~openpde_kinds->module~openpde_vector_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_vector_abstract->module~openpde_f2v_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of f2v (field to vector). Used By module~~openpde_f2v_abstract~~UsedByGraph module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_equation_adv openpde_equation_adv module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde openpde module~openpde_f2v_abstract->module~openpde module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_f2v_fd_2d->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit var panmoduleopenpde_f2v_abstractUsedByGraph = svgPanZoom('#moduleopenpde_f2v_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_operate Derived Types f2v Abstract Interfaces abstract interface Operator operation. private function abstract_operate (this, fie) result(vec) Operator function. Arguments Type Intent Optional Attributes Name class( f2v ), intent(in) :: this The operator. class( field ), intent(in), target, dimension(:) :: fie Input field. Return Value class( vector ),\n  allocatable Resulting vector. Derived Types type, public, abstract :: f2v Abstract class of f2v. Components Type Visibility Attributes Name Initial class( vector ), public, allocatable :: vec Vector used only to decide the type Type-Bound Procedures procedure(abstract_operate), public, pass(this) :: operate Operator function.","tags":"","loc":"module/openpde_f2v_abstract.html","title":"openpde_f2v_abstract – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_equation_abstract openpde_field_abstract openpde_integrator_abstract openpde_kinds module~~openpde_integrator_euler_explicit~~UsesGraph module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract openpde_equation_abstract module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit json_module json_module json_module->module~openpde_integrator_euler_explicit module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_field_abstract->module~openpde_integrator_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_integrator_euler_explicit module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_euler_explicit module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_integrator_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_integrator_euler_explicitUsesGraph = svgPanZoom('#moduleopenpde_integrator_euler_explicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of integrator, Euler explicit scheme. Used By module~~openpde_integrator_euler_explicit~~UsedByGraph module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde openpde module~openpde_integrator_euler_explicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrator_euler_explicit Functions integrate Subroutines init load_from_json Derived Types type, public, extends( integrator ) :: integrator_euler_explicit Concrete class of integrator, Euler explicit scheme. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize integrator. procedure, public, pass(this) :: integrate Integrate the field accordingly to the equation. generic, public :: load => load_from_json Load integrator definition from file. procedure, private, pass(this) :: load_from_json Load integrator definition from jSON file. Functions private function integrate (this, equ, t, inp) result(error) Integrate the field accordingly the to equation by means of the Euler explicit scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Subroutines private subroutine init (this, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, filename, error) Load integrator definition from JSON file. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: this The integrator. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_integrator_euler_explicit.html","title":"openpde_integrator_euler_explicit – openpde"},{"text":"Uses: openpde_field_abstract openpde_equation_abstract openpde_kinds module~~openpde_integrator_abstract~~UsesGraph module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_integrator_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_equation_abstract openpde_equation_abstract module~openpde_kinds->module~openpde_equation_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_mesh_abstract->module~openpde_field_abstract var panmoduleopenpde_integrator_abstractUsesGraph = svgPanZoom('#moduleopenpde_integrator_abstractUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of integrator. Used By module~~openpde_integrator_abstract~~UsedByGraph module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde openpde module~openpde_integrator_abstract->module~openpde module~openpde_integrator_euler_explicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_init abstract_integrate Derived Types integrator Subroutines free Abstract Interfaces abstract interface Initialize integrator. private subroutine abstract_init (this, description, filename, error) Initialize integrator. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator. character(len=*), intent(in), optional :: description Integrator description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Integrate the field accordingly the equation. private function abstract_integrate (this, equ, t, inp) result(error) Integrate the field accordingly to the equation. Arguments Type Intent Optional Attributes Name class( integrator ), intent(in) :: this The integrator. class( equation ), intent(in), target :: equ The equation. real(kind=R_P), intent(in) :: t Time. class( field ), intent(inout), target :: inp Input field. Return Value integer(kind=I_P) Error status. Derived Types type, public, abstract :: integrator Abstract class of integrator. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Integrator description. real(kind=R_P), public :: dt = 0._R_P Time step. Type-Bound Procedures procedure(abstract_init), public, pass(this) :: init Initilize integrator. procedure(abstract_integrate), public, pass(this) :: integrate Integrate the field accordingly to the equation. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( integrator ), intent(inout) :: this The integrator.","tags":"","loc":"module/openpde_integrator_abstract.html","title":"openpde_integrator_abstract – openpde"},{"text":"Uses: openpde_multigrid_abstract openpde_field_abstract openpde_mesh_FD_1D openpde_kinds module~~openpde_multigrid_fd_1d~~UsesGraph module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_multigrid_fd_1d module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_multigrid_fd_1d module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_mesh_fd_1d->module~openpde_multigrid_fd_1d module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_mesh_abstract->module~openpde_mesh_fd_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_1d var panmoduleopenpde_multigrid_fd_1dUsesGraph = svgPanZoom('#moduleopenpde_multigrid_fd_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of linsolver using LAPACK with general matrix. Used By module~~openpde_multigrid_fd_1d~~UsedByGraph module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde openpde module~openpde_multigrid_fd_1d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types multigrid_FD_1D Subroutines create_subgrids_field init Derived Types type, public, extends( multigrid ) :: multigrid_FD_1D Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( field ), public, allocatable :: fields (:,:) Field on each MG level. class( mesh ), public, allocatable :: meshes (:) Meshes on each MG level. class( field ), public, allocatable :: fields0 (:,:) Initial field on each MG level. class( field ), public, allocatable :: residuals (:,:) Residual field on each MG level. class( field ), public, allocatable :: sources (:,:) Source field on each MG level. integer(kind=I_P), public :: levels_number MG levels number. integer(kind=I_P), public :: max_iterations Maximum number of iterations. integer(kind=I_P), public, allocatable :: n_it_up (:) Number of iteration in \"up\" cycle for each MG level. integer(kind=I_P), public, allocatable :: n_it_down (:) Number of iteration in \"up\" cycle for each MG level. real(kind=R_P), public, allocatable :: stability (:) Stability coefficient for each MG level. class( field ), public, allocatable :: tau (:,:) Local pseudo-dt for each MG level. real(kind=R_P), public :: tolerance Tolerance on iterative convergence. real(kind=R_P), public :: norm Norm of residuals. Type-Bound Procedures procedure, public :: create_subgrids_field Create subgrid-levels field. procedure, public :: init Init multigrid solver. Subroutines private subroutine create_subgrids_field (this, inp, subgrids) Create subgrid-levels field. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. private subroutine init (this, inp, levels_number) Init multigrid solver. Arguments Type Intent Optional Attributes Name class( multigrid_FD_1D ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Number of MG levels.","tags":"","loc":"module/openpde_multigrid_fd_1d.html","title":"openpde_multigrid_FD_1D – openpde"},{"text":"Uses: openpde_field_abstract openpde_mesh_abstract openpde_kinds module~~openpde_multigrid_abstract~~UsesGraph module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_multigrid_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of multigrid solver. Used By module~~openpde_multigrid_abstract~~UsedByGraph module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_equation_adv openpde_equation_adv module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde openpde module~openpde_equation_adv->module~openpde module~openpde_multigrid_fd_1d->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde var panmoduleopenpde_multigrid_abstractUsedByGraph = svgPanZoom('#moduleopenpde_multigrid_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces create_subgrids_field_interface init_interface Derived Types multigrid Subroutines free Abstract Interfaces abstract interface Create subgrid-levels field. private subroutine create_subgrids_field_interface (this, inp, subgrids) Create subgrid-levels field. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(in), target :: this The solver. class( field ), intent(in) :: inp (:) Input field on finest mesh. class( field ), intent(inout) :: subgrids (:,:) Subgrid-levels field. abstract interface Init multigrid solver. private subroutine init_interface (this, inp, levels_number) Init multigrid solver. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(inout) :: this The solver. class( field ), intent(in), target :: inp Input field on finest mesh. integer(kind=I_P), intent(in) :: levels_number Levels number. Derived Types type, public, abstract :: multigrid Abstract class of multigrid solver. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Description. class( field ), public, allocatable :: fields (:,:) Field on each MG level. class( mesh ), public, allocatable :: meshes (:) Meshes on each MG level. class( field ), public, allocatable :: fields0 (:,:) Initial field on each MG level. class( field ), public, allocatable :: residuals (:,:) Residual field on each MG level. class( field ), public, allocatable :: sources (:,:) Source field on each MG level. integer(kind=I_P), public :: levels_number MG levels number. integer(kind=I_P), public :: max_iterations Maximum number of iterations. integer(kind=I_P), public, allocatable :: n_it_up (:) Number of iteration in \"up\" cycle for each MG level. integer(kind=I_P), public, allocatable :: n_it_down (:) Number of iteration in \"up\" cycle for each MG level. real(kind=R_P), public, allocatable :: stability (:) Stability coefficient for each MG level. class( field ), public, allocatable :: tau (:,:) Local pseudo-dt for each MG level. real(kind=R_P), public :: tolerance Tolerance on iterative convergence. real(kind=R_P), public :: norm Norm of residuals. Type-Bound Procedures procedure(create_subgrids_field_interface), public :: create_subgrids_field Create subgrid-levels field. procedure(init_interface), public :: init Init multigrid solver. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( multigrid ), intent(inout) :: this The linsolver.","tags":"","loc":"module/openpde_multigrid_abstract.html","title":"openpde_multigrid_abstract – openpde"},{"text":"Uses: openpde_kinds module~~openpde_matrix_abstract~~UsesGraph module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_matrix_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of matrix. Used By module~~openpde_matrix_abstract~~UsedByGraph module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_matrix_abstract->module~openpde_f2m_abstract module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_matrix_abstract->module~openpde_linsolver_gmlapack module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_matrix_abstract->module~openpde_f2m_d1_abstract module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_matrix_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv openpde_equation_adv module~openpde_matrix_abstract->module~openpde_equation_adv module~openpde_linsolver_abstract openpde_linsolver_abstract module~openpde_matrix_abstract->module~openpde_linsolver_abstract module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_matrix_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_matrix_abstract->module~openpde_f2m_d1_fd_1d module~openpde_matrix_simple openpde_matrix_simple module~openpde_matrix_abstract->module~openpde_matrix_simple module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_matrix_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_matrix_abstract->module~openpde_f2m_d2_abstract module~openpde openpde module~openpde_matrix_abstract->module~openpde module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_f2m_abstract->module~openpde module~openpde_linsolver_gmlapack->module~openpde module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d module~openpde_f2m_d1_abstract->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_linsolver_abstract->module~openpde_linsolver_gmlapack module~openpde_linsolver_abstract->module~openpde_equation_adv module~openpde_linsolver_abstract->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_matrix_simple->module~openpde_linsolver_gmlapack module~openpde_matrix_simple->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d2_abstract->module~openpde module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit var panmoduleopenpde_matrix_abstractUsedByGraph = svgPanZoom('#moduleopenpde_matrix_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_simmetric_operator abstract_real_op_field abstract_assign abstract_matrixinit abstract_matrixoutput abstract_matrixset Derived Types matrix Subroutines free Abstract Interfaces abstract interface Assignment overloading. private function abstract_simmetric_operator (lhs, rhs) result(opr) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Result abstract interface private function abstract_real_op_field (lhs, rhs) result(opr) Non symmetric operator real.op.field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. abstract interface Assignment overloading. private subroutine abstract_assign (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. abstract interface Initialize mesh. private subroutine abstract_matrixinit (this, n, description, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Initialization file name. character(len=*), intent(in), optional :: description Mesh description. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Initialize mesh. private subroutine abstract_matrixoutput (this, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Initialize mesh. private subroutine abstract_matrixset (this, i, j, val) Initialize mesh. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this integer(kind=I_P), intent(in) :: i integer(kind=I_P), intent(in) :: j real(kind=R_P), intent(in) :: val Derived Types type, public, abstract :: matrix Abstract class of matrix. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Matrix description. integer(kind=I_P), public :: n Type-Bound Procedures procedure(abstract_matrixinit), public :: init Initilize matrix. procedure(abstract_matrixoutput), public :: output Output matrix. procedure(abstract_matrixset), public :: set Set matrix value. procedure(abstract_simmetric_operator), private :: add Add matrix. procedure(abstract_simmetric_operator), private :: sub Sub matrix. procedure(abstract_real_op_field), private, pass(rhs) :: realmul Real*matrix. procedure(abstract_assign), private :: assign_matrix Assign matrix. generic, public :: assignment(=) => assign_matrix Operator = overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(-) => sub Operator `- overloading. generic, public :: operator(*) => realmul Operator * overloading. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( matrix ), intent(inout) :: this The integrator.","tags":"","loc":"module/openpde_matrix_abstract.html","title":"openpde_matrix_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_matrix_abstract openpde_kinds module~~openpde_matrix_simple~~UsesGraph module~openpde_matrix_simple openpde_matrix_simple module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_matrix_simple module~openpde_matrix_abstract openpde_matrix_abstract module~openpde_kinds->module~openpde_matrix_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_matrix_simple module~openpde_matrix_abstract->module~openpde_matrix_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of (square) matrix, naive. Used By module~~openpde_matrix_simple~~UsedByGraph module~openpde_matrix_simple openpde_matrix_simple module~openpde openpde module~openpde_matrix_simple->module~openpde module~openpde_linsolver_gmlapack openpde_linsolver_gmlapack module~openpde_matrix_simple->module~openpde_linsolver_gmlapack module~openpde_linsolver_gmlapack->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types matrix_simple Functions associate_matrix_simple add sub realmul Subroutines assign_matrix init output set Derived Types type, public, extends( matrix ) :: matrix_simple Naive matrix (not sparse) Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Matrix description. integer(kind=I_P), public :: n real(kind=R_P), public, dimension(:,:), allocatable :: val values Type-Bound Procedures generic, public :: assignment(=) => assign_matrix Operator = overloading. generic, public :: operator(+) => add Operator + overloading. generic, public :: operator(-) => sub Operator `- overloading. generic, public :: operator(*) => realmul Operator * overloading. procedure, public, pass(this) :: free Free dynamic memory. procedure, public :: init procedure, public :: output procedure, public :: set procedure, private :: assign_matrix procedure, private :: add procedure, private :: sub procedure, public, pass(rhs) :: realmul Functions public function associate_matrix_simple (matrix_input, emsg) result(matrix_pointer) Check the type of the matrix passed as input and return a matrix pointer with type matrix_simple Arguments Type Intent Optional Attributes Name class( matrix ), intent(in), target :: matrix_input Input matrix. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( matrix_simple ),\n  pointer Simple matrix pointer. private function add (lhs, rhs) result(opr) Add matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. private function sub (lhs, rhs) result(opr) Subtract matrix. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(in) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. private function realmul (lhs, rhs) result(opr) Real matrix multiply. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( matrix_simple ), intent(in) :: rhs Right hand side. Return Value class( matrix ),\n  allocatable, target Operator result. Subroutines private subroutine assign_matrix (lhs, rhs) Assignment overloading. Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: lhs Left hand side. class( matrix ), intent(in), target :: rhs Right hand side. private subroutine init (this, n, description, error) Initialize matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P) :: n Matrix size. character(len=*), intent(in), optional :: description Matrix description. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, filename, error) Print matrix Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. character(len=*), intent(in) :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine set (this, i, j, val) Set matrix value Arguments Type Intent Optional Attributes Name class( matrix_simple ), intent(inout) :: this The matrix. integer(kind=I_P), intent(in) :: i Index i where set matrix. integer(kind=I_P), intent(in) :: j Index i where set matrix. real(kind=R_P), intent(in) :: val Value to be inserted","tags":"","loc":"module/openpde_matrix_simple.html","title":"openpde_matrix_simple – openpde"},{"text":"Uses: openpde_field_abstract openpde_kinds module~~openpde_equation_abstract~~UsesGraph module~openpde_equation_abstract openpde_equation_abstract module~openpde_field_abstract openpde_field_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_equation_abstract module~openpde_kinds->module~openpde_field_abstract module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_field_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of equation. Used By module~~openpde_equation_abstract~~UsedByGraph module~openpde_equation_abstract openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde openpde module~openpde_equation_abstract->module~openpde module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_euler_explicit->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_integrator_abstract->module~openpde var panmoduleopenpde_equation_abstractUsedByGraph = svgPanZoom('#moduleopenpde_equation_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_bc abstract_init abstract_forcing Derived Types equation Subroutines free Abstract Interfaces abstract interface Equation boundary conditions. private subroutine abstract_bc (this, inp, t) Equation boundary condition. Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(inout), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. abstract interface Initialize equation. private subroutine abstract_init (this, description, filename, error) Initialize equation. Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation. character(len=*), intent(in), optional :: description Equation description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Return the field after forcing the equation. private function abstract_forcing (this, inp, t) result(opr) Return the field after forcing the equation. Arguments Type Intent Optional Attributes Name class( equation ), intent(in) :: this The equation. class( field ), intent(in), target :: inp Input field. real(kind=R_P), intent(in) :: t Time. Return Value class( field ),\n  allocatable Field computed. Derived Types type, public, abstract :: equation Abstract class of equation. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Equation description. Type-Bound Procedures procedure(abstract_bc), public, pass(this) :: bc Equation boundary conditions. procedure(abstract_forcing), public, pass(this) :: forcing Forcing equation. procedure(abstract_init), public, pass(this) :: init Initialize the equation. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( equation ), intent(inout) :: this The equation.","tags":"","loc":"module/openpde_equation_abstract.html","title":"openpde_equation_abstract – openpde"},{"text":"Uses: iso_fortran_env openpde_mesh_abstract openpde_kinds vtk_fortran module~~openpde_mesh_fd_2d~~UsesGraph module~openpde_mesh_fd_2d openpde_mesh_FD_2D vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_2d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_fd_2d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_2d module~openpde_mesh_abstract->module~openpde_mesh_fd_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of mesh for Finite Difference 2D methods. Used By module~~openpde_mesh_fd_2d~~UsedByGraph module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_mesh_fd_2d->module~openpde_v2f_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_mesh_fd_2d->module~openpde_f2v_fd_2d module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde openpde module~openpde_mesh_fd_2d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_field_fd_2d->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_f2v_fd_2d->module~openpde module~openpde_f2m_d2_fd_2d->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mesh_FD_2D Functions associate_mesh_FD_2D Subroutines init output set Derived Types type, public, extends( mesh ) :: mesh_FD_2D Concrete class of mesh for Finite Difference 2D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: nx = 0 Number of X points. integer(kind=I_P), public :: ny = 0 Number of Y points. integer(kind=I_P), public :: ngx = 0 Number of X ghost points. integer(kind=I_P), public :: ngy = 0 Number of Y ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: hx = 0._R_P Cell X size. real(kind=R_P), public :: hy = 0._R_P Cell Y size. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize mesh. procedure, public, pass(this) :: output Output data. procedure, public, pass(this) :: set Set mesh. Functions public function associate_mesh_FD_2D (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 2D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_2D ),\n  pointer Finite Difference 2D mesh pointer. Subroutines private pure subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. private pure subroutine set (this, description, nx, ny, ngx, ngy, s, hx, hy, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_2D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nx Number of X points. integer(kind=I_P), intent(in), optional :: ny Number of Y points. integer(kind=I_P), intent(in), optional :: ngx Number of X ghost points. integer(kind=I_P), intent(in), optional :: ngy Number of Y ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: hx Cell X size. real(kind=R_P), intent(in), optional :: hy Cell Y size. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_mesh_fd_2d.html","title":"openpde_mesh_FD_2D – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_kinds module~~openpde_mesh_block_fv_1d~~UsesGraph module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D json_module json_module json_module->module~openpde_mesh_block_fv_1d iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_block_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_block_fv_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of mesh block for Finite Volume 1D methods. This mesh block is based on a uniform, Cartesian cell-centered discretization of the domain.\n The nodes-cell numeration adopts the following convention: ```\n                  0     1     2          n    n+1\n +-----+-----+… +-----+-----+-----+… +-----+-----+… +-----+\n |     |     |    |     |     |     |    |     +     +    +     +\n |-ng  |-ng+1|    |  0  |  1  |  2  |    |  n  + n+1 +    + n+ng+\n |     |     |    |     |     |     |    |     +     +    +     +\n +-----+-----+… +-----+-----+-----+… +-----+-----+… +-----+ ```\n where + n is the number of cells + ng is the number of ghost cells The cell size is uniform and equals to h . Used By module~~openpde_mesh_block_fv_1d~~UsedByGraph module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_block_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_field_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_surface_fv_1d->module~openpde module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_mesh_fv_1d->module~openpde module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde var panmoduleopenpde_mesh_block_fv_1dUsedByGraph = svgPanZoom('#moduleopenpde_mesh_block_fv_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mesh_block_FV_1D Subroutines output set load_from_json Derived Types type, public :: mesh_block_FV_1D Concrete class of mesh block for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: n = 0 Number of nodes. integer(kind=I_P), public :: ng = 0 Number of ghost cells. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: output Output data. generic, public :: load => load_from_json Load block definition from file. procedure, public, pass(this) :: set Set block. procedure, private, pass(this) :: load_from_json Load block definition from jSON file. Subroutines private subroutine output (this, error) Output block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(in) :: this The block. integer(kind=I_P), intent(out), optional :: error Error status. private pure subroutine set (this, n, ng, h, error) Set block. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. integer(kind=I_P), intent(in), optional :: n Number of cells. integer(kind=I_P), intent(in), optional :: ng Number of ghost cells. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, json, block_number, error) Load block definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_block_FV_1D ), intent(inout) :: this The block. type(json_file), intent(inout) :: json JSON file handler. character(len=*), intent(in) :: block_number Block number ID, e.g. 'block5', 'block33'. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_mesh_block_fv_1d.html","title":"openpde_mesh_block_FV_1D – openpde"},{"text":"Uses: openpde_kinds module~~openpde_mesh_abstract~~UsesGraph module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract class of mesh. Used By module~~openpde_mesh_abstract~~UsedByGraph module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_mesh_abstract->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_mesh_abstract->module~openpde module~openpde_equation_adv openpde_equation_adv module~openpde_mesh_abstract->module~openpde_equation_adv module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_abstract->module~openpde_field_fv_1d module~openpde_mesh_fd_2d openpde_mesh_FD_2D module~openpde_mesh_abstract->module~openpde_mesh_fd_2d module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_abstract->module~openpde_field_fd_1d module~openpde_field_abstract openpde_field_abstract module~openpde_mesh_abstract->module~openpde_field_abstract module~openpde_multigrid_abstract openpde_multigrid_abstract module~openpde_mesh_abstract->module~openpde_multigrid_abstract module~openpde_v2f_abstract openpde_v2f_abstract module~openpde_mesh_abstract->module~openpde_v2f_abstract module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_mesh_abstract->module~openpde_mesh_fd_1d module~openpde_field_fd_2d openpde_field_FD_2D module~openpde_mesh_abstract->module~openpde_field_fd_2d module~openpde_field_surface_fv_1d->module~openpde module~openpde_equation_adv->module~openpde module~openpde_integrator_adv_euler_explicit openpde_integrator_adv_euler_explicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_equation_adv->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_equation_adv->module~openpde_integrator_adv_rk_implicit module~openpde_integrator_adv_abstract openpde_integrator_adv_abstract module~openpde_equation_adv->module~openpde_integrator_adv_abstract module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_mesh_fd_2d->module~openpde module~openpde_mesh_fd_2d->module~openpde_field_fd_2d module~openpde_spatial_operator_d2_fd_2d openpde_spatial_operator_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_v2f_fd_2d openpde_v2f_FD_2D module~openpde_mesh_fd_2d->module~openpde_v2f_fd_2d module~openpde_spatial_operator_d1_fd_2d openpde_spatial_operator_d1_FD_2D module~openpde_mesh_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_f2v_fd_2d openpde_f2v_FD_2D module~openpde_mesh_fd_2d->module~openpde_f2v_fd_2d module~openpde_f2m_d2_fd_2d openpde_f2m_d2_FD_2D module~openpde_mesh_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde_mesh_fv_1d->module~openpde module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_field_fd_1d->module~openpde_v2f_fd_1d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d proc~integrate~2 integrate module~openpde_field_fd_1d->proc~integrate~2 module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_abstract->module~openpde_field_surface_fv_1d module~openpde_field_abstract->module~openpde module~openpde_field_abstract->module~openpde_equation_adv module~openpde_field_abstract->module~openpde_field_fv_1d module~openpde_field_abstract->module~openpde_field_fd_1d module~openpde_field_abstract->module~openpde_multigrid_abstract module~openpde_field_abstract->module~openpde_v2f_abstract module~openpde_field_abstract->module~openpde_field_fd_2d module~openpde_field_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_field_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_field_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_field_abstract->module~openpde_integrator_adv_abstract module~openpde_field_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_abstract->module~openpde_v2f_fd_2d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_abstract->module~openpde_f2v_fd_2d module~openpde_field_abstract->module~openpde_f2m_d2_fd_2d module~openpde_field_abstract->module~openpde_v2f_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_abstract->module~openpde_f2m_d2_fd_1d module~openpde_field_abstract->module~openpde_f2m_d1_fd_1d module~openpde_field_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_abstract->module~openpde_f2v_fd_1d module~openpde_equation_abstract openpde_equation_abstract module~openpde_field_abstract->module~openpde_equation_abstract module~openpde_integrator_euler_explicit openpde_integrator_euler_explicit module~openpde_field_abstract->module~openpde_integrator_euler_explicit module~openpde_spatial_operator_abstract openpde_spatial_operator_abstract module~openpde_field_abstract->module~openpde_spatial_operator_abstract module~openpde_integrator_abstract openpde_integrator_abstract module~openpde_field_abstract->module~openpde_integrator_abstract module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_field_abstract->module~openpde_multigrid_fd_1d module~openpde_field_surface_abstract openpde_field_surface_abstract module~openpde_field_abstract->module~openpde_field_surface_abstract module~openpde_f2m_abstract openpde_f2m_abstract module~openpde_field_abstract->module~openpde_f2m_abstract module~openpde_f2v_abstract openpde_f2v_abstract module~openpde_field_abstract->module~openpde_f2v_abstract module~openpde_multigrid_abstract->module~openpde_equation_adv module~openpde_multigrid_abstract->module~openpde_multigrid_fd_1d module~openpde_v2f_abstract->module~openpde module~openpde_v2f_abstract->module~openpde_equation_adv module~openpde_v2f_abstract->module~openpde_v2f_fd_2d module~openpde_v2f_abstract->module~openpde_v2f_fd_1d module~openpde_mesh_fd_1d->module~openpde module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_mesh_fd_1d->module~openpde_v2f_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_mesh_fd_1d->module~openpde_f2v_fd_1d module~openpde_mesh_fd_1d->module~openpde_multigrid_fd_1d module~openpde_field_fd_2d->module~openpde module~openpde_field_fd_2d->module~openpde_spatial_operator_d2_fd_2d module~openpde_field_fd_2d->module~openpde_v2f_fd_2d module~openpde_field_fd_2d->module~openpde_spatial_operator_d1_fd_2d module~openpde_field_fd_2d->module~openpde_f2v_fd_2d module~openpde_field_fd_2d->module~openpde_f2m_d2_fd_2d module~openpde_integrator_adv_euler_explicit->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde module~openpde_integrator_adv_abstract->module~openpde module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_explicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_abstract->module~openpde_integrator_adv_rk_implicit module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_spatial_operator_d2_fd_2d->module~openpde module~openpde_v2f_fd_2d->module~openpde module~openpde_spatial_operator_d1_fd_2d->module~openpde module~openpde_f2v_fd_2d->module~openpde module~openpde_f2m_d2_fd_2d->module~openpde module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_v2f_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_equation_abstract->module~openpde module~openpde_equation_abstract->module~openpde_integrator_euler_explicit module~openpde_equation_abstract->module~openpde_integrator_abstract module~openpde_integrator_euler_explicit->module~openpde module~openpde_spatial_operator_abstract->module~openpde module~openpde_spatial_operator_d1_abstract openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d1_abstract module~openpde_spatial_operator_d2_abstract openpde_spatial_operator_d2_abstract module~openpde_spatial_operator_abstract->module~openpde_spatial_operator_d2_abstract module~openpde_integrator_abstract->module~openpde module~openpde_integrator_abstract->module~openpde_integrator_euler_explicit module~openpde_multigrid_fd_1d->module~openpde module~openpde_field_surface_abstract->module~openpde_field_surface_fv_1d module~openpde_field_surface_abstract->module~openpde module~openpde_f2m_abstract->module~openpde module~openpde_f2m_d2_abstract openpde_f2m_d2_abstract module~openpde_f2m_abstract->module~openpde_f2m_d2_abstract module~openpde_f2m_d1_abstract openpde_f2m_d1_abstract module~openpde_f2m_abstract->module~openpde_f2m_d1_abstract module~openpde_f2v_abstract->module~openpde module~openpde_f2v_abstract->module~openpde_equation_adv module~openpde_f2v_abstract->module~openpde_f2v_fd_2d module~openpde_f2v_abstract->module~openpde_f2v_fd_1d module~openpde_spatial_operator_d1_abstract->module~openpde module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fv_1d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_2d module~openpde_spatial_operator_d1_abstract->module~openpde_spatial_operator_d1_fd_1d module~openpde_spatial_operator_d2_abstract->module~openpde module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fv_1d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_2d module~openpde_spatial_operator_d2_abstract->module~openpde_spatial_operator_d2_fd_1d module~openpde_f2m_d2_abstract->module~openpde module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_2d module~openpde_f2m_d2_abstract->module~openpde_f2m_d2_fd_1d module~openpde_f2m_d1_abstract->module~openpde module~openpde_f2m_d1_abstract->module~openpde_f2m_d1_fd_1d var panmoduleopenpde_mesh_abstractUsedByGraph = svgPanZoom('#moduleopenpde_mesh_abstractUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces abstract_meshinit abstract_meshoutput Derived Types mesh Subroutines free Abstract Interfaces abstract interface Initialize mesh. private subroutine abstract_meshinit (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. abstract interface Output mesh. private subroutine abstract_meshoutput (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. Derived Types type, public, abstract :: mesh Abstract class of mesh. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. Type-Bound Procedures procedure(abstract_meshinit), public, pass(this) :: init Initilize mesh. procedure(abstract_meshoutput), public, pass(this) :: output Output mesh. procedure, public, pass(this) :: free Free dynamic memory. Subroutines private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh ), intent(inout) :: this The mesh.","tags":"","loc":"module/openpde_mesh_abstract.html","title":"openpde_mesh_abstract – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_mesh_abstract openpde_kinds vtk_fortran module~~openpde_mesh_fd_1d~~UsesGraph module~openpde_mesh_fd_1d openpde_mesh_FD_1D vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fd_1d json_module json_module json_module->module~openpde_mesh_fd_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_fd_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_kinds->module~openpde_mesh_abstract iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fd_1d module~openpde_mesh_abstract->module~openpde_mesh_fd_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of mesh for Finite Difference 1D methods. Used By module~~openpde_mesh_fd_1d~~UsedByGraph module~openpde_mesh_fd_1d openpde_mesh_FD_1D module~openpde_f2v_fd_1d openpde_f2v_FD_1D module~openpde_mesh_fd_1d->module~openpde_f2v_fd_1d module~openpde_multigrid_fd_1d openpde_multigrid_FD_1D module~openpde_mesh_fd_1d->module~openpde_multigrid_fd_1d module~openpde_spatial_operator_d2_fd_1d openpde_spatial_operator_d2_FD_1D module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_spatial_operator_d1_fd_1d openpde_spatial_operator_d1_FD_1D module~openpde_mesh_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_f2m_d2_fd_1d openpde_f2m_d2_FD_1D module~openpde_mesh_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d openpde_field_FD_1D module~openpde_mesh_fd_1d->module~openpde_field_fd_1d module~openpde_f2m_d1_fd_1d openpde_f2m_d1_FD_1D module~openpde_mesh_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_v2f_fd_1d openpde_v2f_FD_1D module~openpde_mesh_fd_1d->module~openpde_v2f_fd_1d module~openpde openpde module~openpde_mesh_fd_1d->module~openpde module~openpde_f2v_fd_1d->module~openpde module~openpde_multigrid_fd_1d->module~openpde module~openpde_spatial_operator_d2_fd_1d->module~openpde module~openpde_spatial_operator_d1_fd_1d->module~openpde module~openpde_f2m_d2_fd_1d->module~openpde module~openpde_field_fd_1d->module~openpde_f2v_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d2_fd_1d module~openpde_field_fd_1d->module~openpde_spatial_operator_d1_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d2_fd_1d module~openpde_field_fd_1d->module~openpde_f2m_d1_fd_1d module~openpde_field_fd_1d->module~openpde_v2f_fd_1d module~openpde_field_fd_1d->module~openpde module~openpde_integrator_adv_euler_implicit openpde_integrator_adv_euler_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_euler_implicit module~openpde_integrator_adv_rk_implicit openpde_integrator_adv_rk_implicit module~openpde_field_fd_1d->module~openpde_integrator_adv_rk_implicit proc~integrate~2 integrate module~openpde_field_fd_1d->proc~integrate~2 module~openpde_f2m_d1_fd_1d->module~openpde module~openpde_v2f_fd_1d->module~openpde module~openpde_integrator_adv_euler_implicit->module~openpde module~openpde_integrator_adv_rk_implicit->module~openpde Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces associate_mesh_FD_1D Derived Types mesh_FD_1D Functions associate_mesh_FD_1D_scalar associate_mesh_FD_1D_rank1 Subroutines init output set assign_mesh_FD_1D load_from_json Interfaces public interface associate_mesh_FD_1D private function associate_mesh_FD_1D_scalar (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer Finite Difference 1D mesh pointer. private function associate_mesh_FD_1D_rank1 (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input (:) Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer, (:) Finite Difference 1D mesh pointer. Derived Types type, public, extends( mesh ) :: mesh_FD_1D Concrete class of mesh for Finite Difference 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: n = 0 Number of points. integer(kind=I_P), public :: ng = 0 Number of ghost points. integer(kind=I_P), public :: s = 0 Number of replicas for steps/stages. real(kind=R_P), public :: h = 0._R_P Cell size. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize mesh. procedure, public, pass(this) :: output Output data. generic, public :: load => load_from_json Load mesh definition from file. procedure, public, pass(this) :: set Set mesh. generic, public :: assignment(=) => assign_mesh_FD_1D Overloading = operator. procedure, private, pass(lhs) :: assign_mesh_FD_1D Implementation of = operator. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. Functions private function associate_mesh_FD_1D_scalar (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer Finite Difference 1D mesh pointer. private function associate_mesh_FD_1D_rank1 (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input (:) Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FD_1D ),\n  pointer, (:) Finite Difference 1D mesh pointer. Subroutines private subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. private pure subroutine set (this, description, n, ng, s, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: n Number of points. integer(kind=I_P), intent(in), optional :: ng Number of ghost points. integer(kind=I_P), intent(in), optional :: s Number of replicas for steps/stages. real(kind=R_P), intent(in), optional :: h Cell size. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine assign_mesh_FD_1D (lhs, rhs) Implementation of = operator. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: lhs Left hand side. type( mesh_FD_1D ), intent(in) :: rhs Right hand side. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FD_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status.","tags":"","loc":"module/openpde_mesh_fd_1d.html","title":"openpde_mesh_FD_1D – openpde"},{"text":"Uses: iso_fortran_env json_module openpde_kinds openpde_mesh_abstract openpde_mesh_block_FV_1D stringifor vtk_fortran module~~openpde_mesh_fv_1d~~UsesGraph module~openpde_mesh_fv_1d openpde_mesh_FV_1D iso_fortran_env iso_fortran_env iso_fortran_env->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d openpde_mesh_block_FV_1D iso_fortran_env->module~openpde_mesh_block_fv_1d json_module json_module json_module->module~openpde_mesh_fv_1d json_module->module~openpde_mesh_block_fv_1d vtk_fortran vtk_fortran vtk_fortran->module~openpde_mesh_fv_1d stringifor stringifor stringifor->module~openpde_mesh_fv_1d module~openpde_mesh_block_fv_1d->module~openpde_mesh_fv_1d module~openpde_mesh_abstract openpde_mesh_abstract module~openpde_mesh_abstract->module~openpde_mesh_fv_1d module~openpde_kinds openpde_kinds module~openpde_kinds->module~openpde_mesh_fv_1d module~openpde_kinds->module~openpde_mesh_block_fv_1d module~openpde_kinds->module~openpde_mesh_abstract Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Concrete class of mesh for Finite Volume 1D methods. This mesh is based on a uniform, Cartesian cell-centered discretization of the domain,\n that is a multiblock mesh. Used By module~~openpde_mesh_fv_1d~~UsedByGraph module~openpde_mesh_fv_1d openpde_mesh_FV_1D module~openpde_field_surface_fv_1d openpde_field_surface_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_surface_fv_1d module~openpde openpde module~openpde_mesh_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d openpde_spatial_operator_d2_FV_1D module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_surface_block_fv_1d openpde_field_surface_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_spatial_operator_d1_fv_1d openpde_spatial_operator_d1_FV_1D module~openpde_mesh_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_fv_1d openpde_field_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_fv_1d module~openpde_field_block_fv_1d openpde_field_block_FV_1D module~openpde_mesh_fv_1d->module~openpde_field_block_fv_1d module~openpde_field_surface_fv_1d->module~openpde module~openpde_spatial_operator_d2_fv_1d->module~openpde module~openpde_field_surface_block_fv_1d->module~openpde_field_surface_fv_1d module~openpde_spatial_operator_d1_fv_1d->module~openpde module~openpde_field_fv_1d->module~openpde_field_surface_fv_1d module~openpde_field_fv_1d->module~openpde module~openpde_field_fv_1d->module~openpde_spatial_operator_d2_fv_1d module~openpde_field_fv_1d->module~openpde_spatial_operator_d1_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_surface_block_fv_1d module~openpde_field_block_fv_1d->module~openpde_field_fv_1d var panmoduleopenpde_mesh_fv_1dUsedByGraph = svgPanZoom('#moduleopenpde_mesh_fv_1dUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mesh_FV_1D Functions associate_mesh_FV_1D Subroutines init output set load_from_json free Derived Types type, public, extends( mesh ) :: mesh_FV_1D Concrete class of mesh for Finite Volume 1D methods. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description Mesh description. integer(kind=I_P), public :: nb Number of blocks. type(mesh_block_FV_1D), public, allocatable :: blocks (:) The blocks. Type-Bound Procedures procedure, public, pass(this) :: free Free dynamic memory. procedure, public, pass(this) :: init Initilize mesh. procedure, public, pass(this) :: output Output data. generic, public :: load => load_from_json Load mesh definition from file. procedure, public, pass(this) :: set Set mesh. procedure, private, pass(this) :: load_from_json Load mesh definition from jSON file. Functions public function associate_mesh_FV_1D (mesh_input, emsg) result(mesh_pointer) Check the type of the mesh passed as input and return a Finite Difference 1D mesh pointer associated to mesh. Arguments Type Intent Optional Attributes Name class( mesh ), intent(in), target :: mesh_input Input mesh. character(len=*), intent(in), optional :: emsg Auxiliary error message. Return Value class( mesh_FV_1D ),\n  pointer Finite Difference 1D mesh pointer. Subroutines private subroutine init (this, description, filename, error) Initialize mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description. character(len=*), intent(in), optional :: filename Initialization file name. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine output (this, error) Output mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(in) :: this The mesh. integer(kind=I_P), intent(out), optional :: error Error status. private pure subroutine set (this, description, nb, n, ng, h, error) Set mesh. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in), optional :: description Mesh description integer(kind=I_P), intent(in), optional :: nb Number of blocks. integer(kind=I_P), intent(in), optional :: n (1:) Number of points for each block. integer(kind=I_P), intent(in), optional :: ng (1:) Number of ghost points for each block. real(kind=R_P), intent(in), optional :: h (1:) Cell size for each block. integer(kind=I_P), intent(out), optional :: error Error status. private subroutine load_from_json (this, filename, error) Load mesh definition from JSON file. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh. character(len=*), intent(in) :: filename File name of JSON file. integer(kind=I_P), intent(out), optional :: error Error status. private elemental subroutine free (this) Free dynamic memory. Arguments Type Intent Optional Attributes Name class( mesh_FV_1D ), intent(inout) :: this The mesh.","tags":"","loc":"module/openpde_mesh_fv_1d.html","title":"openpde_mesh_FV_1D – openpde"}]}